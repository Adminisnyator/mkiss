diff --git a/meson.build b/meson.build
index 734810d..894a5ca 100644
--- a/meson.build
+++ b/meson.build
@@ -221,17 +221,13 @@ if host_is_linux
   network_manager_deps = [
     dependency('libnm', version: '>= 1.24.0'),
     dependency('libnma', version: '>= 1.8.0'),
-    dependency('mm-glib', version: '>= 0.7')
+    #dependency('mm-glib', version: '>= 0.7')
   ]
 endif
 config_h.set('BUILD_NETWORK', host_is_linux,
              description: 'Define to 1 to build the Network panel')
 config_h.set('HAVE_NETWORK_MANAGER', host_is_linux,
              description: 'Define to 1 if NetworkManager is available')
-config_h.set('BUILD_WWAN', host_is_linux,
-             description: 'Define to 1 to build the WWan panel')
-config_h.set('HAVE_WWAN', host_is_linux,
-             description: 'Define to 1 if WWan is available')
 
 if host_is_linux_not_s390
   # gnome-bluetooth
diff --git a/panels/meson.build b/panels/meson.build
index f603db9..846a08e 100644
--- a/panels/meson.build
+++ b/panels/meson.build
@@ -28,7 +28,6 @@ panels = [
   'universal-access',
   'usage',
   'user-accounts',
-  'wwan',
 ]
 
 if host_is_linux
diff --git a/panels/network/cc-network-panel.c b/panels/network/cc-network-panel.c
index bd4e55d..12dd9e9 100644
--- a/panels/network/cc-network-panel.c
+++ b/panels/network/cc-network-panel.c
@@ -32,7 +32,6 @@
 
 #include "net-device-bluetooth.h"
 #include "net-device-ethernet.h"
-#include "net-device-mobile.h"
 #include "net-device-wifi.h"
 #include "net-proxy.h"
 #include "net-vpn.h"
@@ -42,8 +41,6 @@
 #include "network-dialogs.h"
 #include "connection-editor/net-connection-editor.h"
 
-#include <libmm-glib.h>
-
 typedef enum {
         OPERATION_NULL,
         OPERATION_SHOW_DEVICE,
@@ -61,7 +58,6 @@ struct _CcNetworkPanel
         GHashTable       *nm_device_to_device;
 
         NMClient         *client;
-        MMManager        *modem_manager;
         gboolean          updating_device;
 
         /* widgets */
@@ -203,11 +199,9 @@ cc_network_panel_dispose (GObject *object)
         CcNetworkPanel *self = CC_NETWORK_PANEL (object);
 
         g_clear_object (&self->client);
-        g_clear_object (&self->modem_manager);
 
         g_clear_pointer (&self->bluetooth_devices, g_ptr_array_unref);
         g_clear_pointer (&self->ethernet_devices, g_ptr_array_unref);
-        g_clear_pointer (&self->mobile_devices, g_ptr_array_unref);
         g_clear_pointer (&self->vpns, g_ptr_array_unref);
         g_clear_pointer (&self->nm_device_to_device, g_hash_table_destroy);
 
@@ -252,11 +246,6 @@ panel_refresh_device_titles (CcNetworkPanel *self)
                 g_ptr_array_add (ndarray, device);
                 g_ptr_array_add (nmdarray, net_device_ethernet_get_device (device));
         }
-        for (i = 0; i < self->mobile_devices->len; i++) {
-                NetDeviceMobile *device = g_ptr_array_index (self->mobile_devices, i);
-                g_ptr_array_add (ndarray, device);
-                g_ptr_array_add (nmdarray, net_device_mobile_get_device (device));
-        }
 
         if (ndarray->len == 0)
                 return;
@@ -271,8 +260,6 @@ panel_refresh_device_titles (CcNetworkPanel *self)
                         net_device_bluetooth_set_title (NET_DEVICE_BLUETOOTH (devices[i]), nm_device_bt_get_name (NM_DEVICE_BT (nm_devices[i])));
                 else if (NET_IS_DEVICE_ETHERNET (devices[i]))
                         net_device_ethernet_set_title (NET_DEVICE_ETHERNET (devices[i]), titles[i]);
-                else if (NET_IS_DEVICE_MOBILE (devices[i]))
-                        net_device_mobile_set_title (NET_DEVICE_MOBILE (devices[i]), titles[i]);
         }
 }
 
@@ -336,11 +323,6 @@ handle_argv (CcNetworkPanel *self)
                 if (handle_argv_for_device (self, net_device_ethernet_get_device (device)))
                         return;
         }
-        for (i = 0; i < self->mobile_devices->len; i++) {
-                NetDeviceMobile *device = g_ptr_array_index (self->mobile_devices, i);
-                if (handle_argv_for_device (self, net_device_mobile_get_device (device)))
-                        return;
-        }
         for (i = 0; i < self->vpns->len; i++) {
                 NetVpn *vpn = g_ptr_array_index (self->vpns, i);
                 if (handle_argv_for_connection (self, net_vpn_get_connection (vpn)))
@@ -382,33 +364,11 @@ update_bluetooth_section (CcNetworkPanel *self)
         gtk_widget_set_visible (self->container_bluetooth, self->bluetooth_devices->len > 0);
 }
 
-static gboolean
-wwan_panel_supports_modem (GDBusObject *object)
-{
-        MMObject *mm_object;
-        MMModem *modem;
-        MMModemCapability capability, supported_capabilities;
-
-        g_assert (G_IS_DBUS_OBJECT (object));
-
-        supported_capabilities = MM_MODEM_CAPABILITY_GSM_UMTS | MM_MODEM_CAPABILITY_LTE;
-#if MM_CHECK_VERSION (1,14,0)
-        supported_capabilities |= MM_MODEM_CAPABILITY_5GNR;
-#endif
-
-        mm_object = MM_OBJECT (object);
-        modem = mm_object_get_modem (mm_object);
-        capability = mm_modem_get_current_capabilities (modem);
-
-        return capability & supported_capabilities;
-}
-
 static void
 panel_add_device (CcNetworkPanel *self, NMDevice *device)
 {
         NMDeviceType type;
         NetDeviceEthernet *device_ethernet;
-        NetDeviceMobile *device_mobile;
         NetDeviceBluetooth *device_bluetooth;
         g_autoptr(GDBusObject) modem_object = NULL;
 
@@ -431,33 +391,6 @@ panel_add_device (CcNetworkPanel *self, NMDevice *device)
                 g_ptr_array_add (self->ethernet_devices, device_ethernet);
                 g_hash_table_insert (self->nm_device_to_device, device, device_ethernet);
                 break;
-        case NM_DEVICE_TYPE_MODEM:
-                if (g_str_has_prefix (nm_device_get_udi (device), "/org/freedesktop/ModemManager1/Modem/")) {
-                        if (self->modem_manager == NULL) {
-                                g_warning ("Cannot grab information for modem at %s: No ModemManager support",
-                                           nm_device_get_udi (device));
-                                return;
-                        }
-
-                        modem_object = g_dbus_object_manager_get_object (G_DBUS_OBJECT_MANAGER (self->modem_manager),
-                                                                         nm_device_get_udi (device));
-                        if (modem_object == NULL) {
-                                g_warning ("Cannot grab information for modem at %s: Not found",
-                                           nm_device_get_udi (device));
-                                return;
-                        }
-
-                        /* This will be handled by cellular panel */
-                        if (wwan_panel_supports_modem (modem_object))
-                                return;
-                }
-
-                device_mobile = net_device_mobile_new (self->client, device, modem_object);
-                gtk_widget_show (GTK_WIDGET (device_mobile));
-                gtk_container_add (GTK_CONTAINER (self->box_wired), GTK_WIDGET (device_mobile));
-                g_ptr_array_add (self->mobile_devices, device_mobile);
-                g_hash_table_insert (self->nm_device_to_device, device, device_mobile);
-                break;
         case NM_DEVICE_TYPE_BT:
                 device_bluetooth = net_device_bluetooth_new (self->client, device);
                 gtk_widget_show (GTK_WIDGET (device_bluetooth));
@@ -800,13 +733,7 @@ cc_network_panel_init (CcNetworkPanel *self)
                 g_warning ("Error connecting to system D-Bus: %s",
                            error->message);
         } else {
-                self->modem_manager = mm_manager_new_sync (system_bus,
-                                                            G_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_NONE,
-                                                            NULL,
-                                                            &error);
-                if (self->modem_manager == NULL)
-                        g_warning ("Error connecting to ModemManager: %s",
-                                   error->message);
+            g_warning("ModemManager is not supported!");
         }
 
         /* add remote settings such as VPN settings as virtual devices */
diff --git a/panels/network/cc-wifi-hotspot-dialog.c b/panels/network/cc-wifi-hotspot-dialog.c
deleted file mode 100644
index ece2091..0000000
--- a/panels/network/cc-wifi-hotspot-dialog.c
+++ /dev/null
@@ -1,558 +0,0 @@
-/* -*- Mode: C; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* cc-wifi-hotspot-dialog.c
- *
- * Copyright 2019 Purism SPC
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- *
- * Author(s):
- *   Mohammed Sadiq <sadiq@sadiqpk.org>
- *
- * SPDX-License-Identifier: GPL-3.0-or-later
- */
-
-#undef G_LOG_DOMAIN
-#define G_LOG_DOMAIN "cc-wifi-hotspot-dialog"
-
-#include <config.h>
-#include <glib/gi18n.h>
-#include <libmm-glib.h>
-
-#include "list-box-helper.h"
-#include "cc-wifi-hotspot-dialog.h"
-#include "cc-network-resources.h"
-#include "ui-helpers.h"
-
-/**
- * @short_description: WWAN network type selection dialog
- */
-
-struct _CcWifiHotspotDialog
-{
-  GtkMessageDialog parent_instance;
-
-  GtkLabel        *connection_label;
-  GtkEntry        *name_entry;
-  GtkEntry        *password_entry;
-  GtkLabel        *error_label;
-  GtkButton       *ok_button;
-
-  GCancellable    *cancellable;
-
-  NMDeviceWifi    *device;
-  NMConnection    *connection;
-  gchar           *host_name;
-  gboolean         wpa_supported; /* WPA/WPA2 supported */
-};
-
-G_DEFINE_TYPE (CcWifiHotspotDialog, cc_wifi_hotspot_dialog, GTK_TYPE_MESSAGE_DIALOG)
-
-static gchar *
-get_random_wpa_key (void)
-{
-  gchar *key;
-  gint i;
-
-  key = g_malloc (10 * sizeof (key));
-  for (i = 0; i < 8; i++)
-    {
-      gint c = 0;
-      /* too many non alphanumeric characters are hard to remember for humans */
-      while (!g_ascii_isalnum (c))
-        c = g_random_int_range (33, 126);
-
-    key[i] = (gchar) c;
-  }
-  key[i] = '\0';
-
-  return key;
-}
-
-static gchar *
-get_random_wep_key (void)
-{
-  const gchar *hexdigits = "0123456789abcdef";
-  gchar *key;
-  gint i;
-
-  key = g_malloc (12 * sizeof (key));
-
-  /* generate a 10-digit hex WEP key */
-  for (i = 0; i < 10; i++)
-    {
-      gint digit;
-      digit = g_random_int_range (0, 16);
-      key[i] = hexdigits[digit];
-    }
-
-  key[i] = '\0';
-
-  return key;
-}
-
-static void
-wifi_hotspot_dialog_update_main_label (CcWifiHotspotDialog *self)
-{
-  NMAccessPoint *ap;
-  GBytes *ssid = NULL;
-  g_autofree gchar *active_ssid = NULL;
-  g_autofree gchar *escape = NULL;
-  g_autofree gchar *ssid_text = NULL;
-  g_autofree gchar *label = NULL;
-
-  g_assert (CC_IS_WIFI_HOTSPOT_DIALOG (self));
-
-  gtk_label_set_markup (self->connection_label, "");
-
-  if (!self->device)
-    return;
-
-  ap = nm_device_wifi_get_active_access_point (self->device);
-
-  if (ap)
-    ssid = nm_access_point_get_ssid (ap);
-  if (ssid)
-    active_ssid = nm_utils_ssid_to_utf8 (g_bytes_get_data (ssid, NULL), g_bytes_get_size (ssid));
-
-  if (!active_ssid || !*active_ssid)
-    return;
-
-  escape = g_markup_escape_text (active_ssid, -1);
-  ssid_text = g_strdup_printf ("<b>%s</b>", escape);
-  /* TRANSLATORS: ‘%s’ is a Wi-Fi Network(SSID) name */
-  label = g_strdup_printf (_("Turning on the hotspot will disconnect from %s, "
-                             "and it will not be possible to access the internet through Wi-Fi."), ssid_text);
-  gtk_label_set_markup (self->connection_label, label);
-}
-
-static void
-get_secrets_cb (GObject            *source_object,
-                GAsyncResult       *res,
-                gpointer            data)
-{
-  CcWifiHotspotDialog *self;
-  g_autoptr(GVariant) secrets = NULL;
-  NMSettingWirelessSecurity *security_setting;
-  const gchar *key;
-  g_autoptr(GError) error = NULL;
-
-  secrets = nm_remote_connection_get_secrets_finish (NM_REMOTE_CONNECTION (source_object), res, &error);
-  if (!secrets)
-    {
-      if (!g_error_matches (error, G_IO_ERROR, G_IO_ERROR_CANCELLED))
-        g_warning ("Could not get secrets: %s", error->message);
-      return;
-    }
-
-  self = CC_WIFI_HOTSPOT_DIALOG (data);
-
-  nm_connection_update_secrets (self->connection,
-                                NM_SETTING_WIRELESS_SECURITY_SETTING_NAME,
-                                secrets, &error);
-  if (error)
-    {
-      g_warning ("Error updating secrets: %s", error->message);
-      return;
-    }
-
-  security_setting = nm_connection_get_setting_wireless_security (self->connection);
-  if (self->wpa_supported)
-    key = nm_setting_wireless_security_get_psk (security_setting);
-  else
-    key = nm_setting_wireless_security_get_wep_key (security_setting, 0);
-
-  if (key)
-    gtk_entry_set_text (self->password_entry, key);
-
-  nm_connection_clear_secrets (self->connection);
-}
-
-static void
-wifi_hotspot_dialog_update_entries (CcWifiHotspotDialog *self)
-{
-  NMSettingWireless *setting;
-  GBytes *ssid;
-  g_autofree gchar *ssid_text = NULL;
-
-  g_assert (CC_IS_WIFI_HOTSPOT_DIALOG (self));
-
-  gtk_entry_set_text (self->name_entry, "");
-  gtk_entry_set_text (self->password_entry, "");
-
-  if (!self->connection)
-    return;
-
-  setting = nm_connection_get_setting_wireless (self->connection);
-
-  ssid = nm_setting_wireless_get_ssid (setting);
-  ssid_text = nm_utils_ssid_to_utf8 (g_bytes_get_data (ssid, NULL), g_bytes_get_size (ssid));
-
-  if (!ssid_text && self->host_name)
-    ssid_text = g_strdup (self->host_name);
-
-  if (ssid_text)
-    gtk_entry_set_text (self->name_entry, ssid_text);
-
-  if (!NM_IS_REMOTE_CONNECTION (self->connection))
-    return;
-
-  /* Secrets may not be already loaded, we have to manually load it. */
-  nm_remote_connection_get_secrets_async (NM_REMOTE_CONNECTION (self->connection),
-                                          NM_SETTING_WIRELESS_SECURITY_SETTING_NAME,
-                                          self->cancellable,
-                                          get_secrets_cb,
-                                          self);
-}
-
-static gboolean
-hotspot_password_is_valid (CcWifiHotspotDialog *self,
-                           const gchar         *password)
-{
-  g_assert (CC_IS_WIFI_HOTSPOT_DIALOG (self));
-
-  if (!self->device)
-    return FALSE;
-
-  if (!password || !*password)
-    return TRUE;
-
-  if (self->wpa_supported)
-    return nm_utils_wpa_psk_valid (password);
-  else
-    return nm_utils_wep_key_valid (password, NM_WEP_KEY_TYPE_KEY);
-}
-
-static void
-hotspot_entry_changed_cb (CcWifiHotspotDialog *self)
-{
-  const gchar *ssid, *password, *error_label;
-  gboolean valid_ssid, valid_password;
-
-  g_assert (CC_IS_WIFI_HOTSPOT_DIALOG (self));
-
-  valid_ssid = valid_password = FALSE;
-  ssid = gtk_entry_get_text (self->name_entry);
-  password = gtk_entry_get_text (self->password_entry);
-
-  if (ssid && *ssid)
-    {
-      valid_ssid = TRUE;
-      widget_unset_error (GTK_WIDGET (self->name_entry));
-    }
-  else
-    widget_set_error (GTK_WIDGET (self->name_entry));
-
-  valid_password = hotspot_password_is_valid (self, password);
-
-  if (valid_password)
-    {
-      error_label = "";
-      widget_unset_error (GTK_WIDGET (self->password_entry));
-    }
-  else
-    {
-      if (strlen (password) < 8)
-        {
-          error_label = _("Must have a minimum of 8 characters");
-        }
-      else
-        {
-          guint max_chars = self->wpa_supported ? 63 : 16;
-          error_label = g_strdup_printf (_("Must have a maximum of %d characters"), max_chars);
-        }
-
-      widget_set_error (GTK_WIDGET(self->password_entry));
-    }
-
-  gtk_label_set_label (self->error_label, error_label);
-  gtk_widget_set_sensitive (GTK_WIDGET (self->ok_button),
-                            valid_ssid && valid_password);
-}
-
-static void
-generate_password_clicked_cb (CcWifiHotspotDialog *self)
-{
-  g_autofree gchar *key = NULL;
-
-  g_assert (CC_IS_WIFI_HOTSPOT_DIALOG (self));
-
-  if (self->wpa_supported)
-    key = get_random_wpa_key ();
-  else
-    key = get_random_wep_key ();
-
-  gtk_entry_set_text (self->password_entry, key);
-}
-
-static void
-hotspot_update_wireless_settings (CcWifiHotspotDialog *self)
-{
-  NMSettingWireless *setting;
-  g_autoptr(GBytes) ssid = NULL;
-  const gchar *ssid_text;
-  NMDeviceWifiCapabilities capabilities;
-
-  g_assert (CC_IS_WIFI_HOTSPOT_DIALOG (self));
-
-  if (nm_connection_get_setting_wireless (self->connection) == NULL)
-    nm_connection_add_setting (self->connection, nm_setting_wireless_new ());
-
-  setting = nm_connection_get_setting_wireless (self->connection);
-
-  capabilities = nm_device_wifi_get_capabilities (self->device);
-  if (capabilities & NM_WIFI_DEVICE_CAP_AP)
-    g_object_set (setting, "mode", "ap", NULL);
-  else
-    g_object_set (setting, "mode", "adhoc", NULL);
-
-  ssid_text = gtk_entry_get_text (self->name_entry);
-  ssid = g_bytes_new (ssid_text, strlen (ssid_text));
-  g_object_set (setting, "ssid", ssid, NULL);
-}
-
-static void
-hotspot_update_wireless_security_settings (CcWifiHotspotDialog *self)
-{
-  NMSettingWirelessSecurity *setting;
-  const gchar *value, *key_type;
-
-  g_assert (CC_IS_WIFI_HOTSPOT_DIALOG (self));
-
-  if (nm_connection_get_setting_wireless_security (self->connection) == NULL)
-    nm_connection_add_setting (self->connection, nm_setting_wireless_security_new ());
-
-  setting = nm_connection_get_setting_wireless_security (self->connection);
-  nm_setting_wireless_security_clear_protos (setting);
-  nm_setting_wireless_security_clear_pairwise (setting);
-  nm_setting_wireless_security_clear_groups (setting);
-  value = gtk_entry_get_text (self->password_entry);
-
-  if (self->wpa_supported)
-    key_type = "psk";
-  else
-    key_type = "wep-key0";
-
-  if (self->wpa_supported)
-    g_object_set (setting, "key-mgmt", "wpa-psk", NULL);
-  else
-    g_object_set (setting,
-                  "key-mgmt", "none",
-                  "wep-key-type", NM_WEP_KEY_TYPE_KEY,
-                  NULL);
-
-  if (!value || !*value)
-    {
-      g_autofree gchar *key = NULL;
-
-      if (self->wpa_supported)
-        key = get_random_wpa_key ();
-      else
-        key = get_random_wep_key ();
-
-      g_object_set (setting, key_type, key, NULL);
-    }
-  else
-    g_object_set (setting, key_type, value, NULL);
-
-  if (self->wpa_supported)
-    {
-      NMDeviceWifiCapabilities caps;
-
-      caps = nm_device_wifi_get_capabilities (self->device);
-
-      if (caps & NM_WIFI_DEVICE_CAP_RSN)
-        {
-          nm_setting_wireless_security_add_proto (setting, "rsn");
-          nm_setting_wireless_security_add_pairwise (setting, "ccmp");
-          nm_setting_wireless_security_add_group (setting, "ccmp");
-        }
-      else if (caps & NM_WIFI_DEVICE_CAP_WPA)
-        {
-          nm_setting_wireless_security_add_proto (setting, "wpa");
-          nm_setting_wireless_security_add_pairwise (setting, "tkip");
-          nm_setting_wireless_security_add_group (setting, "tkip");
-        }
-    }
-}
-
-static void
-cc_wifi_hotspot_dialog_finalize (GObject *object)
-{
-  CcWifiHotspotDialog *self = (CcWifiHotspotDialog *)object;
-
-  g_cancellable_cancel(self->cancellable);
-  g_clear_object (&self->cancellable);
-  g_clear_pointer (&self->host_name, g_free);
-  g_clear_object (&self->device);
-  g_clear_object (&self->connection);
-
-  G_OBJECT_CLASS (cc_wifi_hotspot_dialog_parent_class)->finalize (object);
-}
-
-static void
-cc_wifi_hotspot_dialog_show (GtkWidget *widget)
-{
-  CcWifiHotspotDialog *self = (CcWifiHotspotDialog *)widget;
-  g_warn_if_fail (self->device != NULL);
-
-  gtk_widget_grab_focus (GTK_WIDGET (self->ok_button));
-  wifi_hotspot_dialog_update_entries (self);
-
-  if (!self->connection)
-    if (self->host_name)
-      gtk_entry_set_text (self->name_entry, self->host_name);
-
-  GTK_WIDGET_CLASS (cc_wifi_hotspot_dialog_parent_class)->show (widget);
-}
-
-static void
-cc_wifi_hotspot_dialog_response (GtkDialog *dialog,
-                                 gint       response_id)
-{
-  CcWifiHotspotDialog *self = CC_WIFI_HOTSPOT_DIALOG (dialog);
-  NMSetting *setting;
-
-  if (response_id != GTK_RESPONSE_APPLY)
-    return;
-
-  if (!self->connection)
-    self->connection = NM_CONNECTION (nm_simple_connection_new ());
-
-  if (nm_connection_get_setting_connection (self->connection) == NULL)
-    {
-      setting = nm_setting_connection_new ();
-      g_object_set (setting,
-                    "type", "802-11-wireless",
-                    "id", "Hotspot",
-                    "autoconnect", FALSE,
-                    NULL);
-      nm_connection_add_setting (self->connection, setting);
-    }
-
-  if (nm_connection_get_setting_ip4_config (self->connection) == NULL)
-    {
-      setting = nm_setting_ip4_config_new ();
-      g_object_set (setting, "method", "shared", NULL);
-      nm_connection_add_setting (self->connection, setting);
-    }
-
-  hotspot_update_wireless_settings (self);
-  hotspot_update_wireless_security_settings (self);
-}
-
-static void
-cc_wifi_hotspot_dialog_class_init (CcWifiHotspotDialogClass *klass)
-{
-  GtkDialogClass *dialog_class = GTK_DIALOG_CLASS (klass);
-  GtkWidgetClass *widget_class = GTK_WIDGET_CLASS (klass);
-  GObjectClass   *object_class = G_OBJECT_CLASS (klass);
-
-  object_class->finalize = cc_wifi_hotspot_dialog_finalize;
-
-  widget_class->show = cc_wifi_hotspot_dialog_show;
-  dialog_class->response = cc_wifi_hotspot_dialog_response;
-
-  gtk_widget_class_set_template_from_resource (widget_class,
-                                               "/org/gnome/control-center/network/cc-wifi-hotspot-dialog.ui");
-
-  gtk_widget_class_bind_template_child (widget_class, CcWifiHotspotDialog, connection_label);
-  gtk_widget_class_bind_template_child (widget_class, CcWifiHotspotDialog, name_entry);
-  gtk_widget_class_bind_template_child (widget_class, CcWifiHotspotDialog, password_entry);
-  gtk_widget_class_bind_template_child (widget_class, CcWifiHotspotDialog, error_label);
-  gtk_widget_class_bind_template_child (widget_class, CcWifiHotspotDialog, ok_button);
-
-  gtk_widget_class_bind_template_callback (widget_class, hotspot_entry_changed_cb);
-  gtk_widget_class_bind_template_callback (widget_class, generate_password_clicked_cb);
-}
-
-static void
-cc_wifi_hotspot_dialog_init (CcWifiHotspotDialog *self)
-{
-  g_autofree gchar *title = NULL;
-
-  self->cancellable = g_cancellable_new ();
-
-  gtk_widget_init_template (GTK_WIDGET (self));
-
-  title = g_strdup_printf ("<big><b>%s</b></big>", _("Turn On Wi-Fi Hotspot?"));
-  gtk_message_dialog_set_markup (GTK_MESSAGE_DIALOG (self), title);
-}
-
-CcWifiHotspotDialog *
-cc_wifi_hotspot_dialog_new (GtkWindow *parent_window)
-{
-  g_return_val_if_fail (GTK_IS_WINDOW (parent_window), NULL);
-
-  return g_object_new (CC_TYPE_WIFI_HOTSPOT_DIALOG,
-                       "transient-for", parent_window,
-                       "message-type", GTK_MESSAGE_OTHER,
-                       NULL);
-}
-
-void
-cc_wifi_hotspot_dialog_set_hostname (CcWifiHotspotDialog *self,
-                                     const gchar         *host_name)
-{
-  g_return_if_fail (CC_IS_WIFI_HOTSPOT_DIALOG (self));
-
-  g_clear_pointer (&self->host_name, g_free);
-  self->host_name = g_strdup (host_name);
-}
-
-void
-cc_wifi_hotspot_dialog_set_device (CcWifiHotspotDialog *self,
-                                   NMDeviceWifi        *device)
-{
-  g_return_if_fail (CC_IS_WIFI_HOTSPOT_DIALOG (self));
-  g_return_if_fail (NM_IS_DEVICE_WIFI (device));
-
-  g_set_object (&self->device, device);
-
-  if (device)
-    {
-      NMDeviceWifiCapabilities caps;
-
-      caps = nm_device_wifi_get_capabilities (device);
-      self->wpa_supported = FALSE;
-
-      if (caps & NM_WIFI_DEVICE_CAP_AP)
-        if (caps & (NM_WIFI_DEVICE_CAP_RSN | NM_WIFI_DEVICE_CAP_WPA))
-          self->wpa_supported = TRUE;
-    }
-
-  wifi_hotspot_dialog_update_main_label (self);
-}
-
-NMConnection *
-cc_wifi_hotspot_dialog_get_connection (CcWifiHotspotDialog *self)
-{
-  g_return_val_if_fail (CC_IS_WIFI_HOTSPOT_DIALOG (self), NULL);
-
-  return self->connection;
-}
-
-void
-cc_wifi_hotspot_dialog_set_connection (CcWifiHotspotDialog *self,
-                                       NMConnection        *connection)
-{
-  NMSettingWireless *setting;
-
-  g_return_if_fail (CC_IS_WIFI_HOTSPOT_DIALOG (self));
-  g_return_if_fail (NM_IS_CONNECTION (connection));
-
-  setting = nm_connection_get_setting_wireless (connection);
-  g_return_if_fail (setting);
-
-  g_set_object (&self->connection, connection);
-}
diff --git a/panels/network/cc-wifi-hotspot-dialog.h b/panels/network/cc-wifi-hotspot-dialog.h
deleted file mode 100644
index 585d7f1..0000000
--- a/panels/network/cc-wifi-hotspot-dialog.h
+++ /dev/null
@@ -1,44 +0,0 @@
-/* -*- Mode: C; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* wifi-hotspot-dialog.h
- *
- * Copyright 2019 Purism SPC
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- *
- * Author(s):
- *   Mohammed Sadiq <sadiq@sadiqpk.org>
- *
- * SPDX-License-Identifier: GPL-3.0-or-later
- */
-
-#pragma once
-
-#include <gtk/gtk.h>
-#include <NetworkManager.h>
-
-G_BEGIN_DECLS
-
-#define CC_TYPE_WIFI_HOTSPOT_DIALOG (cc_wifi_hotspot_dialog_get_type())
-G_DECLARE_FINAL_TYPE (CcWifiHotspotDialog, cc_wifi_hotspot_dialog, CC, WIFI_HOTSPOT_DIALOG, GtkMessageDialog)
-
-CcWifiHotspotDialog *cc_wifi_hotspot_dialog_new            (GtkWindow           *parent_window);
-void                 cc_wifi_hotspot_dialog_set_hostname   (CcWifiHotspotDialog *self,
-                                                            const gchar         *host_name);
-void                 cc_wifi_hotspot_dialog_set_device     (CcWifiHotspotDialog *self,
-                                                            NMDeviceWifi        *device);
-NMConnection        *cc_wifi_hotspot_dialog_get_connection (CcWifiHotspotDialog *self);
-void                 cc_wifi_hotspot_dialog_set_connection (CcWifiHotspotDialog *self,
-                                                            NMConnection        *connection);
-
-G_END_DECLS
diff --git a/panels/network/cc-wifi-hotspot-dialog.ui b/panels/network/cc-wifi-hotspot-dialog.ui
deleted file mode 100644
index 619e051..0000000
--- a/panels/network/cc-wifi-hotspot-dialog.ui
+++ /dev/null
@@ -1,139 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<interface>
-  <template class="CcWifiHotspotDialog" parent="GtkMessageDialog">
-    <property name="modal">1</property>
-    <property name="destroy-with-parent">1</property>
-    <property name="message-type">other</property>
-    <signal name="delete-event" handler="gtk_widget_hide_on_delete"/>
-
-    <child internal-child="message_area">
-      <object class="GtkBox">
-        <property name="visible">1</property>
-        <property name="margin-top">0</property>
-
-        <child>
-          <object class="GtkLabel" id="label">
-            <property name="visible">1</property>
-            <property name="wrap">1</property>
-            <property name="max-width-chars">50</property>
-            <property name="label" translatable="yes">Wi-Fi hotspot allows others to share your internet connection, by creating a Wi-Fi network that they can connect to. To do this, you must have an internet connection through a source other than Wi-Fi.</property>
-            <property name="xalign">0.0</property>
-          </object>
-        </child>
-
-        <child>
-          <object class="GtkLabel" id="connection_label">
-            <property name="visible">1</property>
-            <property name="margin-bottom">18</property>
-            <property name="wrap">1</property>
-            <property name="max-width-chars">40</property>
-            <property name="use-markup">1</property>
-            <property name="xalign">0.0</property>
-          </object>
-        </child>
-
-        <child>
-          <object class="GtkGrid">
-            <property name="visible">1</property>
-            <property name="row-spacing">6</property>
-            <property name="column-spacing">12</property>
-
-            <!-- Hotspot SSID Name -->
-            <child>
-              <object class="GtkLabel">
-                <property name="label" translatable="yes">Network Name</property>
-                <property name="halign">end</property>
-                <property name="visible">1</property>
-              </object>
-              <packing>
-                <property name="left-attach">0</property>
-                <property name="top-attach">0</property>
-              </packing>
-            </child>
-            <child>
-              <object class="GtkEntry" id="name_entry">
-                <property name="visible">1</property>
-                <property name="hexpand">1</property>
-                <property name="max-length">64</property>
-                <signal name="changed" handler="hotspot_entry_changed_cb" swapped="yes" />
-              </object>
-              <packing>
-                <property name="left-attach">1</property>
-                <property name="top-attach">0</property>
-              </packing>
-            </child>
-
-            <!-- Hotspot Password -->
-            <child>
-              <object class="GtkLabel">
-                <property name="label" translatable="yes">Password</property>
-                <property name="halign">end</property>
-                <property name="visible">1</property>
-              </object>
-              <packing>
-                <property name="left-attach">0</property>
-                <property name="top-attach">1</property>
-              </packing>
-            </child>
-            <child>
-              <object class="GtkEntry" id="password_entry">
-                <property name="visible">1</property>
-                <property name="max-length">64</property>
-                <property name="secondary-icon-name">view-refresh-symbolic</property>
-                <property name="secondary-icon-tooltip-text" translatable="yes">Generate Random Password</property>
-                <property name="placeholder-text" translatable="yes">Autogenerate Password</property>
-                <signal name="icon-press" handler="generate_password_clicked_cb" swapped="yes" />
-                <signal name="changed" handler="hotspot_entry_changed_cb" swapped="yes" />
-              </object>
-              <packing>
-                <property name="left-attach">1</property>
-                <property name="top-attach">1</property>
-              </packing>
-            </child>
-
-            <!-- Error Label -->
-            <child>
-              <object class="GtkLabel" id="error_label">
-                <property name="halign">start</property>
-                <property name="visible">1</property>
-                <style>
-                  <class name="dim-label" />
-                </style>
-                <attributes>
-                  <attribute name="scale" value="0.83"/>
-                </attributes>
-              </object>
-              <packing>
-                <property name="left-attach">1</property>
-                <property name="top-attach">2</property>
-              </packing>
-            </child>
-
-          </object>
-        </child>
-
-      </object>
-    </child>
-
-    <child type="action">
-      <object class="GtkButton" id="cancel_button">
-        <property name="visible">1</property>
-        <property name="use-underline">1</property>
-        <property name="label" translatable="yes">_Cancel</property>
-      </object>
-    </child>
-    <child type="action">
-      <object class="GtkButton" id="ok_button">
-        <property name="visible">1</property>
-        <property name="can-default">1</property>
-        <property name="use-underline">1</property>
-        <property name="label" translatable="yes">_Turn On</property>
-      </object>
-    </child>
-
-    <action-widgets>
-      <action-widget response="cancel">cancel_button</action-widget>
-      <action-widget response="apply" default="true">ok_button</action-widget>
-    </action-widgets>
-  </template>
-</interface>
diff --git a/panels/network/meson.build b/panels/network/meson.build
index d7cd6e4..e80fc39 100644
--- a/panels/network/meson.build
+++ b/panels/network/meson.build
@@ -41,10 +41,8 @@ sources = files(
   'cc-wifi-connection-row.c',
   'cc-wifi-connection-list.c',
   'cc-wifi-panel.c',
-  'cc-wifi-hotspot-dialog.c',
   'net-device-bluetooth.c',
   'net-device-ethernet.c',
-  'net-device-mobile.c',
   'net-device-wifi.c',
   'net-proxy.c',
   'net-vpn.c',
@@ -57,10 +55,8 @@ resource_data = files(
   'cc-network-panel.ui',
   'cc-wifi-connection-row.ui',
   'cc-wifi-panel.ui',
-  'cc-wifi-hotspot-dialog.ui',
   'network-bluetooth.ui',
   'network-ethernet.ui',
-  'network-mobile.ui',
   'network-proxy.ui',
   'network-vpn.ui',
   'network-wifi.ui',
diff --git a/panels/network/net-device-mobile.c b/panels/network/net-device-mobile.c
deleted file mode 100644
index 886180e..0000000
--- a/panels/network/net-device-mobile.c
+++ /dev/null
@@ -1,913 +0,0 @@
-/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
- *
- * Copyright (C) 2011-2012 Richard Hughes <richard@hughsie.com>
- * Copyright (C) 2013 Aleksander Morgado <aleksander@gnu.org>
- *
- * Licensed under the GNU General Public License Version 2
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
- */
-
-#include "config.h"
-
-#include <glib-object.h>
-#include <glib/gi18n.h>
-
-#include <NetworkManager.h>
-#include <libmm-glib.h>
-#include <nma-mobile-providers.h>
-
-#include "panel-common.h"
-#include "network-dialogs.h"
-#include "net-device-mobile.h"
-
-static void nm_device_mobile_refresh_ui (NetDeviceMobile *self);
-
-struct _NetDeviceMobile
-{
-        GtkBox        parent;
-
-        GtkLabel     *device_label;
-        GtkSwitch    *device_off_switch;
-        GtkLabel     *dns4_heading_label;
-        GtkLabel     *dns4_label;
-        GtkLabel     *dns6_heading_label;
-        GtkLabel     *dns6_label;
-        GtkLabel     *imei_heading_label;
-        GtkLabel     *imei_label;
-        GtkLabel     *ipv4_heading_label;
-        GtkLabel     *ipv4_label;
-        GtkLabel     *ipv6_heading_label;
-        GtkLabel     *ipv6_label;
-        GtkListStore *mobile_connections_list_store;
-        GtkComboBox  *network_combo;
-        GtkLabel     *network_label;
-        GtkButton    *options_button;
-        GtkLabel     *provider_heading_label;
-        GtkLabel     *provider_label;
-        GtkLabel     *route_heading_label;
-        GtkLabel     *route_label;
-        GtkLabel     *status_label;
-
-        NMClient     *client;
-        NMDevice     *device;
-        GDBusObject  *modem;
-        GCancellable *cancellable;
-
-        gboolean    updating_device;
-
-        /* Old MM < 0.7 support */
-        GDBusProxy *gsm_proxy;
-        GDBusProxy *cdma_proxy;
-
-        /* New MM >= 0.7 support */
-        MMObject   *mm_object;
-
-        NMAMobileProvidersDatabase *mpd;
-};
-
-enum {
-        COLUMN_ID,
-        COLUMN_TITLE,
-        COLUMN_LAST
-};
-
-G_DEFINE_TYPE (NetDeviceMobile, net_device_mobile, GTK_TYPE_BOX)
-
-static void
-connection_activate_cb (GObject *source_object,
-                        GAsyncResult *res,
-                        gpointer user_data)
-{
-        g_autoptr(GError) error = NULL;
-
-        if (!nm_client_activate_connection_finish (NM_CLIENT (source_object), res, &error)) {
-                /* failed to activate */
-                nm_device_mobile_refresh_ui (user_data);
-        }
-}
-
-static void
-network_combo_changed_cb (NetDeviceMobile *self)
-{
-        gboolean ret;
-        g_autofree gchar *object_path = NULL;
-        GtkTreeIter iter;
-        GtkTreeModel *model;
-        NMConnection *connection;
-        GtkWidget *toplevel;
-
-        if (self->updating_device)
-                return;
-
-        ret = gtk_combo_box_get_active_iter (self->network_combo, &iter);
-        if (!ret)
-                return;
-
-        /* get entry */
-        model = gtk_combo_box_get_model (self->network_combo);
-        gtk_tree_model_get (model, &iter,
-                            COLUMN_ID, &object_path,
-                            -1);
-        if (g_strcmp0 (object_path, NULL) == 0) {
-                toplevel = gtk_widget_get_toplevel (GTK_WIDGET (self));
-                cc_network_panel_connect_to_3g_network (toplevel, self->client, self->device);
-                return;
-        }
-
-        /* activate the connection */
-        g_debug ("try to switch to connection %s", object_path);
-        connection = (NMConnection*) nm_client_get_connection_by_path (self->client, object_path);
-        if (connection != NULL) {
-                nm_device_disconnect (self->device, NULL, NULL);
-                nm_client_activate_connection_async (self->client,
-                                                     connection,
-                                                     self->device, NULL, NULL,
-                                                     connection_activate_cb,
-                                                     self);
-                return;
-        }
-}
-
-static void
-mobilebb_enabled_toggled (NetDeviceMobile *self)
-{
-        gboolean enabled = FALSE;
-
-        if (nm_client_wwan_get_enabled (self->client)) {
-                NMDeviceState state;
-
-                state = nm_device_get_state (self->device);
-                if (state == NM_DEVICE_STATE_UNKNOWN ||
-                    state == NM_DEVICE_STATE_UNMANAGED ||
-                    state == NM_DEVICE_STATE_UNAVAILABLE ||
-                    state == NM_DEVICE_STATE_DISCONNECTED ||
-                    state == NM_DEVICE_STATE_DEACTIVATING ||
-                    state == NM_DEVICE_STATE_FAILED) {
-                        enabled = FALSE;
-                } else {
-                        enabled = TRUE;
-                }
-        }
-
-        self->updating_device = TRUE;
-        gtk_switch_set_active (self->device_off_switch, enabled);
-        self->updating_device = FALSE;
-}
-
-static void
-device_add_device_connections (NetDeviceMobile *self,
-                               NMDevice *nm_device,
-                               GtkListStore *liststore,
-                               GtkComboBox *combobox)
-{
-        GSList *list, *l;
-        GtkTreeIter treeiter;
-        NMActiveConnection *active_connection;
-        NMConnection *connection;
-
-        /* get the list of available connections for this device */
-        list = net_device_get_valid_connections (self->client, nm_device);
-        gtk_list_store_clear (liststore);
-        active_connection = nm_device_get_active_connection (nm_device);
-        for (l = list; l; l = g_slist_next (l)) {
-                connection = NM_CONNECTION (l->data);
-                gtk_list_store_append (liststore, &treeiter);
-                gtk_list_store_set (liststore,
-                                    &treeiter,
-                                    COLUMN_ID, nm_connection_get_uuid (connection),
-                                    COLUMN_TITLE, nm_connection_get_id (connection),
-                                    -1);
-
-                /* is this already activated? */
-                if (active_connection != NULL &&
-                    g_strcmp0 (nm_connection_get_uuid (connection),
-                               nm_active_connection_get_uuid (active_connection)) == 0) {
-                        self->updating_device = TRUE;
-                        gtk_combo_box_set_active_iter (combobox, &treeiter);
-                        self->updating_device = FALSE;
-                }
-        }
-
-        /* add new connection entry */
-        gtk_list_store_append (liststore, &treeiter);
-        gtk_list_store_set (liststore,
-                            &treeiter,
-                            COLUMN_ID, NULL,
-                            COLUMN_TITLE, _("Add new connection"),
-                            -1);
-
-        g_slist_free (list);
-}
-
-static void
-device_mobile_refresh_equipment_id (NetDeviceMobile *self)
-{
-        const gchar *equipment_id = NULL;
-
-        if (self->mm_object != NULL) {
-                MMModem *modem;
-
-                /* Modem interface should always be present */
-                modem = mm_object_peek_modem (self->mm_object);
-                equipment_id = mm_modem_get_equipment_identifier (modem);
-
-                /* Set equipment ID */
-                if (equipment_id != NULL) {
-                        g_debug ("[%s] Equipment ID set to '%s'",
-                                 mm_object_get_path (self->mm_object),
-                                 equipment_id);
-                }
-        } else {
-                /* Assume old MM handling */
-                equipment_id = g_object_get_data (G_OBJECT (self),
-                                                  "ControlCenter::EquipmentIdentifier");
-        }
-
-        gtk_label_set_label (self->imei_label, equipment_id);
-        gtk_widget_set_visible (GTK_WIDGET (self->imei_heading_label), equipment_id != NULL);
-        gtk_widget_set_visible (GTK_WIDGET (self->imei_label), equipment_id != NULL);
-}
-
-static gchar *
-device_mobile_find_provider (NetDeviceMobile *self,
-                             const gchar     *mccmnc,
-                             guint32          sid)
-{
-        NMAMobileProvider *provider;
-        GString *name = NULL;
-
-        if (self->mpd == NULL) {
-                g_autoptr(GError) error = NULL;
-
-                /* Use defaults */
-                self->mpd = nma_mobile_providers_database_new_sync (NULL, NULL, NULL, &error);
-                if (self->mpd == NULL) {
-                        g_debug ("Couldn't load mobile providers database: %s",
-                                 error ? error->message : "");
-                        return NULL;
-                }
-        }
-
-        if (mccmnc != NULL) {
-                provider = nma_mobile_providers_database_lookup_3gpp_mcc_mnc (self->mpd, mccmnc);
-                if (provider != NULL)
-                        name = g_string_new (nma_mobile_provider_get_name (provider));
-        }
-
-        if (sid != 0) {
-                provider = nma_mobile_providers_database_lookup_cdma_sid (self->mpd, sid);
-                if (provider != NULL) {
-                        if (name == NULL)
-                                name = g_string_new (nma_mobile_provider_get_name (provider));
-                        else
-                                g_string_append_printf (name, ", %s", nma_mobile_provider_get_name (provider));
-                }
-        }
-
-        return (name != NULL ? g_string_free (name, FALSE) : NULL);
-}
-
-static void
-device_mobile_refresh_operator_name (NetDeviceMobile *self)
-{
-        g_autofree gchar *operator_name = NULL;
-
-        if (self->mm_object != NULL) {
-                MMModem3gpp *modem_3gpp;
-                MMModemCdma *modem_cdma;
-
-                modem_3gpp = mm_object_peek_modem_3gpp (self->mm_object);
-                modem_cdma = mm_object_peek_modem_cdma (self->mm_object);
-
-                if (modem_3gpp != NULL) {
-                        const gchar *operator_name_unsafe;
-
-                        operator_name_unsafe = mm_modem_3gpp_get_operator_name (modem_3gpp);
-                        if (operator_name_unsafe != NULL && operator_name_unsafe[0] != '\0')
-                                operator_name = g_strescape (operator_name_unsafe, NULL);
-                }
-
-                /* If not directly given in the 3GPP interface, try to guess from
-                 * MCCMNC/SID */
-                if (operator_name == NULL) {
-                        const gchar *mccmnc = NULL;
-                        guint32 sid = 0;
-
-                        if (modem_3gpp != NULL)
-                                mccmnc = mm_modem_3gpp_get_operator_code (modem_3gpp);
-                        if (modem_cdma != NULL)
-                                sid = mm_modem_cdma_get_sid (modem_cdma);
-                        operator_name = device_mobile_find_provider (self, mccmnc, sid);
-                }
-
-                /* Set operator name */
-                if (operator_name != NULL) {
-                        g_debug ("[%s] Operator name set to '%s'",
-                                 mm_object_get_path (self->mm_object),
-                                 operator_name);
-                }
-
-        } else {
-                const gchar *gsm;
-                const gchar *cdma;
-
-                /* Assume old MM handling */
-                gsm = g_object_get_data (G_OBJECT (self),
-                                         "ControlCenter::OperatorNameGsm");
-                cdma = g_object_get_data (G_OBJECT (self),
-                                          "ControlCenter::OperatorNameCdma");
-
-                if (gsm != NULL && cdma != NULL)
-                        operator_name = g_strdup_printf ("%s, %s", gsm, cdma);
-                else if (gsm != NULL)
-                        operator_name = g_strdup (gsm);
-                else if (cdma != NULL)
-                        operator_name = g_strdup (cdma);
-        }
-
-        gtk_label_set_label (self->provider_label, operator_name);
-        gtk_widget_set_visible (GTK_WIDGET (self->provider_heading_label), operator_name != NULL);
-        gtk_widget_set_visible (GTK_WIDGET (self->provider_label), operator_name != NULL);
-}
-
-static void
-nm_device_mobile_refresh_ui (NetDeviceMobile *self)
-{
-        gboolean is_connected;
-        NMDeviceModemCapabilities caps;
-        g_autofree gchar *status = NULL;
-        NMIPConfig *ipv4_config = NULL, *ipv6_config = NULL;
-        gboolean have_ipv4_address = FALSE, have_ipv6_address = FALSE;
-        gboolean have_dns4 = FALSE, have_dns6 = FALSE;
-        const gchar *route4_text = NULL, *route6_text = NULL;
-
-        /* set up the device on/off switch */
-        gtk_widget_show (GTK_WIDGET (self->device_off_switch));
-        mobilebb_enabled_toggled (self);
-
-        /* set device state, with status */
-        status = panel_device_status_to_localized_string (self->device, NULL);
-        gtk_label_set_label (self->status_label, status);
-
-        /* sensitive for other connection types if the device is currently connected */
-        is_connected = net_device_get_find_connection (self->client, self->device) != NULL;
-        gtk_widget_set_sensitive (GTK_WIDGET (self->options_button), is_connected);
-
-        caps = nm_device_modem_get_current_capabilities (NM_DEVICE_MODEM (self->device));
-        if ((caps & NM_DEVICE_MODEM_CAPABILITY_GSM_UMTS) ||
-            (caps & NM_DEVICE_MODEM_CAPABILITY_CDMA_EVDO) ||
-            (caps & NM_DEVICE_MODEM_CAPABILITY_LTE)) {
-                device_mobile_refresh_operator_name (self);
-                device_mobile_refresh_equipment_id (self);
-        }
-
-        /* add possible connections to device */
-        device_add_device_connections (self,
-                                       self->device,
-                                       self->mobile_connections_list_store,
-                                       self->network_combo);
-
-        ipv4_config = nm_device_get_ip4_config (self->device);
-        if (ipv4_config != NULL) {
-                GPtrArray *addresses;
-                const gchar *ipv4_text = NULL;
-                g_autofree gchar *ip4_dns = NULL;
-
-                addresses = nm_ip_config_get_addresses (ipv4_config);
-                if (addresses->len > 0)
-                        ipv4_text = nm_ip_address_get_address (g_ptr_array_index (addresses, 0));
-                gtk_label_set_label (self->ipv4_label, ipv4_text);
-                gtk_widget_set_visible (GTK_WIDGET (self->ipv4_heading_label), ipv4_text != NULL);
-                gtk_widget_set_visible (GTK_WIDGET (self->ipv4_label), ipv4_text != NULL);
-                have_ipv4_address = ipv4_text != NULL;
-
-                ip4_dns = g_strjoinv (" ", (char **) nm_ip_config_get_nameservers (ipv4_config));
-                if (!*ip4_dns)
-                        ip4_dns = NULL;
-                gtk_label_set_label (self->dns4_label, ip4_dns);
-                gtk_widget_set_visible (GTK_WIDGET (self->dns4_heading_label), ip4_dns != NULL);
-                gtk_widget_set_visible (GTK_WIDGET (self->dns4_label), ip4_dns != NULL);
-                have_dns4 = ip4_dns != NULL;
-
-                route4_text = nm_ip_config_get_gateway (ipv4_config);
-        } else {
-                gtk_widget_hide (GTK_WIDGET (self->ipv4_heading_label));
-                gtk_widget_hide (GTK_WIDGET (self->ipv4_label));
-                gtk_widget_hide (GTK_WIDGET (self->dns4_heading_label));
-                gtk_widget_hide (GTK_WIDGET (self->dns4_label));
-        }
-
-        ipv6_config = nm_device_get_ip6_config (self->device);
-        if (ipv6_config != NULL) {
-                g_autofree gchar *ipv6_text = NULL;
-                g_autofree gchar *ip6_dns = NULL;
-
-                ipv6_text = net_device_get_ip6_addresses (ipv6_config);
-                gtk_label_set_label (self->ipv6_label, ipv6_text);
-                gtk_widget_set_visible (GTK_WIDGET (self->ipv6_heading_label), ipv6_text != NULL);
-                gtk_widget_set_valign (GTK_WIDGET (self->ipv6_heading_label), GTK_ALIGN_START);
-                gtk_widget_set_visible (GTK_WIDGET (self->ipv6_label), ipv6_text != NULL);
-                have_ipv6_address = ipv6_text != NULL;
-
-                ip6_dns = g_strjoinv (" ", (char **) nm_ip_config_get_nameservers (ipv6_config));
-                if (!*ip6_dns)
-                        ip6_dns = NULL;
-                gtk_label_set_label (self->dns6_label, ip6_dns);
-                gtk_widget_set_visible (GTK_WIDGET (self->dns6_heading_label), ip6_dns != NULL);
-                gtk_widget_set_visible (GTK_WIDGET (self->dns6_label), ip6_dns != NULL);
-                have_dns6 = ip6_dns != NULL;
-
-                route6_text =  nm_ip_config_get_gateway (ipv6_config);
-        } else {
-                gtk_widget_hide (GTK_WIDGET (self->ipv6_heading_label));
-                gtk_widget_hide (GTK_WIDGET (self->ipv6_label));
-                gtk_widget_hide (GTK_WIDGET (self->dns6_heading_label));
-                gtk_widget_hide (GTK_WIDGET (self->dns6_label));
-        }
-
-        if (have_ipv4_address && have_ipv6_address) {
-                gtk_label_set_label (self->ipv4_heading_label, _("IPv4 Address"));
-                gtk_label_set_label (self->ipv6_heading_label, _("IPv6 Address"));
-        }
-        else {
-                gtk_label_set_label (self->ipv4_heading_label, _("IP Address"));
-                gtk_label_set_label (self->ipv6_heading_label, _("IP Address"));
-        }
-
-        if (have_dns4 && have_dns6) {
-                gtk_label_set_label (self->dns4_heading_label, _("DNS4"));
-                gtk_label_set_label (self->dns6_heading_label, _("DNS6"));
-        } else {
-                gtk_label_set_label (self->dns4_heading_label, _("DNS"));
-                gtk_label_set_label (self->dns6_heading_label, _("DNS"));
-        }
-
-        if (route4_text != NULL || route6_text != NULL) {
-                g_autofree const gchar *routes_text = NULL;
-
-                if (route4_text == NULL) {
-                        routes_text = g_strdup (route6_text);
-                } else if (route6_text == NULL) {
-                        routes_text = g_strdup (route4_text);
-                } else {
-                        routes_text = g_strjoin ("\n", route4_text, route6_text, NULL);
-                }
-                gtk_label_set_label (self->route_label, routes_text);
-                gtk_widget_set_visible (GTK_WIDGET (self->route_heading_label), routes_text != NULL);
-                gtk_widget_set_valign (GTK_WIDGET (self->route_heading_label), GTK_ALIGN_START);
-                gtk_widget_set_visible (GTK_WIDGET (self->route_label), routes_text != NULL);
-        } else {
-                gtk_widget_hide (GTK_WIDGET (self->route_heading_label));
-                gtk_widget_hide (GTK_WIDGET (self->route_label));
-        }
-}
-
-static void
-device_off_switch_changed_cb (NetDeviceMobile *self)
-{
-        const GPtrArray *acs;
-        gboolean active;
-        gint i;
-        NMActiveConnection *a;
-        NMConnection *connection;
-
-        if (self->updating_device)
-                return;
-
-        connection = net_device_get_find_connection (self->client, self->device);
-        if (connection == NULL)
-                return;
-
-        active = gtk_switch_get_active (self->device_off_switch);
-        if (active) {
-                nm_client_activate_connection_async (self->client,
-                                                     connection,
-                                                     self->device,
-                                                     NULL, NULL, NULL, NULL);
-        } else {
-                const gchar *uuid;
-
-                uuid = nm_connection_get_uuid (connection);
-                acs = nm_client_get_active_connections (self->client);
-                for (i = 0; acs && i < acs->len; i++) {
-                        a = (NMActiveConnection*)acs->pdata[i];
-                        if (strcmp (nm_active_connection_get_uuid (a), uuid) == 0) {
-                                nm_client_deactivate_connection (self->client, a, NULL, NULL);
-                                break;
-                        }
-                }
-        }
-}
-
-static void
-options_button_clicked_cb (NetDeviceMobile *self)
-{
-        const gchar *uuid;
-        g_autofree gchar *cmdline = NULL;
-        g_autoptr(GError) error = NULL;
-        NMConnection *connection;
-
-        connection = net_device_get_find_connection (self->client, self->device);
-        uuid = nm_connection_get_uuid (connection);
-        cmdline = g_strdup_printf ("nm-connection-editor --edit %s", uuid);
-        g_debug ("Launching '%s'\n", cmdline);
-        if (!g_spawn_command_line_async (cmdline, &error))
-                g_warning ("Failed to launch nm-connection-editor: %s", error->message);
-}
-
-static void
-device_mobile_device_got_modem_manager_cb (GObject *source_object,
-                                           GAsyncResult *res,
-                                           gpointer user_data)
-{
-        g_autoptr(GError) error = NULL;
-        g_autoptr(GVariant) result = NULL;
-        g_autoptr(GDBusProxy) proxy = NULL;
-        NetDeviceMobile *self = (NetDeviceMobile *)user_data;
-
-        proxy = g_dbus_proxy_new_for_bus_finish (res, &error);
-        if (!proxy) {
-                g_warning ("Error creating ModemManager proxy: %s",
-                           error->message);
-                return;
-        }
-
-        /* get the IMEI */
-        result = g_dbus_proxy_get_cached_property (proxy,
-                                                   "EquipmentIdentifier");
-
-        /* save */
-        if (result)
-                g_object_set_data_full (G_OBJECT (self),
-                                        "ControlCenter::EquipmentIdentifier",
-                                        g_variant_dup_string (result, NULL),
-                                        g_free);
-
-        device_mobile_refresh_equipment_id (self);
-}
-
-static void
-device_mobile_save_operator_name (NetDeviceMobile *self,
-                                  const gchar     *field,
-                                  const gchar     *operator_name)
-{
-        gchar *operator_name_safe = NULL;
-
-        if (operator_name != NULL && operator_name[0] != '\0')
-                operator_name_safe = g_strescape (operator_name, NULL);
-
-        /* save */
-        g_object_set_data_full (G_OBJECT (self),
-                                field,
-                                operator_name_safe,
-                                g_free);
-        /* refresh */
-        device_mobile_refresh_operator_name (self);
-}
-
-static void
-device_mobile_get_registration_info_cb (GObject      *source_object,
-                                        GAsyncResult *res,
-                                        gpointer      user_data)
-{
-        g_autofree gchar *operator_code = NULL;
-        g_autoptr(GError) error = NULL;
-        guint registration_status;
-        g_autoptr(GVariant) result = NULL;
-        g_autofree gchar *operator_name = NULL;
-        NetDeviceMobile *self = (NetDeviceMobile *)user_data;
-
-        result = g_dbus_proxy_call_finish (G_DBUS_PROXY (source_object), res, &error);
-        if (result == NULL) {
-                g_warning ("Error getting registration info: %s\n",
-                           error->message);
-                return;
-        }
-
-        /* get values */
-        g_variant_get (result, "((uss))",
-                       &registration_status,
-                       &operator_code,
-                       &operator_name);
-
-        /* If none give, try to guess it */
-        if (operator_name == NULL || operator_name[0] == '\0') {
-                g_free (operator_name);
-                operator_name = device_mobile_find_provider (self, operator_code, 0);
-        }
-
-        /* save and refresh */
-        device_mobile_save_operator_name (self,
-                                          "ControlCenter::OperatorNameGsm",
-                                          operator_name);
-}
-
-static void
-device_mobile_gsm_signal_cb (NetDeviceMobile *self,
-                             const gchar     *sender_name,
-                             const gchar     *signal_name,
-                             GVariant        *parameters)
-{
-        guint registration_status = 0;
-        g_autofree gchar *operator_code = NULL;
-        g_autofree gchar *operator_name = NULL;
-
-        if (!g_str_equal (signal_name, "RegistrationInfo"))
-                return;
-
-        g_variant_get (parameters,
-                       "(uss)",
-                       &registration_status,
-                       &operator_code,
-                       &operator_name);
-
-        /* If none given, try to guess it */
-        if (operator_name == NULL || operator_name[0] == '\0') {
-                g_free (operator_name);
-                operator_name = device_mobile_find_provider (self, operator_code, 0);
-        }
-
-        /* save and refresh */
-        device_mobile_save_operator_name (self,
-                                          "ControlCenter::OperatorNameGsm",
-                                          operator_name);
-}
-
-static void
-device_mobile_device_got_modem_manager_gsm_cb (GObject      *source_object,
-                                               GAsyncResult *res,
-                                               gpointer      user_data)
-{
-        g_autoptr(GError) error = NULL;
-        NetDeviceMobile *self = (NetDeviceMobile *)user_data;
-
-        self->gsm_proxy = g_dbus_proxy_new_for_bus_finish (res, &error);
-        if (self->gsm_proxy == NULL) {
-                g_warning ("Error creating ModemManager GSM proxy: %s\n",
-                           error->message);
-                return;
-        }
-
-        /* Setup value updates */
-        g_signal_connect_object (self->gsm_proxy,
-                                 "g-signal",
-                                 G_CALLBACK (device_mobile_gsm_signal_cb),
-                                 self,
-                                 G_CONNECT_SWAPPED);
-
-        /* Load initial value */
-        g_dbus_proxy_call (self->gsm_proxy,
-                           "GetRegistrationInfo",
-                           NULL,
-                           G_DBUS_CALL_FLAGS_NONE,
-                           -1,
-                           NULL,
-                           device_mobile_get_registration_info_cb,
-                           self);
-}
-
-static void
-device_mobile_get_serving_system_cb (GObject      *source_object,
-                                     GAsyncResult *res,
-                                     gpointer      user_data)
-{
-        NetDeviceMobile *self = (NetDeviceMobile *)user_data;
-        g_autoptr(GVariant) result = NULL;
-        g_autoptr(GError) error = NULL;
-
-        guint32 band_class;
-        g_autofree gchar *band = NULL;
-        guint32 sid;
-        gchar *operator_name;
-
-        result = g_dbus_proxy_call_finish (G_DBUS_PROXY (source_object), res, &error);
-        if (result == NULL) {
-                g_warning ("Error getting serving system: %s\n",
-                           error->message);
-                return;
-        }
-
-        /* get values */
-        g_variant_get (result, "((usu))",
-                       &band_class,
-                       &band,
-                       &sid);
-
-        operator_name = device_mobile_find_provider (self, NULL, sid);
-
-        /* save and refresh */
-        device_mobile_save_operator_name (self,
-                                          "ControlCenter::OperatorNameCdma",
-                                          operator_name);
-}
-
-static void
-device_mobile_device_got_modem_manager_cdma_cb (GObject      *source_object,
-                                                GAsyncResult *res,
-                                                gpointer      user_data)
-{
-        g_autoptr(GError) error = NULL;
-        NetDeviceMobile *self = (NetDeviceMobile *)user_data;
-
-        self->cdma_proxy = g_dbus_proxy_new_for_bus_finish (res, &error);
-        if (self->cdma_proxy == NULL) {
-                g_warning ("Error creating ModemManager CDMA proxy: %s\n",
-                           error->message);
-                return;
-        }
-
-        /* Load initial value */
-        g_dbus_proxy_call (self->cdma_proxy,
-                           "GetServingSystem",
-                           NULL,
-                           G_DBUS_CALL_FLAGS_NONE,
-                           -1,
-                           NULL,
-                           device_mobile_get_serving_system_cb,
-                           self);
-}
-
-static void
-operator_name_updated (NetDeviceMobile *self)
-{
-        device_mobile_refresh_operator_name (self);
-}
-
-static void
-net_device_mobile_dispose (GObject *object)
-{
-        NetDeviceMobile *self = NET_DEVICE_MOBILE (object);
-
-        g_cancellable_cancel (self->cancellable);
-
-        g_clear_object (&self->client);
-        g_clear_object (&self->device);
-        g_clear_object (&self->modem);
-        g_clear_object (&self->cancellable);
-        g_clear_object (&self->gsm_proxy);
-        g_clear_object (&self->cdma_proxy);
-        g_clear_object (&self->mm_object);
-        g_clear_object (&self->mpd);
-
-        G_OBJECT_CLASS (net_device_mobile_parent_class)->dispose (object);
-}
-
-static void
-net_device_mobile_class_init (NetDeviceMobileClass *klass)
-{
-        GObjectClass *object_class = G_OBJECT_CLASS (klass);
-        GtkWidgetClass *widget_class = GTK_WIDGET_CLASS (klass);
-
-        object_class->dispose = net_device_mobile_dispose;
-
-        gtk_widget_class_set_template_from_resource (widget_class, "/org/gnome/control-center/network/network-mobile.ui");
-
-        gtk_widget_class_bind_template_child (widget_class, NetDeviceMobile, device_label);
-        gtk_widget_class_bind_template_child (widget_class, NetDeviceMobile, device_off_switch);
-        gtk_widget_class_bind_template_child (widget_class, NetDeviceMobile, dns4_heading_label);
-        gtk_widget_class_bind_template_child (widget_class, NetDeviceMobile, dns4_label);
-        gtk_widget_class_bind_template_child (widget_class, NetDeviceMobile, dns6_heading_label);
-        gtk_widget_class_bind_template_child (widget_class, NetDeviceMobile, dns6_label);
-        gtk_widget_class_bind_template_child (widget_class, NetDeviceMobile, imei_heading_label);
-        gtk_widget_class_bind_template_child (widget_class, NetDeviceMobile, imei_label);
-        gtk_widget_class_bind_template_child (widget_class, NetDeviceMobile, ipv4_heading_label);
-        gtk_widget_class_bind_template_child (widget_class, NetDeviceMobile, ipv4_label);
-        gtk_widget_class_bind_template_child (widget_class, NetDeviceMobile, ipv6_heading_label);
-        gtk_widget_class_bind_template_child (widget_class, NetDeviceMobile, ipv6_label);
-        gtk_widget_class_bind_template_child (widget_class, NetDeviceMobile, mobile_connections_list_store);
-        gtk_widget_class_bind_template_child (widget_class, NetDeviceMobile, network_combo);
-        gtk_widget_class_bind_template_child (widget_class, NetDeviceMobile, network_label);
-        gtk_widget_class_bind_template_child (widget_class, NetDeviceMobile, options_button);
-        gtk_widget_class_bind_template_child (widget_class, NetDeviceMobile, provider_heading_label);
-        gtk_widget_class_bind_template_child (widget_class, NetDeviceMobile, provider_label);
-        gtk_widget_class_bind_template_child (widget_class, NetDeviceMobile, route_heading_label);
-        gtk_widget_class_bind_template_child (widget_class, NetDeviceMobile, route_label);
-        gtk_widget_class_bind_template_child (widget_class, NetDeviceMobile, status_label);
-
-        gtk_widget_class_bind_template_callback (widget_class, device_off_switch_changed_cb);
-        gtk_widget_class_bind_template_callback (widget_class, network_combo_changed_cb);
-        gtk_widget_class_bind_template_callback (widget_class, options_button_clicked_cb);
-}
-
-static void
-net_device_mobile_init (NetDeviceMobile *self)
-{
-        g_autofree gchar *path = NULL;
-
-        gtk_widget_init_template (GTK_WIDGET (self));
-
-        self->cancellable = g_cancellable_new ();
-
-        path = g_find_program_in_path ("nm-connection-editor");
-        gtk_widget_set_visible (GTK_WIDGET (self->options_button), path != NULL);
-}
-
-NetDeviceMobile *
-net_device_mobile_new (NMClient *client, NMDevice *device, GDBusObject *modem)
-{
-        NetDeviceMobile *self;
-        NMDeviceModemCapabilities caps;
-
-        self = g_object_new (net_device_mobile_get_type (), NULL);
-        self->client = g_object_ref (client);
-        self->device = g_object_ref (device);
-
-        g_signal_connect_object (device, "state-changed", G_CALLBACK (nm_device_mobile_refresh_ui), self, G_CONNECT_SWAPPED);
-
-        if (modem != NULL)  {
-                MMModem3gpp *modem_3gpp;
-
-                self->modem = g_object_ref (modem);
-
-                /* Load equipment ID initially */
-                device_mobile_refresh_equipment_id (self);
-
-                /* Follow changes in operator name and load initial values */
-                modem_3gpp = mm_object_peek_modem_3gpp (self->mm_object);
-                if (modem_3gpp != NULL) {
-                        g_signal_connect_object (modem_3gpp,
-                                                 "notify::operator-name",
-                                                 G_CALLBACK (operator_name_updated),
-                                                 self,
-                                                 G_CONNECT_SWAPPED);
-                        device_mobile_refresh_operator_name (self);
-                }
-        }
-
-        caps = nm_device_modem_get_current_capabilities (NM_DEVICE_MODEM (device));
-
-        /* Only load proxies if we have broadband modems of the OLD ModemManager interface */
-        if (g_str_has_prefix (nm_device_get_udi (device), "/org/freedesktop/ModemManager/") &&
-            ((caps & NM_DEVICE_MODEM_CAPABILITY_GSM_UMTS) ||
-             (caps & NM_DEVICE_MODEM_CAPABILITY_CDMA_EVDO) ||
-             (caps & NM_DEVICE_MODEM_CAPABILITY_LTE))) {
-                g_dbus_proxy_new_for_bus (G_BUS_TYPE_SYSTEM,
-                                          G_DBUS_PROXY_FLAGS_NONE,
-                                          NULL,
-                                          "org.freedesktop.ModemManager",
-                                          nm_device_get_udi (device),
-                                          "org.freedesktop.ModemManager.Modem",
-                                          self->cancellable,
-                                          device_mobile_device_got_modem_manager_cb,
-                                          self);
-
-                if ((caps & NM_DEVICE_MODEM_CAPABILITY_GSM_UMTS) ||
-                    (caps & NM_DEVICE_MODEM_CAPABILITY_LTE)) {
-                        g_dbus_proxy_new_for_bus (G_BUS_TYPE_SYSTEM,
-                                                  G_DBUS_PROXY_FLAGS_NONE,
-                                                  NULL,
-                                                  "org.freedesktop.ModemManager",
-                                                  nm_device_get_udi (device),
-                                                  "org.freedesktop.ModemManager.Modem.Gsm.Network",
-                                                  self->cancellable,
-                                                  device_mobile_device_got_modem_manager_gsm_cb,
-                                                  self);
-                }
-
-                if (caps & NM_DEVICE_MODEM_CAPABILITY_CDMA_EVDO) {
-                        g_dbus_proxy_new_for_bus (G_BUS_TYPE_SYSTEM,
-                                                  G_DBUS_PROXY_FLAGS_NONE,
-                                                  NULL,
-                                                  "org.freedesktop.ModemManager",
-                                                  nm_device_get_udi (device),
-                                                  "org.freedesktop.ModemManager.Modem.Cdma",
-                                                  self->cancellable,
-                                                  device_mobile_device_got_modem_manager_cdma_cb,
-                                                  self);
-                }
-        }
-
-        g_signal_connect_object (client, "notify::wwan-enabled",
-                                 G_CALLBACK (mobilebb_enabled_toggled),
-                                 self, G_CONNECT_SWAPPED);
-        nm_device_mobile_refresh_ui (self);
-
-        return self;
-}
-
-NMDevice *
-net_device_mobile_get_device (NetDeviceMobile *self)
-{
-        g_return_val_if_fail (NET_IS_DEVICE_MOBILE (self), NULL);
-        return self->device;
-}
-
-void
-net_device_mobile_set_title (NetDeviceMobile *self, const gchar *title)
-{
-        g_return_if_fail (NET_IS_DEVICE_MOBILE (self));
-        gtk_label_set_label (self->device_label, title);
-}
diff --git a/panels/network/net-device-mobile.h b/panels/network/net-device-mobile.h
deleted file mode 100644
index 7574d3f..0000000
--- a/panels/network/net-device-mobile.h
+++ /dev/null
@@ -1,40 +0,0 @@
-/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
- *
- * Copyright (C) 2011-2012 Richard Hughes <richard@hughsie.com>
- *
- * Licensed under the GNU General Public License Version 2
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
- */
-
-#pragma once
-
-#include <gtk/gtk.h>
-#include <NetworkManager.h>
-
-G_BEGIN_DECLS
-
-G_DECLARE_FINAL_TYPE (NetDeviceMobile, net_device_mobile, NET, DEVICE_MOBILE, GtkBox)
-
-NetDeviceMobile *net_device_mobile_new          (NMClient        *client,
-                                                 NMDevice        *device,
-                                                 GDBusObject     *modem);
-
-NMDevice          *net_device_mobile_get_device (NetDeviceMobile *device);
-
-void               net_device_mobile_set_title  (NetDeviceMobile *device,
-                                                 const gchar     *title);
-
-G_END_DECLS
diff --git a/panels/network/net-device-wifi.c b/panels/network/net-device-wifi.c
index 69fe2e1..b3b8e22 100644
--- a/panels/network/net-device-wifi.c
+++ b/panels/network/net-device-wifi.c
@@ -29,7 +29,6 @@
 #include <NetworkManager.h>
 #include <polkit/polkit.h>
 
-#include "cc-wifi-hotspot-dialog.h"
 #include "list-box-helper.h"
 #include "hostname-helper.h"
 #include "network-dialogs.h"
@@ -73,7 +72,6 @@ struct _NetDeviceWifi
         gchar                   *selected_ssid_title;
         gchar                   *selected_connection_id;
         gchar                   *selected_ap_id;
-        CcWifiHotspotDialog     *hotspot_dialog;
 
         gint64                   last_scan;
         gboolean                 scanning;
@@ -675,53 +673,6 @@ overwrite_ssid_cb (GObject      *source_object,
                                              self);
 }
 
-static void
-start_hotspot_button_clicked_cb (NetDeviceWifi *self)
-{
-        g_autofree gchar *active_ssid = NULL;
-        GtkWidget *window;
-        NMConnection *c;
-        g_autofree gchar *hostname = NULL;
-        g_autofree gchar *ssid = NULL;
-        gint response;
-
-        window = gtk_widget_get_toplevel (GTK_WIDGET (self));
-
-        if (!self->hotspot_dialog)
-                self->hotspot_dialog = cc_wifi_hotspot_dialog_new (GTK_WINDOW (window));
-        cc_wifi_hotspot_dialog_set_device (self->hotspot_dialog, NM_DEVICE_WIFI (self->device));
-        hostname = get_hostname ();
-        ssid =  pretty_hostname_to_ssid (hostname);
-        cc_wifi_hotspot_dialog_set_hostname (self->hotspot_dialog, ssid);
-                c = net_device_wifi_get_hotspot_connection (self);
-        if (c)
-                cc_wifi_hotspot_dialog_set_connection (self->hotspot_dialog, c);
-
-        response = gtk_dialog_run (GTK_DIALOG (self->hotspot_dialog));
-
-        if (response == GTK_RESPONSE_APPLY) {
-                NMConnection *connection;
-
-                connection = cc_wifi_hotspot_dialog_get_connection (self->hotspot_dialog);
-                if (NM_IS_REMOTE_CONNECTION (connection))
-                        nm_remote_connection_commit_changes_async (NM_REMOTE_CONNECTION (connection),
-                                                                   TRUE,
-                                                                   self->cancellable,
-                                                                   overwrite_ssid_cb,
-                                                                   self);
-                else
-                        nm_client_add_and_activate_connection_async (self->client,
-                                                                     connection,
-                                                                     self->device,
-                                                                     NULL,
-                                                                     self->cancellable,
-                                                                     activate_new_cb,
-                                                                     self);
-        }
-
-        gtk_widget_hide (GTK_WIDGET (self->hotspot_dialog));
-}
-
 static void
 stop_shared_connection (NetDeviceWifi *self)
 {
@@ -1187,7 +1138,6 @@ net_device_wifi_class_init (NetDeviceWifiClass *klass)
         gtk_widget_class_bind_template_callback (widget_class, connect_hidden_button_clicked_cb);
         gtk_widget_class_bind_template_callback (widget_class, device_off_switch_changed_cb);
         gtk_widget_class_bind_template_callback (widget_class, history_button_clicked_cb);
-        gtk_widget_class_bind_template_callback (widget_class, start_hotspot_button_clicked_cb);
 }
 
 static void
diff --git a/panels/network/network.gresource.xml b/panels/network/network.gresource.xml
index b056d4b..8d3ba96 100644
--- a/panels/network/network.gresource.xml
+++ b/panels/network/network.gresource.xml
@@ -4,12 +4,10 @@
     <!-- Network panel -->
     <file preprocess="xml-stripblanks">cc-network-panel.ui</file>
     <file preprocess="xml-stripblanks">cc-wifi-connection-row.ui</file>
-    <file preprocess="xml-stripblanks">cc-wifi-hotspot-dialog.ui</file>
     <file preprocess="xml-stripblanks">network-bluetooth.ui</file>
     <file preprocess="xml-stripblanks">network-proxy.ui</file>
     <file preprocess="xml-stripblanks">network-vpn.ui</file>
     <file preprocess="xml-stripblanks">network-wifi.ui</file>
-    <file preprocess="xml-stripblanks">network-mobile.ui</file>
     <file preprocess="xml-stripblanks">network-ethernet.ui</file>
 
     <!-- Wi-Fi panel -->
diff --git a/panels/printers/meson.build b/panels/printers/meson.build
index ccce64c..e8d7953 100644
--- a/panels/printers/meson.build
+++ b/panels/printers/meson.build
@@ -35,7 +35,6 @@ sources = files(
   'pp-print-device.c',
   'pp-printer-entry.c',
   'pp-printer.c',
-  'pp-samba.c',
   'pp-utils.c'
 )
 
@@ -62,8 +61,7 @@ sources += gnome.compile_resources(
 deps = common_deps + [
   cups_dep,
   m_dep,
-  polkit_gobject_dep,
-  dependency('smbclient')
+  polkit_gobject_dep
 ]
 
 printers_panel_lib = static_library(
diff --git a/panels/printers/pp-new-printer-dialog.c b/panels/printers/pp-new-printer-dialog.c
index 9ab1721..3e4f6f0 100644
--- a/panels/printers/pp-new-printer-dialog.c
+++ b/panels/printers/pp-new-printer-dialog.c
@@ -33,7 +33,6 @@
 #include "pp-host.h"
 #include "pp-new-printer.h"
 #include "pp-ppd-selection-dialog.h"
-#include "pp-samba.h"
 #include "pp-utils.h"
 
 #if (CUPS_VERSION_MAJOR > 1) || (CUPS_VERSION_MINOR > 5)
@@ -151,7 +150,6 @@ struct _PpNewPrinterDialog
   PpHost  *socket_host;
   PpHost  *lpd_host;
   PpHost  *remote_cups_host;
-  PpSamba *samba_host;
   guint    host_search_timeout_id;
 };
 
@@ -174,9 +172,7 @@ get_authenticated_samba_devices_cb (GObject      *source_object,
   gboolean                   cancelled = FALSE;
   g_autoptr(GError)          error = NULL;
 
-  devices = pp_samba_get_devices_finish (PP_SAMBA (source_object), res, &error);
-
-  if (devices != NULL)
+ if (devices != NULL)
     {
       self->samba_authenticated_searching = FALSE;
 
@@ -213,7 +209,6 @@ get_authenticated_samba_devices_cb (GObject      *source_object,
         {
           g_warning ("%s", error->message);
 
-          self->samba_authenticated_searching = FALSE;
           update_dialog_state (self);
         }
     }
@@ -249,12 +244,9 @@ on_authenticate (PpNewPrinterDialog *self)
       return;
     }
 
-  pp_samba_set_auth_info (PP_SAMBA (self->samba_host), username, password);
-
   gtk_header_bar_set_title (self->headerbar, _("Add Printer"));
   go_to_page (self, ADDPRINTER_PAGE);
 
-  g_object_get (PP_HOST (self->samba_host), "hostname", &hostname, NULL);
   remove_device_from_list (self, hostname);
 }
 
@@ -268,7 +260,6 @@ on_authentication_required (PpNewPrinterDialog *self)
   gtk_header_bar_set_subtitle (self->headerbar, NULL);
   gtk_header_bar_set_title (self->headerbar, _("Unlock Print Server"));
 
-  g_object_get (self->samba_host, "hostname", &hostname, NULL);
   /* Translators: Samba server needs authentication of the user to show list of its printers. */
   title = g_strdup_printf (_("Unlock %s."), hostname);
   gtk_label_set_text (self->authentication_title, title);
@@ -304,8 +295,6 @@ auth_entries_changed (PpNewPrinterDialog *self)
 static void
 on_go_back_button_clicked (PpNewPrinterDialog *self)
 {
-  pp_samba_set_auth_info (self->samba_host, NULL, NULL);
-  g_clear_object (&self->samba_host);
 
   go_to_page (self, ADDPRINTER_PAGE);
   gtk_header_bar_set_title (self->headerbar, _("Add Printer"));
@@ -314,50 +303,6 @@ on_go_back_button_clicked (PpNewPrinterDialog *self)
   gtk_tree_selection_unselect_all (gtk_tree_view_get_selection (self->devices_treeview));
 }
 
-static void
-authenticate_samba_server (PpNewPrinterDialog *self)
-{
-  GtkTreeModel              *model;
-  GtkTreeIter                iter;
-  AuthSMBData               *data;
-  gchar                     *server_name = NULL;
-
-  gtk_widget_set_sensitive (GTK_WIDGET (self->unlock_button), FALSE);
-  gtk_widget_set_sensitive (GTK_WIDGET (self->authenticate_button), FALSE);
-  gtk_widget_grab_focus (GTK_WIDGET (self->username_entry));
-
-  if (gtk_tree_selection_get_selected (gtk_tree_view_get_selection (self->devices_treeview), &model, &iter))
-    {
-      gtk_tree_model_get (model, &iter,
-                          DEVICE_NAME_COLUMN, &server_name,
-                          -1);
-
-      if (server_name != NULL)
-        {
-          g_clear_object (&self->samba_host);
-
-          self->samba_host = pp_samba_new (server_name);
-          g_signal_connect_object (self->samba_host,
-                                   "authentication-required",
-                                   G_CALLBACK (on_authentication_required),
-                                   self, G_CONNECT_SWAPPED);
-
-          self->samba_authenticated_searching = TRUE;
-          update_dialog_state (self);
-
-          data = g_new (AuthSMBData, 1);
-          data->server_name = server_name;
-          data->dialog = self;
-
-          pp_samba_get_devices_async (self->samba_host,
-                                      TRUE,
-                                      self->cancellable,
-                                      get_authenticated_samba_devices_cb,
-                                      data);
-        }
-    }
-}
-
 static gboolean
 stack_key_press_cb (PpNewPrinterDialog *self,
                     GdkEvent *event)
@@ -577,10 +522,7 @@ update_dialog_state (PpNewPrinterDialog *self)
               self->remote_cups_host != NULL ||
               self->snmp_host != NULL ||
               self->socket_host != NULL ||
-              self->lpd_host != NULL ||
-              self->samba_host != NULL ||
-              self->samba_authenticated_searching ||
-              self->samba_searching;
+              self->lpd_host != NULL;
 
   if (searching)
     {
@@ -915,70 +857,6 @@ get_remote_cups_devices_cb (GObject      *source_object,
     }
 }
 
-static void
-get_samba_host_devices_cb (GObject      *source_object,
-                           GAsyncResult *res,
-                           gpointer      user_data)
-{
-  PpNewPrinterDialog        *self = user_data;
-  g_autoptr(GPtrArray)       devices = NULL;
-  g_autoptr(GError)          error = NULL;
-
-  devices = pp_samba_get_devices_finish (PP_SAMBA (source_object), res, &error);
-
-  if (devices != NULL)
-    {
-      g_clear_object(&self->samba_host);
-
-      add_devices_to_list (self, devices);
-
-      update_dialog_state (self);
-    }
-  else
-    {
-      if (!g_error_matches (error, G_IO_ERROR, G_IO_ERROR_CANCELLED))
-        {
-          g_warning ("%s", error->message);
-
-          g_clear_object(&self->samba_host);
-
-          update_dialog_state (self);
-        }
-    }
-}
-
-static void
-get_samba_devices_cb (GObject      *source_object,
-                      GAsyncResult *res,
-                      gpointer      user_data)
-{
-  PpNewPrinterDialog        *self = user_data;
-  g_autoptr(GPtrArray)       devices = NULL;
-  g_autoptr(GError)          error = NULL;
-
-  devices = pp_samba_get_devices_finish (PP_SAMBA (source_object), res, &error);
-
-  if (devices != NULL)
-    {
-      self->samba_searching = FALSE;
-
-      add_devices_to_list (self, devices);
-
-      update_dialog_state (self);
-    }
-  else
-    {
-      if (!g_error_matches (error, G_IO_ERROR, G_IO_ERROR_CANCELLED))
-        {
-          g_warning ("%s", error->message);
-
-          self->samba_searching = FALSE;
-
-          update_dialog_state (self);
-        }
-    }
-}
-
 static void
 get_jetdirect_devices_cb (GObject      *source_object,
                           GAsyncResult *res,
@@ -1152,7 +1030,6 @@ search_for_remote_printers (THostSearchData *data)
         g_object_set (self->lpd_host, "port", data->host_port, NULL);
     }
 
-  self->samba_host = pp_samba_new (data->host_name);
 
   update_dialog_state (data->dialog);
 
@@ -1176,12 +1053,6 @@ search_for_remote_printers (THostSearchData *data)
                                  get_lpd_devices_cb,
                                  data->dialog);
 
-  pp_samba_get_devices_async (self->samba_host,
-                              FALSE,
-                              self->remote_host_cancellable,
-                              get_samba_host_devices_cb,
-                              data->dialog);
-
   self->host_search_timeout_id = 0;
 
   return G_SOURCE_REMOVE;
@@ -1544,7 +1415,7 @@ row_activated_cb (PpNewPrinterDialog *self)
 
       if (authentication_needed)
         {
-          authenticate_samba_server (self);
+            gtk_dialog_response(GTK_DIALOG (self), GTK_RESPONSE_NO);
         }
       else
         {
@@ -1603,7 +1474,6 @@ static void
 populate_devices_list (PpNewPrinterDialog *self)
 {
   GtkTreeViewColumn         *column;
-  g_autoptr(PpSamba)         samba = NULL;
   g_autoptr(GEmblem)         emblem = NULL;
   g_autoptr(PpCups)          cups = NULL;
   g_autoptr(GIcon)           icon = NULL;
@@ -1649,11 +1519,7 @@ populate_devices_list (PpNewPrinterDialog *self)
   cups = pp_cups_new ();
   pp_cups_get_dests_async (cups, self->cancellable, cups_get_dests_cb, self);
 
-  self->samba_searching = TRUE;
   update_dialog_state (self);
-
-  samba = pp_samba_new (NULL);
-  pp_samba_get_devices_async (samba, FALSE, self->cancellable, get_samba_devices_cb, self);
 }
 
 static void
@@ -1795,8 +1661,6 @@ pp_new_printer_dialog_new (PPDList              *ppd_list,
   g_signal_connect_object (self->search_entry, "activate", G_CALLBACK (search_entry_activated_cb), self, G_CONNECT_SWAPPED);
   g_signal_connect_object (self->search_entry, "search-changed", G_CALLBACK (search_entry_changed_cb), self, G_CONNECT_SWAPPED);
 
-  g_signal_connect_object (self->unlock_button, "clicked", G_CALLBACK (authenticate_samba_server), self, G_CONNECT_SWAPPED);
-
   g_signal_connect_object (self->stack, "key-press-event", G_CALLBACK (stack_key_press_cb), self, G_CONNECT_SWAPPED);
 
   /* Authentication form widgets */
@@ -1841,7 +1705,6 @@ pp_new_printer_dialog_dispose (GObject *object)
   g_clear_object (&self->socket_host);
   g_clear_object (&self->lpd_host);
   g_clear_object (&self->remote_cups_host);
-  g_clear_object (&self->samba_host);
 
   if (self->num_of_dests > 0)
     {
diff --git a/panels/printers/pp-samba.c b/panels/printers/pp-samba.c
deleted file mode 100644
index 5eaf5b7..0000000
--- a/panels/printers/pp-samba.c
+++ /dev/null
@@ -1,414 +0,0 @@
-/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
- *
- * Copyright 2012 - 2013 Red Hat, Inc,
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, see <http://www.gnu.org/licenses/>.
- *
- * Author: Marek Kasik <mkasik@redhat.com>
- */
-
-#include "pp-samba.h"
-
-#include "config.h"
-
-#include <glib/gi18n.h>
-#include <libsmbclient.h>
-#include <errno.h>
-
-#define POLL_DELAY 100000
-
-struct _PpSamba
-{
-  PpHost    parent_instance;
-
-  /* Auth info */
-  gchar    *username;
-  gchar    *password;
-  gboolean  waiting;
-};
-
-G_DEFINE_TYPE (PpSamba, pp_samba, PP_TYPE_HOST);
-
-static void
-pp_samba_finalize (GObject *object)
-{
-  PpSamba *self = PP_SAMBA (object);
-
-  g_clear_pointer (&self->username, g_free);
-  g_clear_pointer (&self->password, g_free);
-
-  G_OBJECT_CLASS (pp_samba_parent_class)->finalize (object);
-}
-
-static void
-pp_samba_class_init (PpSambaClass *klass)
-{
-  GObjectClass *gobject_class = G_OBJECT_CLASS (klass);
-
-  gobject_class->finalize = pp_samba_finalize;
-}
-
-static void
-pp_samba_init (PpSamba *samba)
-{
-}
-
-PpSamba *
-pp_samba_new (const gchar *hostname)
-{
-  return g_object_new (PP_TYPE_SAMBA,
-                       "hostname", hostname,
-                       NULL);
-}
-
-typedef struct
-{
-  PpSamba       *samba;
-  GPtrArray     *devices;
-  GMainContext  *context;
-  gboolean       auth_if_needed;
-  gboolean       hostname_set;
-  gboolean       cancelled;
-} SMBData;
-
-static void
-smb_data_free (SMBData *data)
-{
-  if (data)
-    {
-      g_ptr_array_unref (data->devices);
-
-      g_free (data);
-    }
-}
-
-static gboolean
-get_auth_info (gpointer user_data)
-{
-  SMBData *data = (SMBData *) user_data;
-  PpSamba *samba = PP_SAMBA (data->samba);
-
-  g_signal_emit_by_name (samba, "authentication-required");
-
-  return FALSE;
-}
-
-void
-pp_samba_set_auth_info (PpSamba     *samba,
-                        const gchar *username,
-                        const gchar *password)
-{
-  g_free (samba->username);
-  if ((username != NULL) && (username[0] != '\0'))
-    samba->username = g_strdup (username);
-  else
-    samba->username = NULL;
-
-  g_free (samba->password);
-  if ((password != NULL) && (password[0] != '\0'))
-    samba->password = g_strdup (password);
-  else
-    samba->password = NULL;
-
-  samba->waiting = FALSE;
-}
-
-static void
-auth_fn (SMBCCTX    *smb_context,
-         const char *server,
-         const char *share,
-         char       *workgroup,
-         int         wgmaxlen,
-         char       *username,
-         int         unmaxlen,
-         char       *password,
-         int         pwmaxlen)
-{
-  PpSamba           *samba;
-  g_autoptr(GSource) source = NULL;
-  SMBData           *data;
-
-  data = (SMBData *) smbc_getOptionUserData (smb_context);
-  samba = data->samba;
-
-  if (!data->cancelled)
-    {
-      samba->username = g_strdup (username);
-      samba->password = g_strdup (password);
-
-      source = g_idle_source_new ();
-      g_source_set_callback (source,
-                             get_auth_info,
-                             data,
-                             NULL);
-      g_source_attach (source, data->context);
-
-      samba->waiting = TRUE;
-
-      /*
-       * smbclient needs to get authentication data
-       * from this synchronous callback so we are blocking
-       * until we get them
-       */
-      while (samba->waiting)
-        {
-          g_usleep (POLL_DELAY);
-        }
-
-      /* Samba tries to call the auth_fn again if we just set the values
-       * to NULL when we want to cancel the authentication 
-       */
-      if (samba->username == NULL && samba->password == NULL)
-        data->cancelled = TRUE;
-
-      if (samba->username != NULL)
-        {
-          if (g_strcmp0 (username, samba->username) != 0)
-            g_strlcpy (username, samba->username, unmaxlen);
-        }
-      else
-        {
-          username[0] = '\0';
-        }
-
-      if (samba->password != NULL)
-        {
-          if (g_strcmp0 (password, samba->password) != 0)
-            g_strlcpy (password, samba->password, pwmaxlen);
-        }
-      else
-        {
-          password[0] = '\0';
-        }
-
-    }
-}
-
-static void
-anonymous_auth_fn (SMBCCTX    *smb_context,
-                   const char *server,
-                   const char *share,
-                   char       *workgroup,
-                   int         wgmaxlen,
-                   char       *username,
-                   int         unmaxlen,
-                   char       *password,
-                   int         pwmaxlen)
-{
-  username[0] = '\0';
-  password[0] = '\0';
-}
-
-static void
-list_dir (SMBCCTX      *smb_context,
-          const gchar  *dirname,
-          const gchar  *path,
-          GCancellable *cancellable,
-          SMBData      *data)
-{
-  struct smbc_dirent *dirent;
-  smbc_closedir_fn    smbclient_closedir;
-  smbc_readdir_fn     smbclient_readdir;
-  smbc_opendir_fn     smbclient_opendir;
-  const gchar        *host_name;
-  SMBCFILE           *dir;
-
-  if (!g_cancellable_is_cancelled (cancellable))
-    {
-      smbclient_closedir = smbc_getFunctionClosedir (smb_context);
-      smbclient_readdir = smbc_getFunctionReaddir (smb_context);
-      smbclient_opendir = smbc_getFunctionOpendir (smb_context);
-
-      dir = smbclient_opendir (smb_context, dirname);
-      if (!dir && errno == EACCES)
-        {
-          if (g_str_has_prefix (dirname, "smb://"))
-            host_name = dirname + 6;
-          else
-            host_name = dirname;
-
-          if (data->auth_if_needed)
-            {
-              data->cancelled = FALSE;
-              smbc_setFunctionAuthDataWithContext (smb_context, auth_fn);
-              dir = smbclient_opendir (smb_context, dirname);
-              smbc_setFunctionAuthDataWithContext (smb_context, anonymous_auth_fn);
-
-              if (data->cancelled)
-                {
-                  PpPrintDevice *device = g_object_new (PP_TYPE_PRINT_DEVICE,
-                                                        "host-name", host_name,
-                                                        "is-authenticated-server", TRUE,
-                                                        NULL);
-                  g_ptr_array_add (data->devices, device);
-
-                  if (dir)
-                    smbclient_closedir (smb_context, dir);
-                  return;
-                }
-            }
-          else
-            {
-              PpPrintDevice *device = g_object_new (PP_TYPE_PRINT_DEVICE,
-                                                    "host-name", host_name,
-                                                    "is-authenticated-server", TRUE,
-                                                    NULL);
-              g_ptr_array_add (data->devices, device);
-            }
-        }
-
-      while (dir && (dirent = smbclient_readdir (smb_context, dir)))
-        {
-          g_autofree gchar *subdirname = NULL;
-          g_autofree gchar *subpath = NULL;
-
-          if (dirent->smbc_type == SMBC_WORKGROUP)
-            {
-              subdirname = g_strdup_printf ("%s%s", dirname, dirent->name);
-              subpath = g_strdup_printf ("%s%s", path, dirent->name);
-            }
-
-          if (dirent->smbc_type == SMBC_SERVER)
-            {
-              subdirname = g_strdup_printf ("smb://%s", dirent->name);
-              subpath = g_strdup_printf ("%s//%s", path, dirent->name);
-            }
-
-          if (dirent->smbc_type == SMBC_PRINTER_SHARE)
-            {
-              g_autofree gchar *uri = NULL;
-              g_autofree gchar *device_name = NULL;
-              g_autofree gchar *device_uri = NULL;
-              PpPrintDevice *device;
-
-              uri = g_strdup_printf ("%s/%s", dirname, dirent->name);
-              device_uri = g_uri_escape_string (uri,
-                                                G_URI_RESERVED_CHARS_GENERIC_DELIMITERS
-                                                G_URI_RESERVED_CHARS_SUBCOMPONENT_DELIMITERS,
-                                                FALSE);
-
-              device_name = g_strdup (dirent->name);
-              g_strcanon (device_name, ALLOWED_CHARACTERS, '-');
-
-              device = g_object_new (PP_TYPE_PRINT_DEVICE,
-                                     "device-uri", device_uri,
-                                     "is-network-device", TRUE,
-                                     "device-info", dirent->comment,
-                                     "device-name", device_name,
-                                     "acquisition-method", data->hostname_set ? ACQUISITION_METHOD_SAMBA_HOST : ACQUISITION_METHOD_SAMBA,
-                                     "device-location", path,
-                                     "host-name", dirname,
-                                     NULL);
-
-              g_ptr_array_add (data->devices, device);
-            }
-
-          if (subdirname)
-            {
-              list_dir (smb_context,
-                        subdirname,
-                        subpath,
-                        cancellable,
-                        data);
-            }
-        }
-
-      if (dir)
-        smbclient_closedir (smb_context, dir);
-    }
-}
-
-static void
-_pp_samba_get_devices_thread (GTask        *task,
-                              gpointer      source_object,
-                              gpointer      task_data,
-                              GCancellable *cancellable)
-{
-  static GMutex   mutex;
-  SMBData        *data = (SMBData *) task_data;
-  SMBCCTX        *smb_context;
-
-  data->devices = g_ptr_array_new_with_free_func (g_object_unref);
-  data->samba = PP_SAMBA (source_object);
-
-  g_mutex_lock (&mutex);
-
-  smb_context = smbc_new_context ();
-  if (smb_context)
-    {
-      if (smbc_init_context (smb_context))
-        {
-          g_autofree gchar *hostname = NULL;
-          g_autofree gchar *dirname = NULL;
-          g_autofree gchar *path = NULL;
-
-          smbc_setOptionUserData (smb_context, data);
-
-          g_object_get (source_object, "hostname", &hostname, NULL);
-          if (hostname != NULL)
-            {
-              dirname = g_strdup_printf ("smb://%s", hostname);
-              path = g_strdup_printf ("//%s", hostname);
-            }
-          else
-            {
-              dirname = g_strdup_printf ("smb://");
-              path = g_strdup_printf ("//");
-            }
-
-          smbc_setFunctionAuthDataWithContext (smb_context, anonymous_auth_fn);
-          list_dir (smb_context, dirname, path, cancellable, data);
-        }
-
-      smbc_free_context (smb_context, 1);
-    }
-
-  g_mutex_unlock (&mutex);
-
-  g_task_return_pointer (task, g_ptr_array_ref (data->devices), (GDestroyNotify) g_ptr_array_unref);
-}
-
-void
-pp_samba_get_devices_async (PpSamba             *samba,
-                            gboolean             auth_if_needed,
-                            GCancellable        *cancellable,
-                            GAsyncReadyCallback  callback,
-                            gpointer             user_data)
-{
-  g_autoptr(GTask)  task = NULL;
-  SMBData          *data;
-  g_autofree gchar *hostname = NULL;
-
-  g_object_get (G_OBJECT (samba), "hostname", &hostname, NULL);
-
-  task = g_task_new (samba, cancellable, callback, user_data);
-  data = g_new0 (SMBData, 1);
-  data->devices = NULL;
-  data->context = g_main_context_default ();
-  data->hostname_set = hostname != NULL;
-  data->auth_if_needed = auth_if_needed;
-
-  g_task_set_task_data (task, data, (GDestroyNotify) smb_data_free);
-  g_task_run_in_thread (task, _pp_samba_get_devices_thread);
-}
-
-GPtrArray *
-pp_samba_get_devices_finish (PpSamba       *samba,
-                             GAsyncResult  *res,
-                             GError       **error)
-{
-  g_return_val_if_fail (g_task_is_valid (res, samba), NULL);
-  g_return_val_if_fail (error == NULL || *error == NULL, NULL);
-  return g_task_propagate_pointer (G_TASK (res), error);
-}
diff --git a/panels/printers/pp-samba.h b/panels/printers/pp-samba.h
deleted file mode 100644
index 0801317..0000000
--- a/panels/printers/pp-samba.h
+++ /dev/null
@@ -1,47 +0,0 @@
-/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
- *
- * Copyright 2012 - 2013 Red Hat, Inc,
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, see <http://www.gnu.org/licenses/>.
- *
- * Author: Marek Kasik <mkasik@redhat.com>
- */
-
-#pragma once
-
-#include "pp-host.h"
-#include "pp-utils.h"
-
-G_BEGIN_DECLS
-
-#define PP_TYPE_SAMBA (pp_samba_get_type ())
-G_DECLARE_FINAL_TYPE (PpSamba, pp_samba, PP, SAMBA, PpHost)
-
-PpSamba       *pp_samba_new                (const gchar         *hostname);
-
-void           pp_samba_get_devices_async  (PpSamba             *samba,
-                                            gboolean             auth_if_needed,
-                                            GCancellable        *cancellable,
-                                            GAsyncReadyCallback  callback,
-                                            gpointer             user_data);
-
-GPtrArray     *pp_samba_get_devices_finish (PpSamba             *samba,
-                                            GAsyncResult        *result,
-                                            GError             **error);
-
-void           pp_samba_set_auth_info      (PpSamba             *samba,
-                                            const gchar         *username,
-                                            const gchar         *password);
-
-G_END_DECLS
diff --git a/panels/wwan/cc-wwan-apn-dialog.c b/panels/wwan/cc-wwan-apn-dialog.c
deleted file mode 100644
index bc5fde2..0000000
--- a/panels/wwan/cc-wwan-apn-dialog.c
+++ /dev/null
@@ -1,424 +0,0 @@
-/* -*- Mode: C; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* cc-wwan-apn-dialog.c
- *
- * Copyright 2019 Purism SPC
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- *
- * Author(s):
- *   Mohammed Sadiq <sadiq@sadiqpk.org>
- *
- * SPDX-License-Identifier: GPL-3.0-or-later
- */
-
-#undef G_LOG_DOMAIN
-#define G_LOG_DOMAIN "cc-wwan-apn-dialog"
-
-#include <config.h>
-#include <glib/gi18n.h>
-#include <libmm-glib.h>
-
-#include "cc-wwan-device.h"
-#include "cc-wwan-data.h"
-#include "list-box-helper.h"
-#include "cc-wwan-apn-dialog.h"
-#include "cc-wwan-resources.h"
-
-/**
- * @short_description: Dialog to manage Internet Access Points
- */
-
-struct _CcWwanApnDialog
-{
-  GtkDialog          parent_instance;
-
-  GtkButton         *add_button;
-  GtkButton         *back_button;
-  GtkButton         *save_button;
-  GtkEntry          *apn_entry;
-  GtkEntry          *name_entry;
-  GtkEntry          *password_entry;
-  GtkEntry          *username_entry;
-  GtkGrid           *apn_edit_view;
-  GtkListBox        *apn_list;
-  GtkRadioButton    *apn_radio_button;
-  GtkScrolledWindow *apn_list_view;
-  GtkStack          *apn_settings_stack;
-
-  CcWwanData        *wwan_data;
-  CcWwanDataApn     *apn_to_save;   /* The APN currently being edited */
-  CcWwanDevice      *device;
-
-  gboolean           enable_data;
-  gboolean           enable_roaming;
-};
-
-G_DEFINE_TYPE (CcWwanApnDialog, cc_wwan_apn_dialog, GTK_TYPE_DIALOG)
-
-
-enum {
-  PROP_0,
-  PROP_DEVICE,
-  N_PROPS
-};
-
-static GParamSpec *properties[N_PROPS];
-
-#define CC_TYPE_WWAN_APN_ROW (cc_wwan_apn_row_get_type())
-G_DECLARE_FINAL_TYPE (CcWwanApnRow, cc_wwan_apn_row, CC, WWAN_APN_ROW, GtkListBoxRow)
-
-struct _CcWwanApnRow
-{
-  GtkListBoxRow   parent_instance;
-  GtkRadioButton *radio_button;
-  CcWwanDataApn  *apn;
-};
-
-G_DEFINE_TYPE (CcWwanApnRow, cc_wwan_apn_row, GTK_TYPE_LIST_BOX_ROW)
-
-static void
-cc_wwan_apn_row_finalize (GObject *object)
-{
-  CcWwanApnRow *row = (CcWwanApnRow *)object;
-
-  g_clear_object (&row->apn);
-
-  G_OBJECT_CLASS (cc_wwan_apn_row_parent_class)->finalize (object);
-}
-
-static void
-cc_wwan_apn_row_class_init (CcWwanApnRowClass *klass)
-{
-  GObjectClass *object_class = G_OBJECT_CLASS (klass);
-
-  object_class->finalize = cc_wwan_apn_row_finalize;
-}
-
-static void
-cc_wwan_apn_row_init (CcWwanApnRow *row)
-{
-}
-
-static void
-cc_wwan_apn_back_clicked_cb (CcWwanApnDialog *self)
-{
-  GtkWidget *view;
-
-  view = gtk_stack_get_visible_child (self->apn_settings_stack);
-
-  if (view == GTK_WIDGET (self->apn_edit_view))
-    {
-      gtk_widget_hide (GTK_WIDGET (self->save_button));
-      gtk_widget_show (GTK_WIDGET (self->add_button));
-      gtk_stack_set_visible_child (self->apn_settings_stack,
-                                   GTK_WIDGET (self->apn_list_view));
-    }
-  else
-    {
-      gtk_widget_hide (GTK_WIDGET (self));
-    }
-}
-
-static void
-cc_wwan_apn_add_clicked_cb (CcWwanApnDialog *self)
-{
-  gtk_entry_set_text (self->name_entry, "");
-  gtk_entry_set_text (self->apn_entry, "");
-  gtk_entry_set_text (self->username_entry, "");
-  gtk_entry_set_text (self->password_entry, "");
-
-  gtk_widget_hide (GTK_WIDGET (self->add_button));
-  gtk_widget_show (GTK_WIDGET (self->save_button));
-  self->apn_to_save = NULL;
-  gtk_stack_set_visible_child (self->apn_settings_stack,
-                               GTK_WIDGET (self->apn_edit_view));
-}
-
-static void
-cc_wwan_apn_save_clicked_cb (CcWwanApnDialog *self)
-{
-  const gchar *name, *apn_name;
-  CcWwanDataApn *apn;
-
-  apn = self->apn_to_save;
-  self->apn_to_save = NULL;
-
-  name = gtk_entry_get_text (self->name_entry);
-  apn_name = gtk_entry_get_text (self->apn_entry);
-
-  if (!apn)
-    apn = cc_wwan_data_apn_new ();
-
-  cc_wwan_data_apn_set_name (apn, name);
-  cc_wwan_data_apn_set_apn (apn, apn_name);
-  cc_wwan_data_apn_set_username (apn, gtk_entry_get_text (self->username_entry));
-  cc_wwan_data_apn_set_password (apn, gtk_entry_get_text (self->password_entry));
-
-  cc_wwan_data_save_apn (self->wwan_data, apn, NULL, NULL, NULL);
-
-  gtk_widget_hide (GTK_WIDGET (self->save_button));
-  gtk_stack_set_visible_child (self->apn_settings_stack,
-                               GTK_WIDGET (self->apn_list_view));
-}
-
-static void
-cc_wwan_apn_entry_changed_cb (CcWwanApnDialog *self)
-{
-  GtkWidget *widget;
-  const gchar *str;
-  gboolean valid_name, valid_apn;
-
-  widget = GTK_WIDGET (self->name_entry);
-  str = gtk_entry_get_text (self->name_entry);
-  valid_name = str && *str;
-
-  if (valid_name)
-    gtk_style_context_remove_class (gtk_widget_get_style_context (widget), "error");
-  else
-    gtk_style_context_add_class (gtk_widget_get_style_context (widget), "error");
-
-  widget = GTK_WIDGET (self->apn_entry);
-  str = gtk_entry_get_text (self->apn_entry);
-  valid_apn = str && *str;
-
-  if (valid_apn)
-    gtk_style_context_remove_class (gtk_widget_get_style_context (widget), "error");
-  else
-    gtk_style_context_add_class (gtk_widget_get_style_context (widget), "error");
-
-  gtk_widget_set_sensitive (GTK_WIDGET (self->save_button), valid_name && valid_apn);
-}
-
-static void
-cc_wwan_apn_activated_cb (CcWwanApnDialog *self,
-                          CcWwanApnRow    *row)
-{
-  gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (row->radio_button), TRUE);
-}
-
-static void
-cc_wwan_apn_changed_cb (CcWwanApnDialog *self,
-                        GtkWidget       *widget)
-{
-  CcWwanApnRow *row;
-
-  if (!gtk_toggle_button_get_active (GTK_TOGGLE_BUTTON (widget)))
-    return;
-
-  widget = gtk_widget_get_ancestor (widget, CC_TYPE_WWAN_APN_ROW);
-  row = CC_WWAN_APN_ROW (widget);
-
-  if (cc_wwan_data_set_default_apn (self->wwan_data, row->apn))
-    cc_wwan_data_save_settings (self->wwan_data, NULL, NULL, NULL);
-}
-
-static void
-cc_wwan_apn_edit_clicked_cb (CcWwanApnDialog *self,
-                             GtkButton       *button)
-{
-  CcWwanDataApn *apn;
-  CcWwanApnRow *row;
-  GtkWidget *widget;
-
-  widget = gtk_widget_get_ancestor (GTK_WIDGET (button), CC_TYPE_WWAN_APN_ROW);
-  row = CC_WWAN_APN_ROW (widget);
-  apn = row->apn;
-  self->apn_to_save = apn;
-
-  gtk_widget_show (GTK_WIDGET (self->save_button));
-  gtk_widget_hide (GTK_WIDGET (self->add_button));
-
-  gtk_entry_set_text (self->name_entry, cc_wwan_data_apn_get_name (apn));
-  gtk_entry_set_text (self->apn_entry, cc_wwan_data_apn_get_apn (apn));
-  gtk_entry_set_text (self->username_entry, cc_wwan_data_apn_get_username (apn));
-  gtk_entry_set_text (self->password_entry, cc_wwan_data_apn_get_password (apn));
-
-  gtk_stack_set_visible_child (self->apn_settings_stack,
-                               GTK_WIDGET (self->apn_edit_view));
-}
-
-static GtkWidget *
-cc_wwan_apn_dialog_row_new (CcWwanDataApn   *apn,
-                            CcWwanApnDialog *self)
-{
-  CcWwanApnRow *row;
-  GtkWidget *grid, *name_label, *apn_label, *radio, *edit_button;
-  GtkStyleContext *context;
-
-  row = g_object_new (CC_TYPE_WWAN_APN_ROW, NULL);
-
-  grid = g_object_new (GTK_TYPE_GRID,
-                       "margin-top", 6,
-                       "margin-bottom", 6,
-                       "margin-start", 6,
-                       "margin-end", 6,
-                       NULL);
-
-  radio = gtk_radio_button_new_from_widget (self->apn_radio_button);
-  row->radio_button = GTK_RADIO_BUTTON (radio);
-  gtk_widget_set_margin_end (radio, 12);
-  gtk_grid_attach (GTK_GRID (grid), radio, 0, 0, 1, 2);
-  row->apn = g_object_ref (apn);
-
-  if (cc_wwan_data_get_default_apn (self->wwan_data) == apn)
-    gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (radio), TRUE);
-  g_signal_connect_object (radio, "toggled",
-                           G_CALLBACK (cc_wwan_apn_changed_cb),
-                           self, G_CONNECT_SWAPPED);
-
-  name_label = gtk_label_new (cc_wwan_data_apn_get_name (apn));
-  gtk_widget_set_halign (name_label, GTK_ALIGN_START);
-  gtk_widget_set_hexpand (name_label, TRUE);
-  gtk_grid_attach (GTK_GRID (grid), name_label, 1, 0, 1, 1);
-
-  apn_label = gtk_label_new (cc_wwan_data_apn_get_apn (apn));
-  gtk_widget_set_halign (apn_label, GTK_ALIGN_START);
-  context = gtk_widget_get_style_context (apn_label);
-  gtk_style_context_add_class (context, "dim-label");
-  gtk_grid_attach (GTK_GRID (grid), apn_label, 1, 1, 1, 1);
-
-  edit_button = gtk_button_new_from_icon_name ("emblem-system-symbolic",
-                                               GTK_ICON_SIZE_BUTTON);
-  g_signal_connect_object (edit_button, "clicked",
-                           G_CALLBACK (cc_wwan_apn_edit_clicked_cb),
-                           self, G_CONNECT_SWAPPED);
-  gtk_grid_attach (GTK_GRID (grid), edit_button, 2, 0, 1, 2);
-
-  gtk_container_add (GTK_CONTAINER (row), grid);
-  gtk_widget_show_all (GTK_WIDGET (row));
-
-  return GTK_WIDGET (row);
-}
-
-static void
-cc_wwan_apn_dialog_set_property (GObject      *object,
-                                 guint         prop_id,
-                                 const GValue *value,
-                                 GParamSpec   *pspec)
-{
-  CcWwanApnDialog *self = (CcWwanApnDialog *)object;
-
-  switch (prop_id)
-    {
-    case PROP_DEVICE:
-      self->device = g_value_dup_object (value);
-      break;
-
-    default:
-      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
-    }
-}
-
-static void
-cc_wwan_apn_dialog_constructed (GObject *object)
-{
-  CcWwanApnDialog *self = (CcWwanApnDialog *)object;
-
-  G_OBJECT_CLASS (cc_wwan_apn_dialog_parent_class)->constructed (object);
-
-  self->wwan_data = cc_wwan_device_get_data (self->device);
-
-  gtk_list_box_bind_model (self->apn_list,
-                           cc_wwan_data_get_apn_list (self->wwan_data),
-                           (GtkListBoxCreateWidgetFunc)cc_wwan_apn_dialog_row_new,
-                           self, NULL);
-}
-
-static void
-cc_wwan_apn_dialog_dispose (GObject *object)
-{
-  CcWwanApnDialog *self = (CcWwanApnDialog *)object;
-
-  g_clear_object (&self->device);
-
-  G_OBJECT_CLASS (cc_wwan_apn_dialog_parent_class)->dispose (object);
-}
-
-
-static void
-cc_wwan_apn_dialog_show (GtkWidget *widget)
-{
-  CcWwanApnDialog *self = (CcWwanApnDialog *)widget;
-
-  gtk_widget_show (GTK_WIDGET (self->add_button));
-  gtk_widget_hide (GTK_WIDGET (self->save_button));
-  gtk_stack_set_visible_child (self->apn_settings_stack,
-                               GTK_WIDGET (self->apn_list_view));
-
-  GTK_WIDGET_CLASS (cc_wwan_apn_dialog_parent_class)->show (widget);
-}
-
-static void
-cc_wwan_apn_dialog_class_init (CcWwanApnDialogClass *klass)
-{
-  GtkWidgetClass *widget_class = GTK_WIDGET_CLASS (klass);
-  GObjectClass *object_class = G_OBJECT_CLASS (klass);
-
-  object_class->set_property = cc_wwan_apn_dialog_set_property;
-  object_class->constructed  = cc_wwan_apn_dialog_constructed;
-  object_class->dispose = cc_wwan_apn_dialog_dispose;
-
-  widget_class->show = cc_wwan_apn_dialog_show;
-
-  properties[PROP_DEVICE] =
-    g_param_spec_object ("device",
-                         "Device",
-                         "The WWAN Device",
-                         CC_TYPE_WWAN_DEVICE,
-                         G_PARAM_WRITABLE | G_PARAM_STATIC_STRINGS | G_PARAM_CONSTRUCT_ONLY);
-
-  g_object_class_install_properties (object_class, N_PROPS, properties);
-
-  gtk_widget_class_set_template_from_resource (widget_class,
-                                               "/org/gnome/control-center/wwan/cc-wwan-apn-dialog.ui");
-
-  gtk_widget_class_bind_template_child (widget_class, CcWwanApnDialog, add_button);
-  gtk_widget_class_bind_template_child (widget_class, CcWwanApnDialog, apn_edit_view);
-  gtk_widget_class_bind_template_child (widget_class, CcWwanApnDialog, apn_entry);
-  gtk_widget_class_bind_template_child (widget_class, CcWwanApnDialog, apn_list);
-  gtk_widget_class_bind_template_child (widget_class, CcWwanApnDialog, apn_list_view);
-  gtk_widget_class_bind_template_child (widget_class, CcWwanApnDialog, apn_radio_button);
-  gtk_widget_class_bind_template_child (widget_class, CcWwanApnDialog, apn_settings_stack);
-  gtk_widget_class_bind_template_child (widget_class, CcWwanApnDialog, back_button);
-  gtk_widget_class_bind_template_child (widget_class, CcWwanApnDialog, name_entry);
-  gtk_widget_class_bind_template_child (widget_class, CcWwanApnDialog, password_entry);
-  gtk_widget_class_bind_template_child (widget_class, CcWwanApnDialog, save_button);
-  gtk_widget_class_bind_template_child (widget_class, CcWwanApnDialog, username_entry);
-
-  gtk_widget_class_bind_template_callback (widget_class, cc_wwan_apn_back_clicked_cb);
-  gtk_widget_class_bind_template_callback (widget_class, cc_wwan_apn_add_clicked_cb);
-  gtk_widget_class_bind_template_callback (widget_class, cc_wwan_apn_save_clicked_cb);
-  gtk_widget_class_bind_template_callback (widget_class, cc_wwan_apn_entry_changed_cb);
-  gtk_widget_class_bind_template_callback (widget_class, cc_wwan_apn_activated_cb);
-}
-
-static void
-cc_wwan_apn_dialog_init (CcWwanApnDialog *self)
-{
-  gtk_widget_init_template (GTK_WIDGET (self));
-}
-
-CcWwanApnDialog *
-cc_wwan_apn_dialog_new (GtkWindow    *parent_window,
-                        CcWwanDevice *device)
-{
-  g_return_val_if_fail (GTK_IS_WINDOW (parent_window), NULL);
-  g_return_val_if_fail (CC_IS_WWAN_DEVICE (device), NULL);
-
-  return g_object_new (CC_TYPE_WWAN_APN_DIALOG,
-                       "transient-for", parent_window,
-                       "use-header-bar", 1,
-                       "device", device,
-                       NULL);
-}
diff --git a/panels/wwan/cc-wwan-apn-dialog.h b/panels/wwan/cc-wwan-apn-dialog.h
deleted file mode 100644
index 0e98858..0000000
--- a/panels/wwan/cc-wwan-apn-dialog.h
+++ /dev/null
@@ -1,40 +0,0 @@
-/* -*- Mode: C; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* cc-wwan-apn-dialog.h
- *
- * Copyright 2019 Purism SPC
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- *
- * Author(s):
- *   Mohammed Sadiq <sadiq@sadiqpk.org>
- *
- * SPDX-License-Identifier: GPL-3.0-or-later
- */
-
-#pragma once
-
-#include <handy.h>
-#include <shell/cc-panel.h>
-
-#include "cc-wwan-device.h"
-
-G_BEGIN_DECLS
-
-#define CC_TYPE_WWAN_APN_DIALOG (cc_wwan_apn_dialog_get_type())
-G_DECLARE_FINAL_TYPE (CcWwanApnDialog, cc_wwan_apn_dialog, CC, WWAN_APN_DIALOG, GtkDialog)
-
-CcWwanApnDialog *cc_wwan_apn_dialog_new   (GtkWindow       *parent_window,
-                                           CcWwanDevice    *device);
-
-G_END_DECLS
diff --git a/panels/wwan/cc-wwan-apn-dialog.ui b/panels/wwan/cc-wwan-apn-dialog.ui
deleted file mode 100644
index 9ac07ce..0000000
--- a/panels/wwan/cc-wwan-apn-dialog.ui
+++ /dev/null
@@ -1,249 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<interface>
-  <template class="CcWwanApnDialog" parent="GtkDialog">
-    <property name="default-height">480</property>
-    <property name="default-width">360</property>
-    <signal name="delete-event" handler="gtk_widget_hide_on_delete"/>
-
-    <child type="titlebar">
-      <object class="GtkHeaderBar">
-        <property name="visible">1</property>
-        <property name="title" translatable="yes">Access Points</property>
-
-        <!-- Back button -->
-        <child>
-          <object class="GtkButton" id="back_button">
-            <property name="visible">1</property>
-            <property name="use-underline">1</property>
-            <signal name="clicked" handler="cc_wwan_apn_back_clicked_cb" swapped="yes" />
-            <child internal-child="accessible">
-              <object class="AtkObject">
-                <property name="accessible-name" translatable="yes">Back</property>
-              </object>
-            </child>
-            <child>
-              <object class="GtkImage">
-                <property name="visible">1</property>
-                <property name="icon-name">go-previous-symbolic</property>
-              </object>
-            </child>
-          </object>
-          <packing>
-            <property name="pack-type">start</property>
-          </packing>
-        </child>
-
-        <!-- Add button -->
-        <child>
-          <object class="GtkButton" id="add_button">
-            <property name="visible">1</property>
-            <property name="use-underline">1</property>
-            <signal name="clicked" handler="cc_wwan_apn_add_clicked_cb" swapped="yes" />
-            <child internal-child="accessible">
-              <object class="AtkObject">
-                <property name="accessible-name" translatable="yes">Add</property>
-              </object>
-            </child>
-            <child>
-              <object class="GtkImage">
-                <property name="visible">1</property>
-                <property name="icon-name">list-add-symbolic</property>
-              </object>
-            </child>
-          </object>
-          <packing>
-            <property name="pack-type">end</property>
-          </packing>
-        </child>
-
-        <!-- Save button -->
-        <child>
-          <object class="GtkButton" id="save_button">
-            <property name="visible">0</property>
-            <property name="use-underline">1</property>
-            <property name="label" translatable="yes">_Save</property>
-            <signal name="clicked" handler="cc_wwan_apn_save_clicked_cb" swapped="yes" />
-            <style>
-              <class name="default" />
-            </style>
-          </object>
-          <packing>
-            <property name="pack-type">end</property>
-          </packing>
-        </child>
-
-      </object>
-    </child>
-
-    <child internal-child="vbox">
-      <object class="GtkBox">
-        <property name="visible">1</property>
-        <property name="border-width">0</property>
-        <property name="width-request">340</property>
-        <property name="height-request">360</property>
-
-        <child>
-          <object class="HdyClamp">
-            <property name="visible">1</property>
-            <property name="margin-top">32</property>
-            <property name="margin-bottom">32</property>
-
-            <child>
-              <object class="GtkStack" id="apn_settings_stack">
-                <property name="visible">1</property>
-                <property name="transition-type">slide-left-right</property>
-
-                <!-- Access Point List -->
-                <child>
-                  <object class="GtkScrolledWindow" id="apn_list_view">
-                    <property name="visible">1</property>
-                    <property name="margin-start">18</property>
-                    <property name="margin-end">18</property>
-                    <child>
-                      <object class="GtkListBox" id="apn_list">
-                        <property name="visible">1</property>
-                        <property name="valign">start</property>
-                        <property name="selection-mode">none</property>
-                        <signal name="row-activated" handler="cc_wwan_apn_activated_cb" swapped="yes" />
-                        <style>
-                          <class name="content" />
-                        </style>
-                      </object>
-                    </child>
-                  </object>
-                </child>
-
-                <child>
-                  <object class="GtkGrid" id="apn_edit_view">
-                    <property name="visible">1</property>
-                    <property name="orientation">vertical</property>
-                    <property name="expand">1</property>
-                    <property name="margin-start">18</property>
-                    <property name="margin-end">18</property>
-                    <property name="row-spacing">6</property>
-                    <property name="column-spacing">12</property>
-
-                    <!-- Name -->
-                    <child>
-                      <object class="GtkLabel">
-                        <property name="visible">1</property>
-                        <property name="halign">end</property>
-                        <property name="valign">center</property>
-                        <property name="label" translatable="yes">Name</property>
-                        <style>
-                           <class name="dim-label" />
-                        </style>
-                      </object>
-                      <packing>
-                        <property name="left-attach">0</property>
-                        <property name="top-attach">0</property>
-                      </packing>
-                    </child>
-                    <child>
-                      <object class="GtkEntry" id="name_entry">
-                        <property name="visible">1</property>
-                        <property name="hexpand">1</property>
-                        <signal name="changed" handler="cc_wwan_apn_entry_changed_cb" swapped="yes" />
-                      </object>
-                      <packing>
-                        <property name="left-attach">1</property>
-                        <property name="top-attach">0</property>
-                      </packing>
-                    </child>
-
-                    <!-- APN -->
-                    <child>
-                      <object class="GtkLabel">
-                        <property name="visible">1</property>
-                        <property name="halign">end</property>
-                        <property name="valign">center</property>
-                        <property name="label" translatable="yes">APN</property>
-                        <style>
-                          <class name="dim-label" />
-                        </style>
-                      </object>
-                      <packing>
-                        <property name="left-attach">0</property>
-                        <property name="top-attach">1</property>
-                      </packing>
-                    </child>
-                    <child>
-                      <object class="GtkEntry" id="apn_entry">
-                        <property name="visible">1</property>
-                        <property name="margin-bottom">12</property>
-                        <signal name="changed" handler="cc_wwan_apn_entry_changed_cb" swapped="yes" />
-                      </object>
-                      <packing>
-                        <property name="left-attach">1</property>
-                        <property name="top-attach">1</property>
-                      </packing>
-                    </child>
-
-                    <!-- Username -->
-                    <child>
-                      <object class="GtkLabel">
-                        <property name="visible">1</property>
-                        <property name="halign">end</property>
-                        <property name="valign">center</property>
-                        <property name="label" translatable="yes">Username</property>
-                        <style>
-                          <class name="dim-label" />
-                        </style>
-                      </object>
-                      <packing>
-                        <property name="left-attach">0</property>
-                        <property name="top-attach">2</property>
-                      </packing>
-                    </child>
-                    <child>
-                      <object class="GtkEntry" id="username_entry">
-                        <property name="visible">1</property>
-                      </object>
-                      <packing>
-                        <property name="left-attach">1</property>
-                        <property name="top-attach">2</property>
-                      </packing>
-                    </child>
-
-                    <!-- Password -->
-                    <child>
-                      <object class="GtkLabel">
-                        <property name="visible">1</property>
-                        <property name="halign">end</property>
-                        <property name="valign">center</property>
-                        <property name="label" translatable="yes">Password</property>
-                        <style>
-                          <class name="dim-label" />
-                        </style>
-                      </object>
-                      <packing>
-                        <property name="left-attach">0</property>
-                        <property name="top-attach">3</property>
-                      </packing>
-                    </child>
-                    <child>
-                      <object class="GtkEntry" id="password_entry">
-                        <property name="visible">1</property>
-                        <property name="margin-bottom">12</property>
-                      </object>
-                      <packing>
-                        <property name="left-attach">1</property>
-                        <property name="top-attach">3</property>
-                      </packing>
-                    </child>
-
-                  </object>
-                </child>
-
-              </object> <!-- ./GtkStack apn_settings_stack -->
-            </child>
-          </object>
-        </child>
-      </object>
-    </child> <!-- ./internal-child -->
-
-  </template>
-
-  <!-- A simple hack to create a radio button group -->
-  <object class="GtkRadioButton" id="apn_radio_button" />
-</interface>
diff --git a/panels/wwan/cc-wwan-data.c b/panels/wwan/cc-wwan-data.c
deleted file mode 100644
index 4062d78..0000000
--- a/panels/wwan/cc-wwan-data.c
+++ /dev/null
@@ -1,1457 +0,0 @@
-/* -*- Mode: C; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* cc-wwan-data.c
- *
- * Copyright 2019 Purism SPC
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- *
- * Author(s):
- *   Mohammed Sadiq <sadiq@sadiqpk.org>
- *
- * SPDX-License-Identifier: GPL-3.0-or-later
- */
-
-#undef G_LOG_DOMAIN
-#define G_LOG_DOMAIN "cc-wwan-data"
-
-#ifdef HAVE_CONFIG_H
-# include <config.h>
-#endif
-
-#define _GNU_SOURCE
-#include <string.h>
-#include <glib/gi18n.h>
-#include <nma-mobile-providers.h>
-
-#include "cc-wwan-data.h"
-
-/**
- * @short_description: Device Internet Data Object
- * @include: "cc-wwan-device-data.h"
- *
- * #CcWwanData represents the data object of the given
- * #CcWwanDevice.  Please note that while #CcWWanDevice
- * is bound to the hardware device, #CcWwanData may also
- * depend on the inserted SIM (if supported). So the state
- * of #CcWwanData changes when SIM is changed.
- */
-
-/*
- * Priority for connections. The larger the number, the lower the priority
- * https://developer.gnome.org/NetworkManager/stable/nm-settings.html:
- *
- *   A lower value is better (higher priority). Zero selects a globally
- *   configured default value. If the latter is missing or zero too, it
- *   defaults to 50 for VPNs and 100 for other connections.
- *
- * Since WiFi and other network connections will likely get the default
- * setting of 100, set WWAN DNS priorities higher than the default, with
- * room to allow multiple modems to set priority above/below each other.
- */
-#define CC_WWAN_DNS_PRIORITY_LOW  (120)
-#define CC_WWAN_DNS_PRIORITY_HIGH (115)
-
-/* These are to be set as route metric */
-#define CC_WWAN_ROUTE_PRIORITY_LOW  (1050)
-#define CC_WWAN_ROUTE_PRIORITY_HIGH (1040)
-
-struct _CcWwanData
-{
-  GObject      parent_instance;
-
-  MMObject    *mm_object;
-  MMModem     *modem;
-  MMSim       *sim;
-  gchar       *sim_id;
-
-  gchar       *operator_code; /* MCCMNC */
-  GError      *error;
-
-  NMClient           *nm_client;
-  NMDevice           *nm_device;
-  NMAMobileProvidersDatabase *apn_db;
-  NMAMobileProvider  *apn_provider;
-  CcWwanDataApn      *default_apn;
-  CcWwanDataApn      *old_default_apn;
-  GListStore         *apn_list;
-  NMActiveConnection *active_connection;
-
-  gint     priority;
-  gboolean data_enabled; /* autoconnect enabled */
-  gboolean home_only;    /* Data roaming */
-};
-
-G_DEFINE_TYPE (CcWwanData, cc_wwan_data, G_TYPE_OBJECT)
-
-/*
- * Default Access Point Settings Logic:
- * For a provided SIM, all the APNs available from NetworkManager
- * that matches the given SIM identifier (ICCID, available via
- * mm_sim_get_identifier() or similar gdbus API) is loaded for
- * the Device (In NetworkManager, it is saved as ‘sim-id’, if
- * present).  At a time, only one connection will be bound to
- * a device.  If there are more than one match, the item with
- * the highest ‘route-metric’ is taken.  If more matches are
- * still available, the first item is chosen.
- *
- * Populating All available APNs:
- * All Possible APNs for the given sim are populated the following
- * way (A list of all the following avoiding duplicates)
- * 1. The above mentioned “Default Access Point Settings Logic”
- * 2. Get All saved Network Manager connections with the
- *    provided MCCMNC of the given SIM
- * 3. Get All possible APNs for the MCCMNC from mobile-provider-info
- *
- * Testing if data is enabled:
- * Check if any of the items from step 1 have ‘autoconnect’ set
- *
- * Checking/Setting current SIM for data (in case of multiple SIM):
- * Since other networks (like wifi, ethernet) should have higher
- * priorities we use a negative number for priority.
- * 1. All APNs by default have priority CC_WWAN_APN_PRIORITY_LOW
- * 2. APN of selected SIM for active data have priority of
- *    CC_WWAN_APN_PRIORITY_HIGH
- *
- * XXX: Since users may create custom APNs via nmtui or like tools
- * we may have to check if there are some inconsistencies with APNs
- * available in NetworkManager, and ask user if they have to reset
- * the APNs that have invalid settings (basically, we care only APNs
- * that are set to have ‘autoconnect’ enabled, and all we need is to
- * disable autoconnect). We won’t interfere CDMA/EVDO networks.
- */
-struct _CcWwanDataApn {
-  GObject parent_instance;
-
-  /* Set if the APN is from the mobile-provider-info database */
-  NMAMobileAccessMethod *access_method;
-
-  /* Set if the APN is saved in NetworkManager */
-  NMConnection *nm_connection;
-  NMRemoteConnection *remote_connection;
-
-  gboolean modified;
-};
-
-G_DEFINE_TYPE (CcWwanDataApn, cc_wwan_data_apn, G_TYPE_OBJECT)
-
-enum {
-  PROP_0,
-  PROP_ERROR,
-  PROP_ENABLED,
-  N_PROPS
-};
-
-static GParamSpec *properties[N_PROPS];
-
-static void
-wwan_data_apn_reset (CcWwanDataApn *apn)
-{
-  if (!apn)
-    return;
-
-  g_clear_object (&apn->nm_connection);
-  g_clear_object (&apn->remote_connection);
-}
-
-static NMConnection *
-wwan_data_get_nm_connection (CcWwanDataApn *apn)
-{
-  NMConnection *connection;
-  NMSetting *setting;
-  g_autofree gchar *uuid = NULL;
-
-  if (apn->nm_connection)
-    return apn->nm_connection;
-
-  if (apn->remote_connection)
-    return NM_CONNECTION (apn->remote_connection);
-
-  connection = nm_simple_connection_new ();
-  apn->nm_connection = connection;
-
-  setting = nm_setting_connection_new ();
-  uuid = nm_utils_uuid_generate ();
-  g_object_set (setting,
-                NM_SETTING_CONNECTION_UUID, uuid,
-                NM_SETTING_CONNECTION_TYPE, NM_SETTING_GSM_SETTING_NAME,
-                NULL);
-  nm_connection_add_setting (connection, setting);
-
-  setting = nm_setting_serial_new ();
-  nm_connection_add_setting (connection, setting);
-
-  setting = nm_setting_ip4_config_new ();
-  g_object_set (setting, NM_SETTING_IP_CONFIG_METHOD, "auto", NULL);
-  nm_connection_add_setting (connection, setting);
-
-  nm_connection_add_setting (connection, nm_setting_gsm_new ());
-  nm_connection_add_setting (connection, nm_setting_ppp_new ());
-
-  return apn->nm_connection;
-}
-
-static gboolean
-wwan_data_apn_are_same (NMRemoteConnection    *remote_connection,
-                        NMAMobileAccessMethod *access_method)
-{
-  NMConnection *connection;
-  NMSetting *setting;
-
-  if (!remote_connection)
-    return FALSE;
-
-  connection = NM_CONNECTION (remote_connection);
-  setting = NM_SETTING (nm_connection_get_setting_gsm (connection));
-
-  if (g_strcmp0 (nma_mobile_access_method_get_3gpp_apn (access_method),
-                 nm_setting_gsm_get_apn (NM_SETTING_GSM (setting))) != 0)
-    return FALSE;
-
-  if (g_strcmp0 (nma_mobile_access_method_get_username (access_method),
-                 nm_setting_gsm_get_username (NM_SETTING_GSM (setting))) != 0)
-    return FALSE;
-
-  if (g_strcmp0 (nma_mobile_access_method_get_password (access_method),
-                 nm_setting_gsm_get_password (NM_SETTING_GSM (setting))) != 0)
-    return FALSE;
-
-  return TRUE;
-}
-
-static CcWwanDataApn *
-wwan_data_find_matching_apn (CcWwanData            *self,
-                             NMAMobileAccessMethod *access_method)
-{
-  CcWwanDataApn *apn;
-  guint i, n_items;
-
-  n_items = g_list_model_get_n_items (G_LIST_MODEL (self->apn_list));
-
-  for (i = 0; i < n_items; i++)
-    {
-      apn = g_list_model_get_item (G_LIST_MODEL (self->apn_list), i);
-
-      if (apn->access_method == access_method)
-        return apn;
-
-      if (wwan_data_apn_are_same (apn->remote_connection,
-                                  access_method))
-        return apn;
-
-      g_object_unref (apn);
-    }
-
-  return NULL;
-}
-
-static gboolean
-wwan_data_nma_method_is_mms (NMAMobileAccessMethod *method)
-{
-  const char *str;
-
-  str = nma_mobile_access_method_get_3gpp_apn (method);
-  if (str && strcasestr (str, "mms"))
-    return TRUE;
-
-  str = nma_mobile_access_method_get_name (method);
-  if (str && strcasestr (str, "mms"))
-    return TRUE;
-
-  return FALSE;
-}
-
-static void
-wwan_data_update_apn_list_db (CcWwanData *self)
-{
-  GSList *apn_methods = NULL, *l;
-  g_autoptr(GError) error = NULL;
-  guint i = 0;
-
-  if (!self->sim || !self->operator_code)
-    return;
-
-  if (!self->apn_list)
-    self->apn_list = g_list_store_new (CC_TYPE_WWAN_DATA_APN);
-
-  if (!self->apn_db)
-    self->apn_db = nma_mobile_providers_database_new_sync (NULL, NULL, NULL, &error);
-
-  if (error)
-    {
-      g_warning ("%s", error->message);
-      return;
-    }
-
-  if (!self->apn_provider)
-    self->apn_provider = nma_mobile_providers_database_lookup_3gpp_mcc_mnc (self->apn_db,
-                                                                            self->operator_code);
-
-  if (self->apn_provider)
-    apn_methods = nma_mobile_provider_get_methods (self->apn_provider);
-
-  for (l = apn_methods; l; l = l->next, i++)
-    {
-      g_autoptr(CcWwanDataApn) apn = NULL;
-
-      /* We don’t list MMS APNs */
-      if (wwan_data_nma_method_is_mms (l->data))
-        continue;
-
-      apn = wwan_data_find_matching_apn (self, l->data);
-
-      /* Prepend the item in order */
-      if (!apn)
-        {
-          apn = cc_wwan_data_apn_new ();
-          g_list_store_insert (self->apn_list, i, apn);
-        }
-
-      apn->access_method = l->data;
-    }
-}
-
-static void
-wwan_data_update_apn_list (CcWwanData *self)
-{
-  const GPtrArray *nm_connections;
-  guint i;
-
-  if (self->apn_list || !self->sim)
-    return;
-
-  if (!self->apn_list)
-    self->apn_list = g_list_store_new (CC_TYPE_WWAN_DATA_APN);
-
-  if (self->nm_device)
-    {
-      nm_connections = nm_device_get_available_connections (self->nm_device);
-
-      for (i = 0; i < nm_connections->len; i++)
-        {
-          g_autoptr(CcWwanDataApn) apn = NULL;
-
-          apn = cc_wwan_data_apn_new ();
-          apn->remote_connection = g_object_ref (nm_connections->pdata[i]);
-          g_list_store_append (self->apn_list, apn);
-
-          /* Load the default APN */
-          if (!self->default_apn && self->sim_id)
-            {
-              NMSettingConnection *connection_setting;
-              NMSettingIPConfig *ip_setting;
-              NMSettingGsm *setting;
-              NMConnection *connection;
-              const gchar *sim_id;
-
-              connection = NM_CONNECTION (apn->remote_connection);
-              setting = nm_connection_get_setting_gsm (connection);
-              connection_setting = nm_connection_get_setting_connection (connection);
-              sim_id = nm_setting_gsm_get_sim_id (setting);
-
-              if (sim_id && *sim_id && g_str_equal (sim_id, self->sim_id))
-                {
-                  self->default_apn = apn;
-                  self->home_only = nm_setting_gsm_get_home_only (setting);
-                  self->data_enabled = nm_setting_connection_get_autoconnect (connection_setting);
-
-                  /* If any of the APN has a high priority, the device have high priority */
-                  ip_setting = nm_connection_get_setting_ip4_config (connection);
-                  if (nm_setting_ip_config_get_route_metric (ip_setting) == CC_WWAN_ROUTE_PRIORITY_HIGH)
-                    self->priority = CC_WWAN_APN_PRIORITY_HIGH;
-                }
-            }
-        }
-    }
-}
-
-static void
-wwan_device_state_changed_cb (CcWwanData *self)
-{
-  g_object_notify_by_pspec (G_OBJECT (self), properties[PROP_ENABLED]);
-}
-
-static void
-cc_wwan_data_get_property (GObject    *object,
-                           guint       prop_id,
-                           GValue     *value,
-                           GParamSpec *pspec)
-{
-  CcWwanData *self = (CcWwanData *)object;
-
-  switch (prop_id)
-    {
-    case PROP_ERROR:
-      g_value_set_boolean (value, self->error != NULL);
-      break;
-
-    case PROP_ENABLED:
-      g_value_set_boolean (value, cc_wwan_data_get_enabled (self));
-      break;
-
-    default:
-      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
-    }
-}
-
-static void
-cc_wwan_data_dispose (GObject *object)
-{
-  CcWwanData *self = (CcWwanData *)object;
-
-  g_clear_pointer (&self->sim_id, g_free);
-  g_clear_pointer (&self->operator_code, g_free);
-  g_clear_error (&self->error);
-  g_clear_object (&self->apn_list);
-  g_clear_object (&self->modem);
-  g_clear_object (&self->mm_object);
-  g_clear_object (&self->nm_client);
-  g_clear_object (&self->active_connection);
-  g_clear_object (&self->apn_db);
-
-  G_OBJECT_CLASS (cc_wwan_data_parent_class)->dispose (object);
-}
-
-static void
-cc_wwan_data_class_init (CcWwanDataClass *klass)
-{
-  GObjectClass *object_class = G_OBJECT_CLASS (klass);
-
-  object_class->get_property = cc_wwan_data_get_property;
-  object_class->dispose = cc_wwan_data_dispose;
-
-  properties[PROP_ERROR] =
-    g_param_spec_boolean ("error",
-                          "Error",
-                          "Set if some Error occurs",
-                          FALSE,
-                          G_PARAM_READABLE | G_PARAM_STATIC_STRINGS);
-
-  properties[PROP_ENABLED] =
-    g_param_spec_boolean ("enabled",
-                          "Enabled",
-                          "Get if the data is enabled",
-                          FALSE,
-                          G_PARAM_READABLE | G_PARAM_STATIC_STRINGS);
-
-  g_object_class_install_properties (object_class, N_PROPS, properties);
-}
-
-static void
-cc_wwan_data_init (CcWwanData *self)
-{
-  self->home_only = TRUE;
-  self->priority = CC_WWAN_APN_PRIORITY_LOW;
-}
-
-/**
- * cc_wwan_data_new:
- * @mm_object: An #MMObject
- * @nm_client: An #NMClient
- *
- * Create a new device data representing the given
- * @mm_object. If @mm_object isn’t a 3G/CDMA/LTE
- * modem, %NULL will be returned
- *
- * Returns: A #CcWwanData or %NULL.
- */
-CcWwanData *
-cc_wwan_data_new (MMObject *mm_object,
-                  NMClient *nm_client)
-{
-  CcWwanData *self;
-  NMDevice *nm_device = NULL;
-  g_autoptr(MMModem) modem = NULL;
-  NMDeviceModemCapabilities capabilities = 0;
-
-  g_return_val_if_fail (MM_IS_OBJECT (mm_object), NULL);
-  g_return_val_if_fail (NM_CLIENT (nm_client), NULL);
-
-  modem = mm_object_get_modem (mm_object);
-
-  if (modem)
-    nm_device = nm_client_get_device_by_iface (nm_client,
-                                               mm_modem_get_primary_port (modem));
-
-  if (NM_IS_DEVICE_MODEM (nm_device))
-    capabilities = nm_device_modem_get_current_capabilities (NM_DEVICE_MODEM (nm_device));
-
-  if (!(capabilities & (NM_DEVICE_MODEM_CAPABILITY_GSM_UMTS
-                        | NM_DEVICE_MODEM_CAPABILITY_LTE)))
-    return NULL;
-
-  self = g_object_new (CC_TYPE_WWAN_DATA, NULL);
-
-  self->nm_client = g_object_ref (nm_client);
-  self->mm_object = g_object_ref (mm_object);
-  self->modem = g_steal_pointer (&modem);
-  self->sim = mm_modem_get_sim_sync (self->modem, NULL, NULL);
-  self->sim_id = mm_sim_dup_identifier (self->sim);
-  self->operator_code = mm_sim_dup_operator_identifier (self->sim);
-  self->nm_device = g_object_ref (nm_device);
-  self->active_connection = nm_device_get_active_connection (nm_device);
-
-  if (!self->operator_code)
-    {
-      MMModem3gpp *modem_3gpp;
-
-      modem_3gpp = mm_object_peek_modem_3gpp (mm_object);
-      if (modem_3gpp)
-        self->operator_code = mm_modem_3gpp_dup_operator_code (modem_3gpp);
-    }
-
-  if (self->active_connection)
-    g_object_ref (self->active_connection);
-
-  g_signal_connect_object (self->nm_device, "notify::state",
-                           G_CALLBACK (wwan_device_state_changed_cb),
-                           self, G_CONNECT_SWAPPED);
-
-  wwan_data_update_apn_list (self);
-  wwan_data_update_apn_list_db (self);
-
-  return self;
-}
-
-GError *
-cc_wwan_data_get_error (CcWwanData *self)
-{
-  g_return_val_if_fail (CC_IS_WWAN_DATA (self), NULL);
-
-  return self->error;
-}
-
-const gchar *
-cc_wwan_data_get_simple_html_error (CcWwanData *self)
-{
-  g_return_val_if_fail (CC_IS_WWAN_DATA (self), NULL);
-
-  if (!self->error)
-    return NULL;
-
-  if (g_error_matches (self->error, G_IO_ERROR, G_IO_ERROR_CANCELLED))
-    return _("Operation Cancelled");
-
-  if (g_error_matches (self->error, G_DBUS_ERROR, G_DBUS_ERROR_ACCESS_DENIED))
-    return _("<b>Error:</b> Access denied changing settings");
-
-  if (self->error->domain == MM_MOBILE_EQUIPMENT_ERROR)
-    return _("<b>Error:</b> Mobile Equipment Error");
-
-  return NULL;
-}
-
-GListModel *
-cc_wwan_data_get_apn_list (CcWwanData *self)
-{
-  g_return_val_if_fail (CC_IS_WWAN_DATA (self), NULL);
-
-  if (!self->apn_list)
-    wwan_data_update_apn_list (self);
-
-  return G_LIST_MODEL (self->apn_list);
-}
-
-static gboolean
-wwan_data_apn_is_new (CcWwanDataApn *apn)
-{
-  return apn->remote_connection == NULL;
-}
-
-static void
-wwan_data_update_apn (CcWwanData    *self,
-                      CcWwanDataApn *apn,
-                      NMConnection  *connection)
-{
-  NMSetting *setting;
-  const gchar *name, *username, *password, *apn_name;
-  gint dns_priority, route_metric;
-
-  setting = NM_SETTING (nm_connection_get_setting_connection (connection));
-
-  g_object_set (setting,
-                NM_SETTING_CONNECTION_AUTOCONNECT, self->data_enabled,
-                NULL);
-
-  setting = NM_SETTING (nm_connection_get_setting_gsm (connection));
-
-  g_object_set (setting,
-                NM_SETTING_GSM_HOME_ONLY, self->home_only,
-                NULL);
-
-  setting = NM_SETTING (nm_connection_get_setting_ip4_config (connection));
-  if (self->priority == CC_WWAN_APN_PRIORITY_HIGH &&
-      self->default_apn == apn)
-    {
-      dns_priority = CC_WWAN_DNS_PRIORITY_HIGH;
-      route_metric = CC_WWAN_ROUTE_PRIORITY_HIGH;
-    }
-  else
-    {
-      dns_priority = CC_WWAN_DNS_PRIORITY_LOW;
-      route_metric = CC_WWAN_ROUTE_PRIORITY_LOW;
-    }
-
-  g_object_set (setting,
-                NM_SETTING_IP_CONFIG_DNS_PRIORITY, dns_priority,
-                NM_SETTING_IP_CONFIG_ROUTE_METRIC, (gint64)route_metric,
-                NULL);
-
-  if (apn->access_method && !apn->remote_connection)
-    {
-      name = nma_mobile_access_method_get_name (apn->access_method);
-      username = nma_mobile_access_method_get_username (apn->access_method);
-      password = nma_mobile_access_method_get_password (apn->access_method);
-      apn_name = nma_mobile_access_method_get_3gpp_apn (apn->access_method);
-    }
-  else
-    {
-      return;
-    }
-
-  setting = NM_SETTING (nm_connection_get_setting_gsm (connection));
-  g_object_set (setting,
-                NM_SETTING_GSM_USERNAME, username,
-                NM_SETTING_GSM_PASSWORD, password,
-                NM_SETTING_GSM_APN, apn_name,
-                NULL);
-
-  setting = NM_SETTING (nm_connection_get_setting_connection (connection));
-
-  g_object_set (setting,
-                NM_SETTING_CONNECTION_ID, name,
-                NULL);
-}
-
-static gint
-wwan_data_get_apn_index (CcWwanData    *self,
-                         CcWwanDataApn *apn)
-{
-  GListModel *model;
-  guint i, n_items;
-
-  model = G_LIST_MODEL (self->apn_list);
-  n_items = g_list_model_get_n_items (model);
-
-  for (i = 0; i < n_items; i++)
-    {
-      g_autoptr(CcWwanDataApn) cached_apn = NULL;
-
-      cached_apn = g_list_model_get_item (model, i);
-
-      if (apn == cached_apn)
-        return i;
-    }
-
-  return -1;
-}
-
-static void
-cc_wwan_data_connection_updated_cb (GObject      *object,
-                                    GAsyncResult *result,
-                                    gpointer      user_data)
-{
-  CcWwanData *self;
-  CcWwanDataApn *apn;
-  g_autoptr(GTask) task = user_data;
-  g_autoptr(GError) error = NULL;
-
-  self = g_task_get_source_object (G_TASK (task));
-  apn = g_task_get_task_data (G_TASK (task));
-
-  nm_remote_connection_commit_changes_finish (apn->remote_connection,
-                                              result, &error);
-  if (!error)
-    {
-      guint apn_index;
-      apn_index = wwan_data_get_apn_index (self, apn);
-
-      if (apn_index >= 0)
-        g_list_model_items_changed (G_LIST_MODEL (self->apn_list),
-                                    apn_index, 1, 1);
-      else
-        g_warning ("APN ‘%s’ not in APN list",
-                   cc_wwan_data_apn_get_name (apn));
-
-      apn->modified = FALSE;
-      g_task_return_boolean (task, TRUE);
-    }
-  else
-    {
-      g_task_return_error (task, g_steal_pointer (&error));
-    }
-}
-
-static void
-cc_wwan_data_new_connection_added_cb (GObject      *object,
-                                      GAsyncResult *result,
-                                      gpointer      user_data)
-{
-  CcWwanData *self;
-  CcWwanDataApn *apn;
-  g_autoptr(GTask) task = user_data;
-  g_autoptr(GError) error = NULL;
-
-  self = g_task_get_source_object (G_TASK (task));
-  apn = g_task_get_task_data (G_TASK (task));
-  apn->remote_connection = nm_client_add_connection_finish (self->nm_client,
-                                                            result, &error);
-  if (!error)
-    {
-      apn->modified = FALSE;
-
-      /* If APN has access method, it’s already on the list */
-      if (!apn->access_method)
-        {
-          g_list_store_append (self->apn_list, apn);
-          g_object_unref (apn);
-        }
-
-      g_task_return_pointer (task, apn, NULL);
-    }
-  else
-    {
-      g_task_return_error (task, g_steal_pointer (&error));
-    }
-}
-
-void
-cc_wwan_data_save_apn (CcWwanData          *self,
-                       CcWwanDataApn       *apn,
-                       GCancellable        *cancellable,
-                       GAsyncReadyCallback  callback,
-                       gpointer             user_data)
-{
-  NMConnection *connection = NULL;
-  g_autoptr(GTask) task = NULL;
-
-  g_return_if_fail (CC_IS_WWAN_DATA (self));
-  g_return_if_fail (CC_IS_WWAN_DATA_APN (apn));
-  g_return_if_fail (!cancellable || G_IS_CANCELLABLE (cancellable));
-
-  task = g_task_new (self, cancellable, callback, user_data);
-  g_task_set_task_data (task, apn, NULL);
-
-  connection = wwan_data_get_nm_connection (apn);
-
-  /* If the item has a remote connection, it should already be saved.
-   * We should save it again only if it got modified */
-  if (apn->remote_connection && !apn->modified)
-    {
-      g_task_return_pointer (task, apn, NULL);
-      return;
-    }
-
-  wwan_data_update_apn (self, apn, connection);
-  if (wwan_data_apn_is_new (apn))
-    {
-      nm_client_add_connection_async (self->nm_client, apn->nm_connection,
-                                      TRUE, cancellable,
-                                      cc_wwan_data_new_connection_added_cb,
-                                      g_steal_pointer (&task));
-    }
-  else
-    {
-      nm_remote_connection_commit_changes_async (apn->remote_connection, TRUE,
-                                                 cancellable,
-                                                 cc_wwan_data_connection_updated_cb,
-                                                 g_steal_pointer (&task));
-    }
-}
-
-CcWwanDataApn *
-cc_wwan_data_save_apn_finish (CcWwanData    *self,
-                              GAsyncResult  *result,
-                              GError       **error)
-{
-  g_return_val_if_fail (CC_IS_WWAN_DATA (self), NULL);
-  g_return_val_if_fail (G_IS_TASK (result), NULL);
-
-  return g_task_propagate_pointer (G_TASK (result), error);
-}
-
-static void
-cc_wwan_data_activated_cb (GObject      *object,
-                           GAsyncResult *result,
-                           gpointer      user_data)
-{
-  CcWwanData *self;
-  NMActiveConnection *connection;
-  g_autoptr(GTask) task = user_data;
-  g_autoptr(GError) error = NULL;
-
-  self = g_task_get_source_object (G_TASK (task));
-  connection = nm_client_activate_connection_finish (self->nm_client,
-                                                     result, &error);
-  if (connection)
-    {
-      g_set_object (&self->active_connection, connection);
-      g_task_return_boolean (task, TRUE);
-    }
-  else
-    {
-      g_task_return_error (task, g_steal_pointer (&error));
-    }
-
-  if (error)
-    g_warning ("Error: %s", error->message);
-}
-
-static void
-cc_wwan_data_settings_saved_cb (GObject      *object,
-                                GAsyncResult *result,
-                                gpointer      user_data)
-{
-  CcWwanData *self;
-  GCancellable *cancellable;
-  g_autoptr(GTask) task = user_data;
-  g_autoptr(GError) error = NULL;
-
-  self = g_task_get_source_object (G_TASK (task));
-  cancellable = g_task_get_cancellable (G_TASK (task));
-
-  if (!cc_wwan_data_save_apn_finish (self, result, &error))
-    {
-      g_task_return_error (task, g_steal_pointer (&error));
-      return;
-    }
-
-  self->default_apn->modified = FALSE;
-
-  if (self->data_enabled)
-    {
-      nm_client_activate_connection_async (self->nm_client,
-                                           NM_CONNECTION (self->default_apn->remote_connection),
-                                           self->nm_device,
-                                           NULL, cancellable,
-                                           cc_wwan_data_activated_cb,
-                                           g_steal_pointer (&task));
-    }
-  else
-    {
-      if (nm_device_disconnect (self->nm_device, cancellable, &error))
-        {
-          g_clear_object (&self->active_connection);
-          g_task_return_boolean (task, TRUE);
-        }
-      else
-        {
-          g_task_return_error (task, g_steal_pointer (&error));
-        }
-    }
-}
-
-/**
- * cc_wwan_data_save_settings:
- * @cancellable: (nullable): a #GCancellable or %NULL
- * @callback: a #GAsyncReadyCallback, or %NULL
- * @user_data: closure data for @callback
- *
- * Save default settings to disk and apply changes.
- * If the default APN has data enabled, the data is
- * activated after the settings are saved.
- *
- * It’s a programmer error to call this function without
- * a default APN set.
- * Finish with cc_wwan_data_save_settings_finish().
- */
-void
-cc_wwan_data_save_settings (CcWwanData          *self,
-                            GCancellable        *cancellable,
-                            GAsyncReadyCallback  callback,
-                            gpointer             user_data)
-{
-  NMConnection *connection;
-  NMSetting *setting;
-  g_autoptr(GTask) task = NULL;
-
-  g_return_if_fail (CC_IS_WWAN_DATA (self));
-  g_return_if_fail (!cancellable || G_IS_CANCELLABLE (cancellable));
-  g_return_if_fail (self->default_apn != NULL);
-
-  task = g_task_new (self, cancellable, callback, user_data);
-
-  /* Reset old settings to default value */
-  if (self->old_default_apn && self->old_default_apn->remote_connection)
-    {
-      connection = NM_CONNECTION (self->old_default_apn->remote_connection);
-
-      setting = NM_SETTING (nm_connection_get_setting_gsm (connection));
-      g_object_set (G_OBJECT (setting),
-                    NM_SETTING_GSM_HOME_ONLY, TRUE,
-                    NM_SETTING_GSM_SIM_ID, NULL,
-                    NULL);
-
-      setting = NM_SETTING (nm_connection_get_setting_ip4_config (connection));
-      g_object_set (setting,
-                    NM_SETTING_IP_CONFIG_DNS_PRIORITY, CC_WWAN_DNS_PRIORITY_LOW,
-                    NM_SETTING_IP_CONFIG_ROUTE_METRIC, (gint64)CC_WWAN_ROUTE_PRIORITY_LOW,
-                    NULL);
-
-      setting = NM_SETTING (nm_connection_get_setting_connection (connection));
-      g_object_set (G_OBJECT (setting),
-                    NM_SETTING_CONNECTION_AUTOCONNECT, FALSE,
-                    NULL);
-
-      nm_remote_connection_commit_changes (NM_REMOTE_CONNECTION (connection),
-                                           TRUE, cancellable, NULL);
-      self->old_default_apn->modified = FALSE;
-      self->old_default_apn = NULL;
-    }
-
-  self->default_apn->modified = TRUE;
-  connection = wwan_data_get_nm_connection (self->default_apn);
-
-  setting = NM_SETTING (nm_connection_get_setting_gsm (connection));
-  g_object_set (G_OBJECT (setting),
-                NM_SETTING_GSM_HOME_ONLY, self->home_only,
-                NM_SETTING_GSM_SIM_ID, self->sim_id,
-                NULL);
-
-  cc_wwan_data_save_apn (self, self->default_apn, cancellable,
-                         cc_wwan_data_settings_saved_cb,
-                         g_steal_pointer (&task));
-}
-
-gboolean
-cc_wwan_data_save_settings_finish (CcWwanData    *self,
-                                   GAsyncResult  *result,
-                                   GError       **error)
-{
-  g_return_val_if_fail (CC_IS_WWAN_DATA (self), FALSE);
-  g_return_val_if_fail (G_IS_TASK (result), FALSE);
-
-  return g_task_propagate_boolean (G_TASK (result), error);
-}
-
-gboolean
-cc_wwan_data_delete_apn (CcWwanData     *self,
-                         CcWwanDataApn  *apn,
-                         GCancellable   *cancellable,
-                         GError        **error)
-{
-  NMRemoteConnection *connection = NULL;
-  gboolean ret = FALSE;
-  gint apn_index;
-
-  g_return_val_if_fail (CC_IS_WWAN_DATA (self), FALSE);
-  g_return_val_if_fail (!cancellable || G_IS_CANCELLABLE (cancellable), FALSE);
-  g_return_val_if_fail (CC_IS_WWAN_DATA_APN (apn), FALSE);
-  g_return_val_if_fail (error != NULL, FALSE);
-
-  apn_index = wwan_data_get_apn_index (self, apn);
-  if (apn_index == -1)
-    {
-      g_set_error (error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND,
-                   "APN not found for the connection");
-      return FALSE;
-    }
-
-  connection = g_steal_pointer (&apn->remote_connection);
-  wwan_data_apn_reset (apn);
-
-  if (connection)
-    ret = nm_remote_connection_delete (connection, cancellable, error);
-
-  if (!ret)
-    {
-      apn->remote_connection = connection;
-      *error = g_error_new (G_IO_ERROR, G_IO_ERROR_FAILED,
-                            "Deleting APN from NetworkManager failed");
-      return ret;
-    }
-
-  g_object_unref (connection);
-
-  /* We remove the item only if it's not in the mobile provider database */
-  if (!apn->access_method)
-    {
-      if (self->default_apn == apn)
-        self->default_apn = NULL;
-
-      g_list_store_remove (self->apn_list, apn_index);
-
-      return TRUE;
-    }
-
-  *error = g_error_new (G_IO_ERROR, G_IO_ERROR_READ_ONLY,
-                        "Deleting APN from NetworkManager failed");
-  return FALSE;
-}
-
-CcWwanDataApn *
-cc_wwan_data_get_default_apn (CcWwanData *self)
-{
-  g_return_val_if_fail (CC_IS_WWAN_DATA (self), NULL);
-
-  return self->default_apn;
-}
-
-gboolean
-cc_wwan_data_set_default_apn (CcWwanData    *self,
-                              CcWwanDataApn *apn)
-{
-  NMConnection *connection;
-  NMSetting *setting;
-
-  g_return_val_if_fail (CC_IS_WWAN_DATA (self), FALSE);
-  g_return_val_if_fail (CC_IS_WWAN_DATA_APN (apn), FALSE);
-  g_return_val_if_fail (self->sim_id != NULL, FALSE);
-
-  if (self->default_apn == apn)
-    return FALSE;
-
-  /*
-   * APNs are bound to the SIM, not the modem device.
-   * This will let the APN work if the same SIM inserted
-   * in a different device, and not enable data if a
-   * different SIM is inserted to the modem.
-   */
-  apn->modified = TRUE;
-  self->old_default_apn = self->default_apn;
-  self->default_apn = apn;
-  connection = wwan_data_get_nm_connection (apn);
-  setting = NM_SETTING (nm_connection_get_setting_gsm (connection));
-  g_object_set (G_OBJECT (setting),
-                NM_SETTING_GSM_SIM_ID, self->sim_id, NULL);
-
-  return TRUE;
-}
-
-gboolean
-cc_wwan_data_get_enabled (CcWwanData *self)
-{
-  NMSettingConnection *setting;
-  NMConnection *connection;
-  NMDeviceState state;
-
-  g_return_val_if_fail (CC_IS_WWAN_DATA (self), FALSE);
-
-  state = nm_device_get_state (self->nm_device);
-
-  if (state == NM_DEVICE_STATE_DISCONNECTED ||
-      state == NM_DEVICE_STATE_DEACTIVATING)
-    if (nm_device_get_state_reason (self->nm_device) == NM_DEVICE_STATE_REASON_USER_REQUESTED)
-      return FALSE;
-
-  if (nm_device_get_active_connection (self->nm_device) != NULL)
-    return TRUE;
-
-  if (!self->default_apn || !self->default_apn->remote_connection)
-    return FALSE;
-
-  connection = NM_CONNECTION (self->default_apn->remote_connection);
-  setting = nm_connection_get_setting_connection (connection);
-
-  return nm_setting_connection_get_autoconnect (setting);
-}
-
-/**
- * cc_wwan_data_set_enabled:
- * @self: A #CcWwanData
- * @enable_data: whether to enable data
- *
- * Enable data for the device.  The settings is
- * saved to disk only after a default APN is set.
- *
- * If the data is enabled, the device will automatically
- * turn data on everytime the same SIM is available.
- * The data set is bound to the SIM, not the modem device.
- *
- * Use @cc_wwan_data_save_apn() with the default APN
- * to save the changes and really enable/disable data.
- */
-void
-cc_wwan_data_set_enabled (CcWwanData *self,
-                          gboolean    enable_data)
-{
-  g_return_if_fail (CC_IS_WWAN_DATA (self));
-
-  self->data_enabled = !!enable_data;
-
-  if (self->default_apn)
-    self->default_apn->modified = TRUE;
-}
-
-gboolean
-cc_wwan_data_get_roaming_enabled (CcWwanData *self)
-{
-  g_return_val_if_fail (CC_IS_WWAN_DATA (self), FALSE);
-
-  if (!self->default_apn)
-    return FALSE;
-
-  return !self->home_only;
-}
-
-/**
- * cc_wwan_data_apn_set_roaming_enabled:
- * @self: A #CcWwanData
- * @enable_roaming: whether to enable roaming or not
- *
- * Enable roaming for the device.  The settings is
- * saved to disk only after a default APN is set.
- *
- * Use @cc_wwan_data_save_apn() with the default APN
- * to save the changes and really enable/disable data.
- */
-void
-cc_wwan_data_set_roaming_enabled (CcWwanData *self,
-                                  gboolean    enable_roaming)
-{
-  g_return_if_fail (CC_IS_WWAN_DATA (self));
-
-  self->home_only = !enable_roaming;
-
-  if (self->default_apn)
-    self->default_apn->modified = TRUE;
-}
-
-static void
-cc_wwan_data_apn_finalize (GObject *object)
-{
-  CcWwanDataApn *apn = CC_WWAN_DATA_APN (object);
-
-  wwan_data_apn_reset (apn);
-  g_clear_pointer (&apn->access_method,
-                   nma_mobile_access_method_unref);
-
-  G_OBJECT_CLASS (cc_wwan_data_parent_class)->finalize (object);
-}
-
-static void
-cc_wwan_data_apn_class_init (CcWwanDataApnClass *klass)
-{
-  GObjectClass *object_class = G_OBJECT_CLASS (klass);
-
-  object_class->finalize = cc_wwan_data_apn_finalize;
-}
-
-static void
-cc_wwan_data_apn_init (CcWwanDataApn *apn)
-{
-}
-
-CcWwanDataApn *
-cc_wwan_data_apn_new (void)
-{
-  return g_object_new (CC_TYPE_WWAN_DATA_APN, NULL);
-}
-
-/**
- * cc_wwan_data_apn_get_name:
- * @apn: A #CcWwanDataApn
- *
- * Get the Name of @apn
- *
- * Returns: (transfer none): The Name of @apn
- */
-const gchar *
-cc_wwan_data_apn_get_name (CcWwanDataApn *apn)
-{
-  g_return_val_if_fail (CC_IS_WWAN_DATA_APN (apn), "");
-
-  if (apn->remote_connection)
-    return nm_connection_get_id (NM_CONNECTION (apn->remote_connection));
-
-  if (apn->access_method)
-    return nma_mobile_access_method_get_name (apn->access_method);
-
-  return "";
-}
-
-/**
- * cc_wwan_data_apn_set_name:
- * @apn: A #CcWwanDataApn
- * @name: The name to be given for APN, should not
- * be empty
- *
- * Set the name of @apn to be @name.
- *
- * @apn is only modified, use @cc_wwan_data_save_apn()
- * to save the changes.
- */
-void
-cc_wwan_data_apn_set_name (CcWwanDataApn *apn,
-                           const gchar   *name)
-{
-  NMConnection *connection;
-  NMSettingConnection *setting;
-
-  g_return_if_fail (CC_IS_WWAN_DATA_APN (apn));
-  g_return_if_fail (name != NULL);
-  g_return_if_fail (*name != '\0');
-
-  if (g_str_equal (cc_wwan_data_apn_get_name (apn), name))
-    return;
-
-  apn->modified = TRUE;
-  connection = wwan_data_get_nm_connection (apn);
-  setting = nm_connection_get_setting_connection (connection);
-  g_object_set (G_OBJECT (setting),
-                NM_SETTING_CONNECTION_ID, name,
-                NULL);
-}
-
-/**
- * cc_wwan_data_apn_get_apn:
- * @apn: A #CcWwanDataApn
- *
- * Get the APN of @apn
- *
- * Returns: (transfer none): The APN of @apn
- */
-const gchar *
-cc_wwan_data_apn_get_apn (CcWwanDataApn *apn)
-{
-  const gchar *apn_name = "";
-
-  g_return_val_if_fail (CC_IS_WWAN_DATA_APN (apn), "");
-
-  if (apn->remote_connection)
-    {
-      NMSettingGsm *setting;
-
-      setting = nm_connection_get_setting_gsm (NM_CONNECTION (apn->remote_connection));
-      apn_name = nm_setting_gsm_get_apn (setting);
-    }
-  else if (apn->access_method)
-    {
-      apn_name = nma_mobile_access_method_get_3gpp_apn (apn->access_method);
-    }
-
-  return apn_name ? apn_name : "";
-}
-
-/**
- * cc_wwan_data_apn_set_apn:
- * @apn: A #CcWwanDataApn
- * @apn_name: The apn to be used, should not be
- * empty
- *
- * Set the APN of @apn to @apn_name. @apn_name is
- * usually a URL like “example.com” or a simple string
- * like “internet”
- *
- * @apn is only modified, use @cc_wwan_data_save_apn()
- * to save the changes.
- */
-void
-cc_wwan_data_apn_set_apn (CcWwanDataApn *apn,
-                          const gchar   *apn_name)
-{
-  NMConnection *connection;
-  NMSettingGsm *setting;
-
-  g_return_if_fail (CC_IS_WWAN_DATA_APN (apn));
-  g_return_if_fail (apn_name != NULL);
-  g_return_if_fail (*apn_name != '\0');
-
-  if (g_str_equal (cc_wwan_data_apn_get_apn (apn), apn_name))
-    return;
-
-  apn->modified = TRUE;
-  connection = wwan_data_get_nm_connection (apn);
-  setting = nm_connection_get_setting_gsm (connection);
-  g_object_set (G_OBJECT (setting),
-                NM_SETTING_GSM_APN, apn_name,
-                NULL);
-}
-
-/**
- * cc_wwan_data_apn_get_username:
- * @apn: A #CcWwanDataApn
- *
- * Get the Username of @apn
- *
- * Returns: (transfer none): The Username of @apn
- */
-const gchar *
-cc_wwan_data_apn_get_username (CcWwanDataApn *apn)
-{
-  const gchar *username = "";
-
-  g_return_val_if_fail (CC_IS_WWAN_DATA_APN (apn), "");
-
-  if (apn->remote_connection)
-    {
-      NMSettingGsm *setting;
-
-      setting = nm_connection_get_setting_gsm (NM_CONNECTION (apn->remote_connection));
-      username = nm_setting_gsm_get_username (setting);
-    }
-  else if (apn->access_method)
-    {
-      username = nma_mobile_access_method_get_username (apn->access_method);
-    }
-
-  return username ? username : "";
-}
-
-/**
- * cc_wwan_data_apn_set_username:
- * @apn: A #CcWwanDataAPN
- * @username: The username to be used
- *
- * Set the Username of @apn to @username.
- *
- * @apn is only modified, use @cc_wwan_data_save_apn()
- * to save the changes.
- */
-void
-cc_wwan_data_apn_set_username (CcWwanDataApn *apn,
-                               const gchar   *username)
-{
-  NMConnection *connection;
-  NMSettingGsm *setting;
-
-  g_return_if_fail (CC_IS_WWAN_DATA_APN (apn));
-
-  if (username && !*username)
-    username = NULL;
-
-  if (g_strcmp0 (cc_wwan_data_apn_get_username (apn), username) == 0)
-    return;
-
-  apn->modified = TRUE;
-  connection = wwan_data_get_nm_connection (apn);
-  setting = nm_connection_get_setting_gsm (connection);
-  g_object_set (G_OBJECT (setting),
-                NM_SETTING_GSM_USERNAME, username,
-                NULL);
-}
-
-/**
- * cc_wwan_data_apn_get_password:
- * @apn: A #CcWwanDataApn
- *
- * Get the Password of @apn
- *
- * Returns: (transfer none): The Password of @apn
- */
-const gchar *
-cc_wwan_data_apn_get_password (CcWwanDataApn *apn)
-{
-  const gchar *password = "";
-
-  g_return_val_if_fail (CC_IS_WWAN_DATA_APN (apn), "");
-
-  if (NM_IS_REMOTE_CONNECTION (apn->remote_connection))
-    {
-      g_autoptr(GVariant) secrets = NULL;
-      g_autoptr(GError) error = NULL;
-
-      secrets = nm_remote_connection_get_secrets (NM_REMOTE_CONNECTION (apn->remote_connection),
-                                                  "gsm", NULL, &error);
-
-      if (!error)
-        nm_connection_update_secrets (NM_CONNECTION (apn->remote_connection),
-                                      "gsm", secrets, &error);
-
-      if (error)
-        {
-          g_warning ("Error: %s", error->message);
-          return "";
-        }
-    }
-
-  if (apn->remote_connection)
-    {
-      NMSettingGsm *setting;
-
-      setting = nm_connection_get_setting_gsm (NM_CONNECTION (apn->remote_connection));
-      password = nm_setting_gsm_get_password (setting);
-    }
-  else if (apn->access_method)
-    {
-      password = nma_mobile_access_method_get_password (apn->access_method);
-    }
-
-  return password ? password : "";
-
-  if (apn->remote_connection)
-    nm_connection_clear_secrets (NM_CONNECTION (apn->remote_connection));
-}
-
-/**
- * cc_wwan_data_apn_set_password:
- * @apn: A #CcWwanDataApn
- * @password: The password to be used
- *
- * Set the Password of @apn to @password.
- *
- * @apn is only modified, use @cc_wwan_data_save_apn()
- * to save the changes.
- */
-void
-cc_wwan_data_apn_set_password (CcWwanDataApn *apn,
-                               const gchar   *password)
-{
-  NMConnection *connection;
-  NMSettingGsm *setting;
-
-  g_return_if_fail (CC_IS_WWAN_DATA_APN (apn));
-
-  if (password && !*password)
-    password = NULL;
-
-  if (g_strcmp0 (cc_wwan_data_apn_get_password (apn), password) == 0)
-    return;
-
-  apn->modified = TRUE;
-  connection = wwan_data_get_nm_connection (apn);
-  setting = nm_connection_get_setting_gsm (connection);
-  g_object_set (G_OBJECT (setting),
-                NM_SETTING_GSM_PASSWORD, password,
-                NULL);
-}
-
-gint
-cc_wwan_data_get_priority (CcWwanData *self)
-{
-  CcWwanDataApn *apn;
-  NMSettingIPConfig *setting;
-
-  g_return_val_if_fail (CC_IS_WWAN_DATA (self),
-                        CC_WWAN_APN_PRIORITY_LOW);
-
-  apn = self->default_apn;
-
-  if (!apn || !apn->remote_connection)
-    return CC_WWAN_APN_PRIORITY_LOW;
-
-  setting = nm_connection_get_setting_ip4_config (NM_CONNECTION (apn->remote_connection));
-
-  /* Lower the number, higher the priority */
-  if (nm_setting_ip_config_get_route_metric (setting) <= CC_WWAN_ROUTE_PRIORITY_HIGH)
-    return CC_WWAN_APN_PRIORITY_HIGH;
-  else
-    return CC_WWAN_APN_PRIORITY_LOW;
-}
-
-void
-cc_wwan_data_set_priority (CcWwanData *self,
-                           int         priority)
-{
-  g_return_if_fail (CC_IS_WWAN_DATA (self));
-  g_return_if_fail (priority == CC_WWAN_APN_PRIORITY_LOW ||
-                    priority == CC_WWAN_APN_PRIORITY_HIGH);
-
-  if (self->priority == priority)
-    return;
-
-  self->priority = priority;
-
-  if (self->default_apn)
-    self->default_apn->modified = TRUE;
-}
diff --git a/panels/wwan/cc-wwan-data.h b/panels/wwan/cc-wwan-data.h
deleted file mode 100644
index 9572b86..0000000
--- a/panels/wwan/cc-wwan-data.h
+++ /dev/null
@@ -1,93 +0,0 @@
-/* -*- Mode: C; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* cc-wwan-data.h
- *
- * Copyright 2019 Purism SPC
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- *
- * Author(s):
- *   Mohammed Sadiq <sadiq@sadiqpk.org>
- *
- * SPDX-License-Identifier: GPL-3.0-or-later
- */
-
-#pragma once
-
-#include <glib-object.h>
-#include <libmm-glib.h>
-#include <NetworkManager.h>
-
-G_BEGIN_DECLS
-
-#define CC_WWAN_APN_PRIORITY_LOW  (1)
-#define CC_WWAN_APN_PRIORITY_HIGH (2)
-
-#define CC_TYPE_WWAN_DATA_APN (cc_wwan_data_apn_get_type())
-G_DECLARE_FINAL_TYPE (CcWwanDataApn, cc_wwan_data_apn, CC, WWAN_DATA_APN, GObject)
-
-#define CC_TYPE_WWAN_DATA (cc_wwan_data_get_type())
-G_DECLARE_FINAL_TYPE (CcWwanData, cc_wwan_data, CC, WWAN_DATA, GObject)
-
-CcWwanData    *cc_wwan_data_new                   (MMObject             *mm_object,
-                                                   NMClient             *nm_client);
-GError        *cc_wwan_data_get_error             (CcWwanData           *self);
-const gchar   *cc_wwan_data_get_simple_html_error (CcWwanData           *self);
-GListModel    *cc_wwan_data_get_apn_list          (CcWwanData           *self);
-void           cc_wwan_data_save_apn              (CcWwanData           *self,
-                                                   CcWwanDataApn        *apn,
-                                                   GCancellable         *cancellable,
-                                                   GAsyncReadyCallback   callback,
-                                                   gpointer              user_data);
-CcWwanDataApn *cc_wwan_data_save_apn_finish       (CcWwanData           *self,
-                                                   GAsyncResult         *result,
-                                                   GError              **error);
-void           cc_wwan_data_save_settings         (CcWwanData          *self,
-                                                   GCancellable        *cancellable,
-                                                   GAsyncReadyCallback  callback,
-                                                   gpointer             user_data);
-gboolean       cc_wwan_data_save_settings_finish  (CcWwanData          *self,
-                                                   GAsyncResult        *result,
-                                                   GError             **error);
-gboolean       cc_wwan_data_delete_apn            (CcWwanData          *self,
-                                                   CcWwanDataApn       *apn,
-                                                   GCancellable        *cancellable,
-                                                   GError             **error);
-gboolean       cc_wwan_data_set_default_apn       (CcWwanData          *self,
-                                                   CcWwanDataApn       *apn);
-CcWwanDataApn *cc_wwan_data_get_default_apn       (CcWwanData          *self);
-gboolean       cc_wwan_data_get_enabled           (CcWwanData          *self);
-void           cc_wwan_data_set_enabled           (CcWwanData          *self,
-                                                   gboolean             enabled);
-gboolean       cc_wwan_data_get_roaming_enabled   (CcWwanData          *self);
-void           cc_wwan_data_set_roaming_enabled   (CcWwanData          *self,
-                                                   gboolean             enable_roaming);
-
-CcWwanDataApn *cc_wwan_data_apn_new          (void);
-const gchar   *cc_wwan_data_apn_get_name     (CcWwanDataApn *apn);
-void           cc_wwan_data_apn_set_name     (CcWwanDataApn *apn,
-                                              const gchar   *name);
-const gchar   *cc_wwan_data_apn_get_apn      (CcWwanDataApn *apn);
-void           cc_wwan_data_apn_set_apn      (CcWwanDataApn *apn,
-                                              const gchar   *apn_name);
-const gchar   *cc_wwan_data_apn_get_username (CcWwanDataApn *apn);
-void           cc_wwan_data_apn_set_username (CcWwanDataApn *apn,
-                                              const gchar   *username);
-const gchar   *cc_wwan_data_apn_get_password (CcWwanDataApn *apn);
-void           cc_wwan_data_apn_set_password (CcWwanDataApn *apn,
-                                              const gchar   *password);
-gint           cc_wwan_data_get_priority     (CcWwanData    *self);
-void           cc_wwan_data_set_priority     (CcWwanData    *self,
-                                              int            priority);
-
-G_END_DECLS
diff --git a/panels/wwan/cc-wwan-details-dialog.c b/panels/wwan/cc-wwan-details-dialog.c
deleted file mode 100644
index 59e8dc3..0000000
--- a/panels/wwan/cc-wwan-details-dialog.c
+++ /dev/null
@@ -1,257 +0,0 @@
-/* -*- Mode: C; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* cc-wwan-network-dialog.c
- *
- * Copyright 2019 Purism SPC
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- *
- * Author(s):
- *   Mohammed Sadiq <sadiq@sadiqpk.org>
- *
- * SPDX-License-Identifier: GPL-3.0-or-later
- */
-
-#undef G_LOG_DOMAIN
-#define G_LOG_DOMAIN "cc-wwan-details-dialog"
-
-#include <config.h>
-#include <glib/gi18n.h>
-#include <libmm-glib.h>
-
-#include "list-box-helper.h"
-#include "cc-wwan-details-dialog.h"
-#include "cc-wwan-resources.h"
-
-/**
- * @short_description: Dialog to Show Device Details
- */
-
-struct _CcWwanDetailsDialog
-{
-  GtkDialog     parent_instance;
-
-  GtkLabel     *device_identifier;
-  GtkLabel     *device_model;
-  GtkLabel     *firmware_version;
-  GtkLabel     *identifier_label;
-  GtkLabel     *manufacturer;
-  GtkLabel     *network_status;
-  GtkLabel     *network_type;
-  GtkLabel     *operator_name;
-  GtkLabel     *own_numbers;
-  GtkLabel     *signal_strength;
-
-  CcWwanDevice *device;
-};
-
-G_DEFINE_TYPE (CcWwanDetailsDialog, cc_wwan_details_dialog, GTK_TYPE_DIALOG)
-
-
-enum {
-  PROP_0,
-  PROP_DEVICE,
-  N_PROPS
-};
-
-static GParamSpec *properties[N_PROPS];
-
-static void
-cc_wwan_details_update_network_status (CcWwanDetailsDialog *self)
-{
-  CcWwanState state;
-
-  g_assert (CC_IS_WWAN_DETAILS_DIALOG (self));
-
-  state = cc_wwan_device_get_network_state (self->device);
-
-  switch (state)
-    {
-    case CC_WWAN_REGISTRATION_STATE_IDLE:
-      gtk_label_set_label (self->network_status, _("Not Registered"));
-      break;
-
-    case CC_WWAN_REGISTRATION_STATE_REGISTERED:
-      gtk_label_set_label (self->network_status, _("Registered"));
-      break;
-
-    case CC_WWAN_REGISTRATION_STATE_ROAMING:
-      gtk_label_set_label (self->network_status, _("Roaming"));
-      break;
-
-    case CC_WWAN_REGISTRATION_STATE_SEARCHING:
-      gtk_label_set_label (self->network_status, _("Searching"));
-      break;
-
-    case CC_WWAN_REGISTRATION_STATE_DENIED:
-      gtk_label_set_label (self->network_status, _("Denied"));
-      break;
-
-    default:
-      gtk_label_set_label (self->network_status, _("Unknown"));
-      break;
-    }
-}
-
-static void
-cc_wwan_details_signal_changed_cb (CcWwanDetailsDialog *self)
-{
-  g_autofree gchar *network_type_string = NULL;
-  g_autofree gchar *signal_string = NULL;
-  const gchar *operator_name;
-
-  g_assert (CC_IS_WWAN_DETAILS_DIALOG (self));
-
-  operator_name = cc_wwan_device_get_operator_name (self->device);
-  if (operator_name)
-    gtk_label_set_label (self->operator_name, operator_name);
-
-  network_type_string = cc_wwan_device_dup_network_type_string (self->device);
-  if (network_type_string)
-    gtk_label_set_label (self->network_type, network_type_string);
-
-  signal_string = cc_wwan_device_dup_signal_string (self->device);
-  if (signal_string)
-    gtk_label_set_label (self->signal_strength, signal_string);
-
-  cc_wwan_details_update_network_status (self);
-}
-
-static void
-cc_wwan_details_update_hardware_details (CcWwanDetailsDialog *self)
-{
-  const gchar *str;
-
-  g_assert (CC_IS_WWAN_DETAILS_DIALOG (self));
-
-  str = cc_wwan_device_get_manufacturer (self->device);
-  if (str)
-    gtk_label_set_label (self->manufacturer, str);
-
-  str = cc_wwan_device_get_model (self->device);
-  if (str)
-    gtk_label_set_label (self->device_model, str);
-
-  str = cc_wwan_device_get_firmware_version (self->device);
-  if (str)
-    gtk_label_set_label (self->firmware_version, str);
-
-  str = cc_wwan_device_get_identifier (self->device);
-  if (str)
-    gtk_label_set_label (self->device_identifier, str);
-}
-
-static void
-cc_wwan_details_dialog_set_property (GObject      *object,
-                                     guint         prop_id,
-                                     const GValue *value,
-                                     GParamSpec   *pspec)
-{
-  CcWwanDetailsDialog *self = CC_WWAN_DETAILS_DIALOG (object);
-
-  switch (prop_id)
-    {
-    case PROP_DEVICE:
-      self->device = g_value_dup_object (value);
-      break;
-
-    default:
-      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
-    }
-}
-
-static void
-cc_wwan_details_dialog_constructed (GObject *object)
-{
-  CcWwanDetailsDialog *self = CC_WWAN_DETAILS_DIALOG (object);
-  g_autofree char *numbers = NULL;
-
-  G_OBJECT_CLASS (cc_wwan_details_dialog_parent_class)->constructed (object);
-
-  g_signal_connect_object (self->device, "notify::signal",
-                           G_CALLBACK (cc_wwan_details_signal_changed_cb),
-                           self, G_CONNECT_SWAPPED);
-
-  numbers = cc_wwan_device_dup_own_numbers (self->device);
-  gtk_widget_set_visible (GTK_WIDGET (self->own_numbers), !!numbers);
-
-  if (numbers)
-    gtk_label_set_text (self->own_numbers, numbers);
-
-  cc_wwan_details_signal_changed_cb (self);
-  cc_wwan_details_update_hardware_details (self);
-}
-
-static void
-cc_wwan_details_dialog_dispose (GObject *object)
-{
-  CcWwanDetailsDialog *self = CC_WWAN_DETAILS_DIALOG (object);
-
-  g_clear_object (&self->device);
-
-  G_OBJECT_CLASS (cc_wwan_details_dialog_parent_class)->dispose (object);
-}
-
-static void
-cc_wwan_details_dialog_class_init (CcWwanDetailsDialogClass *klass)
-{
-  GtkWidgetClass *widget_class = GTK_WIDGET_CLASS (klass);
-  GObjectClass *object_class = G_OBJECT_CLASS (klass);
-
-  object_class->set_property = cc_wwan_details_dialog_set_property;
-  object_class->constructed  = cc_wwan_details_dialog_constructed;
-  object_class->dispose = cc_wwan_details_dialog_dispose;
-
-  properties[PROP_DEVICE] =
-    g_param_spec_object ("device",
-                         "Device",
-                         "The WWAN Device",
-                         CC_TYPE_WWAN_DEVICE,
-                         G_PARAM_WRITABLE | G_PARAM_STATIC_STRINGS | G_PARAM_CONSTRUCT_ONLY);
-
-  g_object_class_install_properties (object_class, N_PROPS, properties);
-
-  gtk_widget_class_set_template_from_resource (widget_class,
-                                               "/org/gnome/control-center/wwan/cc-wwan-details-dialog.ui");
-
-  gtk_widget_class_bind_template_child (widget_class, CcWwanDetailsDialog, device_identifier);
-  gtk_widget_class_bind_template_child (widget_class, CcWwanDetailsDialog, device_model);
-  gtk_widget_class_bind_template_child (widget_class, CcWwanDetailsDialog, firmware_version);
-  gtk_widget_class_bind_template_child (widget_class, CcWwanDetailsDialog, identifier_label);
-  gtk_widget_class_bind_template_child (widget_class, CcWwanDetailsDialog, manufacturer);
-  gtk_widget_class_bind_template_child (widget_class, CcWwanDetailsDialog, network_status);
-  gtk_widget_class_bind_template_child (widget_class, CcWwanDetailsDialog, network_type);
-  gtk_widget_class_bind_template_child (widget_class, CcWwanDetailsDialog, operator_name);
-  gtk_widget_class_bind_template_child (widget_class, CcWwanDetailsDialog, own_numbers);
-  gtk_widget_class_bind_template_child (widget_class, CcWwanDetailsDialog, signal_strength);
-}
-
-static void
-cc_wwan_details_dialog_init (CcWwanDetailsDialog *self)
-{
-  gtk_widget_init_template (GTK_WIDGET (self));
-}
-
-CcWwanDetailsDialog *
-cc_wwan_details_dialog_new (GtkWindow    *parent_window,
-                            CcWwanDevice *device)
-{
-  g_return_val_if_fail (GTK_IS_WINDOW (parent_window), NULL);
-  g_return_val_if_fail (CC_IS_WWAN_DEVICE (device), NULL);
-
-  return g_object_new (CC_TYPE_WWAN_DETAILS_DIALOG,
-                       "transient-for", parent_window,
-                       "use-header-bar", 1,
-                       "device", device,
-                       NULL);
-}
diff --git a/panels/wwan/cc-wwan-details-dialog.h b/panels/wwan/cc-wwan-details-dialog.h
deleted file mode 100644
index 7e7812c..0000000
--- a/panels/wwan/cc-wwan-details-dialog.h
+++ /dev/null
@@ -1,40 +0,0 @@
-/* -*- Mode: C; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* cc-wwan-details-dialog.h
- *
- * Copyright 2019 Purism SPC
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- *
- * Author(s):
- *   Mohammed Sadiq <sadiq@sadiqpk.org>
- *
- * SPDX-License-Identifier: GPL-3.0-or-later
- */
-
-#pragma once
-
-#include <handy.h>
-#include <shell/cc-panel.h>
-
-#include "cc-wwan-device.h"
-
-G_BEGIN_DECLS
-
-#define CC_TYPE_WWAN_DETAILS_DIALOG (cc_wwan_details_dialog_get_type())
-G_DECLARE_FINAL_TYPE (CcWwanDetailsDialog, cc_wwan_details_dialog, CC, WWAN_DETAILS_DIALOG, GtkDialog)
-
-CcWwanDetailsDialog *cc_wwan_details_dialog_new (GtkWindow    *parent_window,
-                                                 CcWwanDevice *device);
-
-G_END_DECLS
diff --git a/panels/wwan/cc-wwan-details-dialog.ui b/panels/wwan/cc-wwan-details-dialog.ui
deleted file mode 100644
index 042d3ee..0000000
--- a/panels/wwan/cc-wwan-details-dialog.ui
+++ /dev/null
@@ -1,320 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<interface>
-  <template class="CcWwanDetailsDialog" parent="GtkDialog">
-    <property name="title" translatable="yes">Modem Details</property>
-    <property name="default-height">480</property>
-    <property name="default-width">360</property>
-    <signal name="delete-event" handler="gtk_widget_hide_on_delete"/>
-
-    <child internal-child="vbox">
-      <object class="GtkBox">
-        <property name="visible">1</property>
-        <property name="border-width">0</property>
-        <property name="width-request">340</property>
-        <property name="height-request">360</property>
-        <child>
-          <object class="HdyClamp">
-            <property name="visible">1</property>
-            <property name="margin-top">32</property>
-            <property name="margin-bottom">32</property>
-            <property name="margin-start">18</property>
-            <property name="margin-end">18</property>
-
-            <child>
-              <object class="GtkBox">
-                <property name="visible">1</property>
-                <property name="orientation">vertical</property>
-
-                <!-- Modem Status Title -->
-                <child>
-                  <object class="GtkLabel">
-                    <property name="visible">1</property>
-                    <property name="margin-bottom">12</property>
-                    <property name="label" translatable="yes">Modem Status</property>
-                    <property name="xalign">0.0</property>
-                    <attributes>
-                      <attribute name="weight" value="bold"/>
-                    </attributes>
-                  </object>
-                </child>
-
-                <!-- Modem Status Content -->
-                <child>
-                  <object class="GtkGrid">
-                    <property name="visible">1</property>
-                    <property name="row-spacing">9</property>
-                    <property name="column-spacing">6</property>
-                    <property name="margin-bottom">24</property>
-
-                    <!-- Carrier -->
-                    <child>
-                      <object class="GtkLabel">
-                        <property name="visible">1</property>
-                        <property name="label" translatable="yes">Carrier</property>
-                        <property name="xalign">1.0</property>
-                        <style>
-                          <class name="dim-label"/>
-                        </style>
-                      </object>
-                      <packing>
-                        <property name="left-attach">0</property>
-                        <property name="top-attach">0</property>
-                      </packing>
-                    </child>
-                    <child>
-                      <object class="GtkLabel" id="operator_name">
-                        <property name="visible">1</property>
-                        <property name="xalign">0.0</property>
-                      </object>
-                      <packing>
-                        <property name="left-attach">1</property>
-                        <property name="top-attach">0</property>
-                      </packing>
-                    </child>
-
-                    <!-- Network Type -->
-                    <child>
-                      <object class="GtkLabel">
-                        <property name="visible">1</property>
-                        <property name="label" translatable="yes">Network Type</property>
-                        <property name="xalign">1.0</property>
-                        <style>
-                          <class name="dim-label"/>
-                        </style>
-                      </object>
-                      <packing>
-                        <property name="left-attach">0</property>
-                        <property name="top-attach">1</property>
-                      </packing>
-                    </child>
-                    <child>
-                      <object class="GtkLabel" id="network_type">
-                        <property name="visible">1</property>
-                        <property name="xalign">0.0</property>
-                      </object>
-                      <packing>
-                        <property name="left-attach">1</property>
-                        <property name="top-attach">1</property>
-                      </packing>
-                    </child>
-
-                    <!-- Signal Strength -->
-                    <child>
-                      <object class="GtkLabel">
-                        <property name="visible">1</property>
-                        <property name="label" translatable="yes">Signal Strength</property>
-                        <property name="xalign">1.0</property>
-                        <style>
-                          <class name="dim-label"/>
-                        </style>
-                      </object>
-                      <packing>
-                        <property name="left-attach">0</property>
-                        <property name="top-attach">2</property>
-                      </packing>
-                    </child>
-                    <child>
-                      <object class="GtkLabel" id="signal_strength">
-                        <property name="visible">1</property>
-                        <property name="xalign">0.0</property>
-                      </object>
-                      <packing>
-                        <property name="left-attach">1</property>
-                        <property name="top-attach">2</property>
-                      </packing>
-                    </child>
-
-                    <!-- Network Status -->
-                    <child>
-                      <object class="GtkLabel">
-                        <property name="visible">1</property>
-                        <property name="label" translatable="yes">Network Status</property>
-                        <property name="xalign">1.0</property>
-                        <style>
-                          <class name="dim-label"/>
-                        </style>
-                      </object>
-                      <packing>
-                        <property name="left-attach">0</property>
-                        <property name="top-attach">3</property>
-                      </packing>
-                    </child>
-                    <child>
-                      <object class="GtkLabel" id="network_status">
-                        <property name="visible">1</property>
-                        <property name="xalign">0.0</property>
-                      </object>
-                      <packing>
-                        <property name="left-attach">1</property>
-                        <property name="top-attach">3</property>
-                      </packing>
-                    </child>
-
-                    <!-- Own Numbers -->
-                    <child>
-                      <object class="GtkLabel">
-                        <property name="visible" bind-source="own_numbers"
-                                  bind-property="visible" bind-flags="sync-create"/>
-                        <property name="label" translatable="yes">Own Number</property>
-                        <property name="xalign">1.0</property>
-                        <style>
-                          <class name="dim-label"/>
-                        </style>
-                      </object>
-                      <packing>
-                        <property name="left-attach">0</property>
-                        <property name="top-attach">4</property>
-                      </packing>
-                    </child>
-                    <child>
-                      <object class="GtkLabel" id="own_numbers">
-                        <property name="visible">1</property>
-                        <property name="xalign">0.0</property>
-                      </object>
-                      <packing>
-                        <property name="left-attach">1</property>
-                        <property name="top-attach">4</property>
-                      </packing>
-                    </child>
-
-                <!-- Device Details Title -->
-                    <child>
-                      <object class="GtkLabel">
-                        <property name="visible">1</property>
-                        <property name="margin-bottom">12</property>
-                        <property name="label" translatable="yes">Device Details</property>
-                        <property name="xalign">0.0</property>
-                        <attributes>
-                          <attribute name="weight" value="bold"/>
-                        </attributes>
-                      </object>
-                      <packing>
-                        <property name="left-attach">0</property>
-                        <property name="top-attach">5</property>
-                        <property name="width">2</property>
-                      </packing>
-                    </child>
-
-                    <!-- Device Details Content -->
-                    <!-- Manufacturer -->
-                    <child>
-                      <object class="GtkLabel">
-                        <property name="visible">1</property>
-                        <property name="label" translatable="yes">Manufacturer</property>
-                        <property name="xalign">1.0</property>
-                        <style>
-                          <class name="dim-label"/>
-                        </style>
-                      </object>
-                      <packing>
-                        <property name="left-attach">0</property>
-                        <property name="top-attach">6</property>
-                      </packing>
-                    </child>
-                    <child>
-                      <object class="GtkLabel" id="manufacturer">
-                        <property name="visible">1</property>
-                        <property name="xalign">0.0</property>
-                      </object>
-                      <packing>
-                        <property name="left-attach">1</property>
-                        <property name="top-attach">6</property>
-                      </packing>
-                    </child>
-
-                    <!-- Model -->
-                    <child>
-                      <object class="GtkLabel">
-                        <property name="visible">1</property>
-                        <property name="label" translatable="yes">Model</property>
-                        <property name="xalign">1.0</property>
-                        <style>
-                          <class name="dim-label"/>
-                        </style>
-                      </object>
-                      <packing>
-                        <property name="left-attach">0</property>
-                        <property name="top-attach">7</property>
-                      </packing>
-                    </child>
-                    <child>
-                      <object class="GtkLabel" id="device_model">
-                        <property name="visible">1</property>
-                        <property name="xalign">0.0</property>
-                        <property name="selectable">1</property>
-                        <property name="ellipsize">end</property>
-                      </object>
-                      <packing>
-                        <property name="left-attach">1</property>
-                        <property name="top-attach">7</property>
-                      </packing>
-                    </child>
-
-                    <!-- Firmware version -->
-                    <child>
-                      <object class="GtkLabel">
-                        <property name="visible">1</property>
-                        <property name="label" translatable="yes">Firmware Version</property>
-                        <property name="xalign">1.0</property>
-                        <style>
-                          <class name="dim-label"/>
-                        </style>
-                      </object>
-                      <packing>
-                        <property name="left-attach">0</property>
-                        <property name="top-attach">8</property>
-                      </packing>
-                    </child>
-                    <child>
-                      <object class="GtkLabel" id="firmware_version">
-                        <property name="visible">1</property>
-                        <property name="selectable">1</property>
-                        <property name="xalign">0.0</property>
-                        <property name="ellipsize">end</property>
-                        <property name="wrap">1</property>
-                      </object>
-                      <packing>
-                        <property name="left-attach">1</property>
-                        <property name="top-attach">8</property>
-                      </packing>
-                    </child>
-
-                    <!-- IMEI/ICCID -->
-                    <child>
-                      <object class="GtkLabel" id="identifier_label">
-                        <property name="visible">1</property>
-                        <property name="label" translatable="yes">IMEI</property>
-                        <property name="xalign">1.0</property>
-                        <style>
-                          <class name="dim-label"/>
-                        </style>
-                      </object>
-                      <packing>
-                        <property name="left-attach">0</property>
-                        <property name="top-attach">9</property>
-                      </packing>
-                    </child>
-                    <child>
-                      <object class="GtkLabel" id="device_identifier">
-                        <property name="visible">1</property>
-                        <property name="selectable">1</property>
-                        <property name="xalign">0.0</property>
-                      </object>
-                      <packing>
-                        <property name="left-attach">1</property>
-                        <property name="top-attach">9</property>
-                      </packing>
-                    </child>
-
-                  </object>
-                </child>
-              </object>
-            </child>
-
-          </object> <!-- ./HdyClamp -->
-        </child>
-      </object>
-    </child> <!-- ./internal-child -->
-
-  </template>
-</interface>
diff --git a/panels/wwan/cc-wwan-device-page.c b/panels/wwan/cc-wwan-device-page.c
deleted file mode 100644
index 318faa6..0000000
--- a/panels/wwan/cc-wwan-device-page.c
+++ /dev/null
@@ -1,668 +0,0 @@
-/* -*- Mode: C; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* cc-wwan-device-page.c
- *
- * Copyright 2019 Purism SPC
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- *
- * Author(s):
- *   Mohammed Sadiq <sadiq@sadiqpk.org>
- *
- * SPDX-License-Identifier: GPL-3.0-or-later
- */
-
-#undef G_LOG_DOMAIN
-#define G_LOG_DOMAIN "cc-wwan-device-page"
-
-#include <config.h>
-#include <glib/gi18n.h>
-#include <libmm-glib.h>
-#define GCR_API_SUBJECT_TO_CHANGE
-#include <gcr/gcr.h>
-
-#include "list-box-helper.h"
-#include "cc-list-row.h"
-#include "cc-wwan-data.h"
-#include "cc-wwan-mode-dialog.h"
-#include "cc-wwan-network-dialog.h"
-#include "cc-wwan-details-dialog.h"
-#include "cc-wwan-sim-lock-dialog.h"
-#include "cc-wwan-apn-dialog.h"
-#include "cc-wwan-device-page.h"
-#include "cc-wwan-resources.h"
-
-#include "shell/cc-application.h"
-#include "shell/cc-debug.h"
-#include "shell/cc-object-storage.h"
-
-/**
- * @short_description: Device settings page
- * @include: "cc-wwan-device-page.h"
- *
- * The Device page allows users to configure device
- * settings.  Please note that there is no one-to-one
- * maping for a device settings page and a physical
- * device.  Say, if a device have two SIM card slots,
- * there should be two device pages, one for each SIM.
- */
-
-struct _CcWwanDevicePage
-{
-  GtkBox         parent_instance;
-
-  GtkListBox    *advanced_settings_list;
-  CcListRow     *apn_settings_row;
-  CcListRow     *data_enable_row;
-  CcListRow     *data_roaming_row;
-  GtkListBox    *data_settings_list;
-  CcListRow     *details_row;
-  GtkStack      *main_stack;
-  CcListRow     *network_mode_row;
-  CcListRow     *network_name_row;
-  GtkListBox    *network_settings_list;
-  CcListRow     *sim_lock_row;
-  GtkButton     *unlock_button;
-
-  GtkLabel      *notification_label;
-
-  CcWwanDevice  *device;
-  CcWwanData    *wwan_data;
-  GDBusProxy    *wwan_proxy;
-
-  CcWwanApnDialog     *apn_dialog;
-  CcWwanDetailsDialog *details_dialog;
-  CcWwanModeDialog    *network_mode_dialog;
-  CcWwanNetworkDialog *network_dialog;
-  CcWwanSimLockDialog *sim_lock_dialog;
-
-  gint                 sim_index;
-  /* Set if a change is triggered in a signal’s callback,
-   * to avoid re-triggering of callback.  This is used
-   * instead of blocking handlers where the signal may be
-   * emitted async and the block/unblock may not work right
-   */
-  gboolean is_self_change;
-  gboolean is_retry;
-};
-
-G_DEFINE_TYPE (CcWwanDevicePage, cc_wwan_device_page, GTK_TYPE_BOX)
-
-enum {
-  PROP_0,
-  PROP_DEVICE,
-  N_PROPS
-};
-
-static GParamSpec *properties[N_PROPS];
-
-static void
-wwan_device_page_handle_data_row (CcWwanDevicePage *self,
-                                  CcListRow        *data_row)
-{
-  gboolean active;
-
-  /* The user dismissed the dialog for selecting default APN */
-  if (cc_wwan_data_get_default_apn (self->wwan_data) == NULL)
-    {
-      self->is_self_change = TRUE;
-      gtk_widget_activate (GTK_WIDGET (data_row));
-
-      return;
-    }
-
-  active = cc_list_row_get_active (data_row);
-
-  if (data_row == self->data_enable_row)
-    cc_wwan_data_set_enabled (self->wwan_data, active);
-  else
-    cc_wwan_data_set_roaming_enabled (self->wwan_data, active);
-
-  cc_wwan_data_save_settings (self->wwan_data, NULL, NULL, NULL);
-}
-
-static gboolean
-wwan_apn_dialog_closed_cb (CcWwanDevicePage *self)
-{
-  CcListRow *data_row;
-
-  if (gtk_widget_in_destruction (GTK_WIDGET (self)))
-    return FALSE;
-
-  data_row = g_object_get_data (G_OBJECT (self->apn_dialog), "row");
-  g_object_set_data (G_OBJECT (self->apn_dialog), "row", NULL);
-
-  if (data_row)
-    wwan_device_page_handle_data_row (self, data_row);
-
-  return FALSE;
-}
-
-static void
-wwan_data_show_apn_dialog (CcWwanDevicePage *self)
-{
-  GtkWindow *top_level;
-
-  top_level = GTK_WINDOW (gtk_widget_get_toplevel (GTK_WIDGET (self)));
-
-  if (!self->apn_dialog)
-    {
-      self->apn_dialog = cc_wwan_apn_dialog_new (top_level, self->device);
-      g_signal_connect_object (self->apn_dialog, "unmap",
-                               G_CALLBACK (wwan_apn_dialog_closed_cb),
-                               self, G_CONNECT_SWAPPED);
-    }
-
-  gtk_widget_show (GTK_WIDGET (self->apn_dialog));
-}
-
-static GcrPrompt *
-cc_wwan_device_page_new_prompt (CcWwanDevicePage *self,
-                                MMModemLock       lock)
-{
-  GcrPrompt *prompt;
-  g_autoptr(GError) error = NULL;
-  g_autofree gchar *description = NULL;
-  g_autofree gchar *warning = NULL;
-  const gchar *message = NULL;
-  guint num;
-
-  prompt = GCR_PROMPT (gcr_system_prompt_open (-1, NULL, &error));
-
-  if (error)
-    {
-      g_warning ("Error opening Prompt: %s", error->message);
-      return NULL;
-    }
-
-  gcr_prompt_set_title (prompt, _("Unlock SIM card"));
-  gcr_prompt_set_continue_label (prompt, _("Unlock"));
-  gcr_prompt_set_cancel_label (prompt, _("Cancel"));
-
-  if (lock == MM_MODEM_LOCK_SIM_PIN)
-    {
-      description = g_strdup_printf (_("Please provide PIN code for SIM %d"), self->sim_index);
-      message = _("Enter PIN to unlock your SIM card");
-    }
-  else if (lock == MM_MODEM_LOCK_SIM_PUK)
-    {
-      description = g_strdup_printf (_("Please provide PUK code for SIM %d"), self->sim_index);
-      message = _("Enter PUK to unlock your SIM card");
-    }
-  else
-    {
-      g_warn_if_reached ();
-      g_object_unref (prompt);
-
-      return NULL;
-    }
-
-  gcr_prompt_set_description (prompt, description);
-  gcr_prompt_set_message (prompt, message);
-
-  num = cc_wwan_device_get_unlock_retries (self->device, lock);
-
-  if (num != MM_UNLOCK_RETRIES_UNKNOWN)
-    {
-      if (self->is_retry)
-        warning = g_strdup_printf (ngettext ("Wrong password entered. You have %1$u try left",
-                                             "Wrong password entered. You have %1$u tries left", num), num);
-      else
-        warning = g_strdup_printf (ngettext ("You have %u try left",
-                                             "You have %u tries left", num), num);
-    }
-  else if (self->is_retry)
-    {
-      warning = g_strdup (_("Wrong password entered."));
-    }
-
-  gcr_prompt_set_warning (prompt, warning);
-
-  return prompt;
-}
-
-static void
-wwan_update_unlock_button (CcWwanDevicePage *self)
-{
-  gtk_button_set_label (self->unlock_button, _("Unlock"));
-  gtk_widget_set_sensitive (GTK_WIDGET (self->unlock_button), TRUE);
-}
-
-static void
-cc_wwan_device_page_unlocked_cb (GObject      *object,
-                                 GAsyncResult *result,
-                                 gpointer      user_data)
-{
-  CcWwanDevicePage *self = user_data;
-  wwan_update_unlock_button (self);
-}
-
-static void
-wwan_device_unlock_clicked_cb (CcWwanDevicePage *self)
-{
-  g_autoptr(GError) error = NULL;
-  GcrPrompt *prompt;
-  const gchar *password, *warning;
-  const gchar *pin = "";
-  const gchar *puk = "";
-  MMModemLock lock;
-
-  lock = cc_wwan_device_get_lock (self->device);
-  password = "";
-
-  if (lock != MM_MODEM_LOCK_SIM_PIN &&
-      lock != MM_MODEM_LOCK_SIM_PUK)
-    g_return_if_reached ();
-
-  if (lock == MM_MODEM_LOCK_SIM_PUK)
-    {
-      prompt = cc_wwan_device_page_new_prompt (self, lock);
-
-      warning = _("PUK code should be an 8 digit number");
-      while (password && !cc_wwan_device_pin_valid (password, lock))
-        {
-          password = gcr_prompt_password (prompt, NULL, &error);
-          gcr_prompt_set_warning (prompt, warning);
-        }
-
-      puk = g_strdup (password);
-      password = "";
-      gcr_prompt_close (prompt);
-      g_object_unref (prompt);
-
-      if (error)
-        g_warning ("Error: %s", error->message);
-
-      /* Error or User cancelled PUK */
-      if (!puk)
-        return;
-    }
-
-  prompt = cc_wwan_device_page_new_prompt (self, MM_MODEM_LOCK_SIM_PIN);
-  if (lock == MM_MODEM_LOCK_SIM_PUK)
-    {
-      gcr_prompt_set_password_new (prompt, TRUE);
-      gcr_prompt_set_message (prompt, _("Enter New PIN"));
-      gcr_prompt_set_warning (prompt, "");
-    }
-
-  warning = _("PIN code should be a 4-8 digit number");
-  while (password && !cc_wwan_device_pin_valid (password, MM_MODEM_LOCK_SIM_PIN))
-    {
-      password = gcr_prompt_password (prompt, NULL, &error);
-      gcr_prompt_set_warning (prompt, warning);
-    }
-
-  pin = g_strdup (password);
-  gcr_prompt_close (prompt);
-  g_object_unref (prompt);
-
-  if (error)
-    g_warning ("Error: %s", error->message);
-
-  /* Error or User cancelled PIN */
-  if (!pin)
-    return;
-
-  gtk_button_set_label (self->unlock_button, _("Unlocking..."));
-  gtk_widget_set_sensitive (GTK_WIDGET (self->unlock_button), FALSE);
-
-  if (lock == MM_MODEM_LOCK_SIM_PIN)
-    cc_wwan_device_send_pin (self->device, pin,
-                             NULL, /* cancellable */
-                             cc_wwan_device_page_unlocked_cb,
-                             self);
-  else if (lock == MM_MODEM_LOCK_SIM_PUK)
-    {
-      cc_wwan_device_send_puk (self->device, puk, pin,
-                               NULL, /* Cancellable */
-                               cc_wwan_device_page_unlocked_cb,
-                               self);
-    }
-  else
-    {
-      g_warn_if_reached ();
-    }
-}
-
-static void
-wwan_data_settings_changed_cb (CcWwanDevicePage *self,
-                               GParamSpec       *pspec,
-                               CcListRow        *data_row)
-{
-  if (self->is_self_change)
-    {
-      self->is_self_change = FALSE;
-      return;
-    }
-
-  if (cc_wwan_data_get_default_apn (self->wwan_data) == NULL)
-    {
-      wwan_data_show_apn_dialog (self);
-      g_object_set_data (G_OBJECT (self->apn_dialog), "row", data_row);
-    }
-  else
-    {
-      wwan_device_page_handle_data_row (self, data_row);
-    }
-}
-
-static void
-wwan_network_settings_activated_cb (CcWwanDevicePage *self,
-                                    CcListRow        *row)
-{
-  GtkWidget *dialog;
-  GtkWindow *top_level;
-
-  top_level = GTK_WINDOW (gtk_widget_get_toplevel (GTK_WIDGET (self)));
-
-  if (row == self->network_mode_row)
-    {
-      if (!self->network_mode_dialog)
-        self->network_mode_dialog = cc_wwan_mode_dialog_new (top_level, self->device);
-
-      dialog = GTK_WIDGET (self->network_mode_dialog);
-    }
-  else if (row == self->network_name_row)
-    {
-      if (!self->network_dialog)
-        self->network_dialog = cc_wwan_network_dialog_new (top_level, self->device);
-
-      dialog = GTK_WIDGET (self->network_dialog);
-    }
-  else
-    {
-      return;
-    }
-
-  gtk_widget_show (dialog);
-}
-
-static void
-wwan_advanced_settings_activated_cb (CcWwanDevicePage *self,
-                                     CcListRow        *row)
-{
-  GtkWindow *top_level;
-
-  top_level = GTK_WINDOW (gtk_widget_get_toplevel (GTK_WIDGET (self)));
-
-  if (row == self->sim_lock_row)
-    {
-      if (!self->sim_lock_dialog)
-        self->sim_lock_dialog = cc_wwan_sim_lock_dialog_new (top_level, self->device);
-      gtk_widget_show (GTK_WIDGET (self->sim_lock_dialog));
-    }
-  else if (row == self->details_row)
-    {
-      if (!self->details_dialog)
-        self->details_dialog = cc_wwan_details_dialog_new (top_level, self->device);
-      gtk_widget_show (GTK_WIDGET (self->details_dialog));
-    }
-  else if (row == self->apn_settings_row)
-    {
-      wwan_data_show_apn_dialog (self);
-    }
-  else
-    {
-      g_return_if_reached ();
-    }
-}
-
-static void
-cc_wwan_device_page_update_data (CcWwanDevicePage *self)
-{
-  gboolean has_data;
-
-  if (self->wwan_data == cc_wwan_device_get_data (self->device))
-    return;
-
-  self->wwan_data = cc_wwan_device_get_data (self->device);
-  has_data = self->wwan_data != NULL;
-
-  gtk_widget_set_sensitive (GTK_WIDGET (self->data_settings_list), has_data);
-  gtk_widget_set_sensitive (GTK_WIDGET (self->apn_settings_row), has_data);
-
-  if (!has_data)
-    return;
-
-  g_signal_handlers_block_by_func (self->data_roaming_row,
-                                   wwan_data_settings_changed_cb, self);
-  g_signal_handlers_block_by_func (self->data_enable_row,
-                                   wwan_data_settings_changed_cb, self);
-
-  g_object_set (self->data_roaming_row, "active",
-                cc_wwan_data_get_roaming_enabled (self->wwan_data), NULL);
-
-  g_object_set (self->data_enable_row, "active",
-                cc_wwan_data_get_enabled (self->wwan_data), NULL);
-
-  g_signal_handlers_unblock_by_func (self->data_roaming_row,
-                                     wwan_data_settings_changed_cb, self);
-  g_signal_handlers_unblock_by_func (self->data_enable_row,
-                                     wwan_data_settings_changed_cb, self);
-}
-
-static void
-cc_wwan_device_page_update (CcWwanDevicePage *self)
-{
-  GtkStack *main_stack;
-  MMModemLock lock;
-
-  main_stack = self->main_stack;
-  if (!cc_wwan_device_has_sim (self->device))
-    gtk_stack_set_visible_child_name (main_stack, "no-sim-view");
-  else if ((lock = cc_wwan_device_get_lock (self->device)) == MM_MODEM_LOCK_SIM_PIN ||
-           lock == MM_MODEM_LOCK_SIM_PUK)
-    gtk_stack_set_visible_child_name (main_stack, "sim-lock-view");
-  else
-    gtk_stack_set_visible_child_name (main_stack, "settings-view");
-}
-
-static void
-cc_wwan_locks_changed_cb (CcWwanDevicePage *self)
-{
-  const gchar *label;
-
-  if (cc_wwan_device_get_sim_lock (self->device))
-    label = _("Enabled");
-  else
-    label = _("Disabled");
-
-  cc_list_row_set_secondary_label (self->sim_lock_row, label);
-  cc_wwan_device_page_update (self);
-}
-
-static void
-cc_wwan_device_page_set_property (GObject      *object,
-                                  guint         prop_id,
-                                  const GValue *value,
-                                  GParamSpec   *pspec)
-{
-  CcWwanDevicePage *self = (CcWwanDevicePage *)object;
-
-  switch (prop_id)
-    {
-    case PROP_DEVICE:
-      self->device = g_value_dup_object (value);
-      break;
-
-    default:
-      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
-    }
-}
-
-static void
-cc_wwan_device_page_constructed (GObject *object)
-{
-  CcWwanDevicePage *self = (CcWwanDevicePage *)object;
-
-  G_OBJECT_CLASS (cc_wwan_device_page_parent_class)->constructed (object);
-
-  cc_wwan_device_page_update_data (self);
-
-  g_object_bind_property (self->device, "operator-name",
-                          self->network_name_row, "secondary-label",
-                          G_BINDING_DEFAULT | G_BINDING_SYNC_CREATE);
-
-  g_object_bind_property (self->device, "network-mode",
-                          self->network_mode_row, "secondary-label",
-                          G_BINDING_DEFAULT | G_BINDING_SYNC_CREATE);
-
-  g_signal_connect_object (self->device, "notify::enabled-locks",
-                           (GCallback)cc_wwan_locks_changed_cb,
-                           self, G_CONNECT_SWAPPED);
-
-  g_signal_connect_object (self->device, "notify::has-data",
-                           (GCallback)cc_wwan_device_page_update_data,
-                           self, G_CONNECT_SWAPPED);
-
-  cc_wwan_device_page_update (self);
-  cc_wwan_locks_changed_cb (self);
-}
-
-static void
-cc_wwan_device_page_dispose (GObject *object)
-{
-  CcWwanDevicePage *self = (CcWwanDevicePage *)object;
-
-  g_clear_pointer ((GtkWidget **)&self->apn_dialog, gtk_widget_destroy);
-  g_clear_pointer ((GtkWidget **)&self->details_dialog, gtk_widget_destroy);
-  g_clear_pointer ((GtkWidget **)&self->network_mode_dialog, gtk_widget_destroy);
-  g_clear_pointer ((GtkWidget **)&self->network_dialog, gtk_widget_destroy);
-  g_clear_pointer ((GtkWidget **)&self->sim_lock_dialog, gtk_widget_destroy);
-
-  g_clear_object (&self->wwan_proxy);
-  g_clear_object (&self->device);
-
-  G_OBJECT_CLASS (cc_wwan_device_page_parent_class)->dispose (object);
-}
-
-static void
-cc_wwan_device_page_class_init (CcWwanDevicePageClass *klass)
-{
-  GtkWidgetClass *widget_class = GTK_WIDGET_CLASS (klass);
-  GObjectClass *object_class = G_OBJECT_CLASS (klass);
-
-  object_class->set_property = cc_wwan_device_page_set_property;
-  object_class->constructed  = cc_wwan_device_page_constructed;
-  object_class->dispose = cc_wwan_device_page_dispose;
-
-  g_type_ensure (CC_TYPE_WWAN_DEVICE);
-
-  properties[PROP_DEVICE] =
-    g_param_spec_object ("device",
-                         "Device",
-                         "The WWAN Device",
-                         CC_TYPE_WWAN_DEVICE,
-                         G_PARAM_WRITABLE | G_PARAM_STATIC_STRINGS | G_PARAM_CONSTRUCT_ONLY);
-
-  g_object_class_install_properties (object_class, N_PROPS, properties);
-
-  gtk_widget_class_set_template_from_resource (widget_class,
-                                               "/org/gnome/control-center/wwan/cc-wwan-device-page.ui");
-
-  gtk_widget_class_bind_template_child (widget_class, CcWwanDevicePage, advanced_settings_list);
-  gtk_widget_class_bind_template_child (widget_class, CcWwanDevicePage, apn_settings_row);
-  gtk_widget_class_bind_template_child (widget_class, CcWwanDevicePage, data_enable_row);
-  gtk_widget_class_bind_template_child (widget_class, CcWwanDevicePage, data_roaming_row);
-  gtk_widget_class_bind_template_child (widget_class, CcWwanDevicePage, data_settings_list);
-  gtk_widget_class_bind_template_child (widget_class, CcWwanDevicePage, details_row);
-  gtk_widget_class_bind_template_child (widget_class, CcWwanDevicePage, main_stack);
-  gtk_widget_class_bind_template_child (widget_class, CcWwanDevicePage, network_mode_row);
-  gtk_widget_class_bind_template_child (widget_class, CcWwanDevicePage, network_name_row);
-  gtk_widget_class_bind_template_child (widget_class, CcWwanDevicePage, network_settings_list);
-  gtk_widget_class_bind_template_child (widget_class, CcWwanDevicePage, sim_lock_row);
-  gtk_widget_class_bind_template_child (widget_class, CcWwanDevicePage, unlock_button);
-
-  gtk_widget_class_bind_template_callback (widget_class, wwan_device_unlock_clicked_cb);
-  gtk_widget_class_bind_template_callback (widget_class, wwan_data_settings_changed_cb);
-  gtk_widget_class_bind_template_callback (widget_class, wwan_network_settings_activated_cb);
-  gtk_widget_class_bind_template_callback (widget_class, wwan_advanced_settings_activated_cb);
-}
-
-static void
-cc_wwan_device_page_init (CcWwanDevicePage *self)
-{
-  gtk_widget_init_template (GTK_WIDGET (self));
-
-  gtk_list_box_set_header_func (self->data_settings_list,
-                                cc_list_box_update_header_func,
-                                NULL, NULL);
-
-  gtk_list_box_set_header_func (self->network_settings_list,
-                                cc_list_box_update_header_func,
-                                NULL, NULL);
-
-  gtk_list_box_set_header_func (self->advanced_settings_list,
-                                cc_list_box_update_header_func,
-                                NULL, NULL);
-}
-
-static void
-cc_wwan_error_changed_cb (CcWwanDevicePage *self)
-{
-  const gchar *message;
-
-  message = cc_wwan_device_get_simple_error (self->device);
-
-  if (!message)
-    return;
-
-  /*
-   * The label is first set to empty, which will result in
-   * the revealer to be closed.  Then the real label is
-   * set.  This will animate the revealer which can bring
-   * the user's attention.
-   */
-  gtk_label_set_label (self->notification_label, "");
-  gtk_label_set_label (self->notification_label, message);
-}
-
-CcWwanDevicePage *
-cc_wwan_device_page_new (CcWwanDevice *device,
-                         GtkWidget    *notification_label)
-{
-  CcWwanDevicePage *self;
-
-  g_return_val_if_fail (CC_IS_WWAN_DEVICE (device), NULL);
-
-  self = g_object_new (CC_TYPE_WWAN_DEVICE_PAGE,
-                       "device", device,
-                       NULL);
-
-  self->notification_label = GTK_LABEL (notification_label);
-
-  g_signal_connect_object (self->device, "notify::error",
-                           G_CALLBACK (cc_wwan_error_changed_cb),
-                           self, G_CONNECT_SWAPPED);
-
-  return self;
-}
-
-CcWwanDevice *
-cc_wwan_device_page_get_device (CcWwanDevicePage *self)
-{
-  g_return_val_if_fail (CC_IS_WWAN_DEVICE_PAGE (self), NULL);
-
-  return self->device;
-}
-
-void
-cc_wwan_device_page_set_sim_index (CcWwanDevicePage *self,
-                                   gint              sim_index)
-{
-  g_return_if_fail (CC_IS_WWAN_DEVICE_PAGE (self));
-  g_return_if_fail (sim_index >= 1);
-
-  self->sim_index = sim_index;
-}
diff --git a/panels/wwan/cc-wwan-device-page.h b/panels/wwan/cc-wwan-device-page.h
deleted file mode 100644
index 923346a..0000000
--- a/panels/wwan/cc-wwan-device-page.h
+++ /dev/null
@@ -1,42 +0,0 @@
-/* -*- Mode: C; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* cc-wwan-device-page.h
- *
- * Copyright 2019 Purism SPC
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- *
- * Author(s):
- *   Mohammed Sadiq <sadiq@sadiqpk.org>
- *
- * SPDX-License-Identifier: GPL-3.0-or-later
- */
-
-#pragma once
-
-#include <shell/cc-panel.h>
-
-#include "cc-wwan-device.h"
-
-G_BEGIN_DECLS
-
-#define CC_TYPE_WWAN_DEVICE_PAGE (cc_wwan_device_page_get_type())
-G_DECLARE_FINAL_TYPE (CcWwanDevicePage, cc_wwan_device_page, CC, WWAN_DEVICE_PAGE, GtkBox)
-
-CcWwanDevicePage *cc_wwan_device_page_new           (CcWwanDevice     *device,
-                                                     GtkWidget        *notification_label);
-CcWwanDevice     *cc_wwan_device_page_get_device    (CcWwanDevicePage *self);
-void              cc_wwan_device_page_set_sim_index (CcWwanDevicePage *self,
-                                                     gint              sim_index);
-
-G_END_DECLS
diff --git a/panels/wwan/cc-wwan-device-page.ui b/panels/wwan/cc-wwan-device-page.ui
deleted file mode 100644
index f77bd70..0000000
--- a/panels/wwan/cc-wwan-device-page.ui
+++ /dev/null
@@ -1,270 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<interface>
-  <template class="CcWwanDevicePage" parent="GtkBox">
-    <property name="visible">1</property>
-    <child>
-      <object class="GtkStack" id="main_stack">
-        <property name="visible">1</property>
-        <property name="homogeneous">0</property>
-
-        <!-- SIM not inserted view -->
-        <child>
-          <object class="GtkBox">
-            <property name="visible">1</property>
-            <property name="expand">1</property>
-            <property name="halign">center</property>
-            <property name="valign">center</property>
-            <property name="orientation">vertical</property>
-            <property name="margin-bottom">64</property>
-            <child>
-              <object class="GtkImage">
-                <property name="visible">1</property>
-                <property name="icon-name">auth-sim-missing</property>
-                <property name="pixel-size">192</property>
-                <property name="margin-bottom">18</property>
-                <style>
-                  <class name="dim-label" />
-                </style>
-              </object>
-            </child>
-            <child>
-              <object class="GtkLabel">
-                <property name="visible">1</property>
-                <property name="wrap">1</property>
-                <property name="label" translatable="yes">No SIM</property>
-                <attributes>
-                  <attribute name="weight" value="bold" />
-                  <attribute name="scale" value="1.2" />
-                </attributes>
-              </object>
-            </child>
-            <child>
-              <object class="GtkLabel">
-                <property name="visible">1</property>
-                <property name="wrap">1</property>
-                <property name="label" translatable="yes">Insert a SIM card to use this modem</property>
-              </object>
-            </child>
-          </object>
-          <packing>
-            <property name="name">no-sim-view</property>
-          </packing>
-        </child>
-
-        <!-- SIM locked view -->
-        <child>
-          <object class="GtkBox">
-            <property name="visible">1</property>
-            <property name="expand">1</property>
-            <property name="halign">center</property>
-            <property name="valign">center</property>
-            <property name="orientation">vertical</property>
-            <property name="margin-bottom">64</property>
-            <child>
-              <object class="GtkImage">
-                <property name="visible">1</property>
-                <property name="icon-name">auth-sim-locked</property>
-                <property name="pixel-size">192</property>
-                <property name="margin-bottom">18</property>
-                <style>
-                 <class name="dim-label" />
-                </style>
-              </object>
-            </child>
-            <child>
-              <object class="GtkLabel">
-                <property name="visible">1</property>
-                <property name="wrap">1</property>
-                <property name="label" translatable="yes">SIM Locked</property>
-                <property name="margin-bottom">32</property>
-                <attributes>
-                  <attribute name="weight" value="bold" />
-                  <attribute name="scale" value="1.2" />
-                </attributes>
-              </object>
-            </child>
-            <child>
-              <object class="GtkButton" id="unlock_button">
-                <property name="visible">1</property>
-                <property name="use-underline">1</property>
-                <property name="label" translatable="yes">_Unlock</property>
-                <signal name="clicked" handler="wwan_device_unlock_clicked_cb" swapped="yes" />
-                <style>
-                  <class name="suggested-action" />
-                </style>
-              </object>
-            </child>
-          </object>
-          <packing>
-            <property name="name">sim-lock-view</property>
-          </packing>
-        </child> <!--  -->
-
-        <!-- Network Settings -->
-        <child>
-          <object class="GtkBox">
-            <property name="visible">1</property>
-            <property name="margin-top">18</property>
-            <property name="orientation">vertical</property>
-
-            <!-- Network Settings Title -->
-            <child>
-              <object class="GtkLabel">
-                <property name="visible">1</property>
-                <property name="label" translatable="yes">Network</property>
-                <property name="xalign">0.0</property>
-                <property name="margin-bottom">12</property>
-                <attributes>
-                  <attribute name="weight" value="bold"/>
-                </attributes>
-              </object>
-            </child>
-
-            <!-- Internet settings -->
-            <child>
-              <object class="GtkListBox" id="data_settings_list">
-                <property name="visible">1</property>
-                <property name="margin-bottom">32</property>
-                <property name="selection-mode">none</property>
-                <style>
-                 <class name="frame" />
-                </style>
-
-                <!-- Enable/Disable Data -->
-                <child>
-                  <object class="CcListRow" id="data_enable_row">
-                    <property name="visible">1</property>
-                    <property name="use-underline">1</property>
-                    <property name="show-switch">1</property>
-                    <property name="title" translatable="yes">_Mobile Data</property>
-                    <property name="subtitle" translatable="yes">Access data using mobile network</property>
-                    <signal name="notify::active" handler="wwan_data_settings_changed_cb" swapped="yes" />
-                  </object>
-                </child>
-
-                <!-- Data Roaming -->
-                <child>
-                  <object class="CcListRow" id="data_roaming_row">
-                    <property name="visible">1</property>
-                    <property name="use-underline">1</property>
-                    <property name="show-switch">1</property>
-                    <property name="title" translatable="yes">_Data Roaming</property>
-                    <property name="subtitle" translatable="yes">Use mobile data when roaming</property>
-                    <signal name="notify::active" handler="wwan_data_settings_changed_cb" swapped="yes" />
-                  </object>
-                </child>
-
-              </object>
-            </child>
-
-            <!-- Network Settings -->
-            <child>
-              <object class="GtkListBox" id="network_settings_list" >
-                <property name="visible">1</property>
-                <property name="margin-bottom">32</property>
-                <property name="selection-mode">none</property>
-                <style>
-                  <class name="frame" />
-                </style>
-                <signal name="row-activated" handler="wwan_network_settings_activated_cb" swapped="yes" />
-
-                <!-- Network Mode -->
-                <child>
-                  <object class="CcListRow" id="network_mode_row">
-                    <property name="visible">1</property>
-                    <property name="use-underline">1</property>
-                    <property name="icon-name">go-next-symbolic</property>
-                    <property name="title" translatable="yes">_Network Mode</property>
-                  </object>
-                </child>
-
-                <!-- Network -->
-                <child>
-                  <object class="CcListRow" id="network_name_row">
-                    <property name="visible">1</property>
-                    <property name="use-underline">1</property>
-                    <property name="icon-name">go-next-symbolic</property>
-                    <property name="title" translatable="yes">N_etwork</property>
-                  </object>
-                </child>
-
-              </object>
-            </child>
-
-
-            <!-- Advanced Settings Title -->
-            <child>
-              <object class="GtkLabel">
-                <property name="visible">1</property>
-                <property name="label" translatable="yes">Advanced</property>
-                <property name="xalign">0.0</property>
-                <property name="margin-bottom">12</property>
-                <attributes>
-                  <attribute name="weight" value="bold"/>
-                </attributes>
-              </object>
-            </child>
-
-            <!-- Advanced settings -->
-            <child>
-              <object class="GtkListBox" id="advanced_settings_list" >
-                <property name="visible">1</property>
-                <property name="margin-bottom">32</property>
-                <property name="selection-mode">none</property>
-                <style>
-                  <class name="frame" />
-                </style>
-                <signal name="row-activated" handler="wwan_advanced_settings_activated_cb" swapped="yes" />
-
-                <!-- Accesss Point Settings -->
-                <child>
-                  <object class="CcListRow" id="apn_settings_row">
-                    <property name="visible">1</property>
-                    <property name="use-underline">1</property>
-                    <property name="icon-name">go-next-symbolic</property>
-                    <property name="title" translatable="yes">_Access Point Names</property>
-                  </object>
-                </child>
-
-                <!-- SIM Lock -->
-                <child>
-                  <object class="CcListRow" id="sim_lock_row">
-                    <property name="visible">1</property>
-                    <property name="use-underline">1</property>
-                    <property name="icon-name">go-next-symbolic</property>
-                    <property name="title" translatable="yes">_SIM Lock</property>
-                    <property name="subtitle" translatable="yes">Lock SIM with PIN</property>
-                  </object>
-                </child>
-
-                <!-- Modem Details -->
-                <child>
-                  <object class="CcListRow" id="details_row">
-                    <property name="visible">1</property>
-                    <property name="use-underline">1</property>
-                    <property name="icon-name">go-next-symbolic</property>
-                    <property name="title" translatable="yes">M_odem Details</property>
-                  </object>
-                </child>
-
-              </object>
-            </child>
-
-          </object>
-          <packing>
-            <property name="name">settings-view</property>
-          </packing>
-        </child>
-
-      </object> <!-- ./GtkStack main_stack -->
-    </child>
-  </template>
-  <object class="GtkSizeGroup">
-    <property name="mode">both</property>
-    <widgets>
-      <widget name="apn_settings_row"/>
-      <widget name="sim_lock_row"/>
-      <widget name="details_row"/>
-    </widgets>
-  </object>
-</interface>
diff --git a/panels/wwan/cc-wwan-device.c b/panels/wwan/cc-wwan-device.c
deleted file mode 100644
index f6c7382..0000000
--- a/panels/wwan/cc-wwan-device.c
+++ /dev/null
@@ -1,1391 +0,0 @@
-/* -*- Mode: C; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* cc-wwan-device.c
- *
- * Copyright 2019-2020 Purism SPC
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- *
- * Author(s):
- *   Mohammed Sadiq <sadiq@sadiqpk.org>
- *
- * SPDX-License-Identifier: GPL-3.0-or-later
- */
-
-#undef G_LOG_DOMAIN
-#define G_LOG_DOMAIN "cc-wwan-device"
-
-#ifdef HAVE_CONFIG_H
-# include "config.h"
-#endif
-
-#include <glib/gi18n.h>
-#include <polkit/polkit.h>
-#if defined(HAVE_NETWORK_MANAGER) && defined(BUILD_NETWORK)
-# include <NetworkManager.h>
-# include <nma-mobile-providers.h>
-#endif
-
-#include "cc-wwan-errors-private.h"
-#include "cc-wwan-device.h"
-
-/**
- * @short_description: Device Object
- * @include: "cc-wwan-device.h"
- */
-
-struct _CcWwanDevice
-{
-  GObject      parent_instance;
-
-  MMObject    *mm_object;
-  MMModem     *modem;
-  MMSim       *sim;
-  MMModem3gpp *modem_3gpp;
-
-  const char  *operator_code; /* MCCMNC */
-  GError      *error;
-
-  /* Building with NetworkManager is optional,
-   * so #NMclient type can’t be used here.
-   */
-  GObject      *nm_client; /* An #NMClient */
-  CcWwanData   *wwan_data;
-
-  gulong      modem_3gpp_id;
-  gulong      modem_3gpp_locks_id;
-
-  /* Enabled locks like PIN, PIN2, PUK, etc. */
-  MMModem3gppFacility locks;
-
-  CcWwanState  registration_state;
-  gboolean     network_is_manual;
-};
-
-G_DEFINE_TYPE (CcWwanDevice, cc_wwan_device, G_TYPE_OBJECT)
-
-
-enum {
-  PROP_0,
-  PROP_OPERATOR_NAME,
-  PROP_ENABLED_LOCKS,
-  PROP_ERROR,
-  PROP_HAS_DATA,
-  PROP_NETWORK_MODE,
-  PROP_REGISTRATION_STATE,
-  PROP_SIGNAL,
-  PROP_UNLOCK_REQUIRED,
-  N_PROPS
-};
-
-static GParamSpec *properties[N_PROPS];
-
-static void
-cc_wwan_device_state_changed_cb (CcWwanDevice *self)
-{
-  MMModem3gppRegistrationState state;
-
-  g_object_notify_by_pspec (G_OBJECT (self), properties[PROP_OPERATOR_NAME]);
-
-  state = mm_modem_3gpp_get_registration_state (self->modem_3gpp);
-
-  switch (state)
-    {
-    case MM_MODEM_3GPP_REGISTRATION_STATE_UNKNOWN:
-      self->registration_state = CC_WWAN_REGISTRATION_STATE_UNKNOWN;
-      break;
-
-    case MM_MODEM_3GPP_REGISTRATION_STATE_DENIED:
-      self->registration_state = CC_WWAN_REGISTRATION_STATE_DENIED;
-      break;
-
-    case MM_MODEM_3GPP_REGISTRATION_STATE_IDLE:
-      self->registration_state = CC_WWAN_REGISTRATION_STATE_IDLE;
-      break;
-
-    case MM_MODEM_3GPP_REGISTRATION_STATE_SEARCHING:
-      self->registration_state = CC_WWAN_REGISTRATION_STATE_SEARCHING;
-      break;
-
-    case MM_MODEM_3GPP_REGISTRATION_STATE_ROAMING:
-      self->registration_state = CC_WWAN_REGISTRATION_STATE_ROAMING;
-      break;
-
-    default:
-      self->registration_state = CC_WWAN_REGISTRATION_STATE_REGISTERED;
-      break;
-    }
-
-  g_object_notify_by_pspec (G_OBJECT (self), properties[PROP_REGISTRATION_STATE]);
-}
-
-static void
-cc_wwan_device_locks_changed_cb (CcWwanDevice *self)
-{
-  self->locks = mm_modem_3gpp_get_enabled_facility_locks (self->modem_3gpp);
-
-  g_object_notify_by_pspec (G_OBJECT (self), properties[PROP_ENABLED_LOCKS]);
-}
-
-static void
-cc_wwan_device_3gpp_changed_cb (CcWwanDevice *self)
-{
-  gulong handler_id = 0;
-
-  if (self->modem_3gpp_id)
-    g_signal_handler_disconnect (self->modem_3gpp, self->modem_3gpp_id);
-  self->modem_3gpp_id = 0;
-
-  if (self->modem_3gpp_locks_id)
-    g_signal_handler_disconnect (self->modem_3gpp, self->modem_3gpp_locks_id);
-  self->modem_3gpp_locks_id = 0;
-
-  g_clear_object (&self->modem_3gpp);
-  self->modem_3gpp = mm_object_get_modem_3gpp (self->mm_object);
-
-  if (self->modem_3gpp)
-    {
-      handler_id = g_signal_connect_object (self->modem_3gpp, "notify::registration-state",
-                                            G_CALLBACK (cc_wwan_device_state_changed_cb),
-                                            self, G_CONNECT_SWAPPED);
-      self->modem_3gpp_id = handler_id;
-
-      handler_id = g_signal_connect_object (self->modem_3gpp, "notify::enabled-facility-locks",
-                                            G_CALLBACK (cc_wwan_device_locks_changed_cb),
-                                            self, G_CONNECT_SWAPPED);
-      self->modem_3gpp_locks_id = handler_id;
-      cc_wwan_device_locks_changed_cb (self);
-      cc_wwan_device_state_changed_cb (self);
-    }
-}
-
-static void
-cc_wwan_device_signal_quality_changed_cb (CcWwanDevice *self)
-{
-  g_object_notify_by_pspec (G_OBJECT (self), properties[PROP_SIGNAL]);
-}
-
-static void
-cc_wwan_device_mode_changed_cb (CcWwanDevice *self)
-{
-  g_object_notify_by_pspec (G_OBJECT (self), properties[PROP_NETWORK_MODE]);
-}
-
-static void
-wwan_device_emit_data_changed (CcWwanDevice *self)
-{
-  g_object_notify_by_pspec (G_OBJECT (self), properties[PROP_HAS_DATA]);
-}
-
-static void
-cc_wwan_device_unlock_required_cb (CcWwanDevice *self)
-{
-  g_object_notify_by_pspec (G_OBJECT (self), properties[PROP_UNLOCK_REQUIRED]);
-}
-
-#if defined(HAVE_NETWORK_MANAGER) && defined(BUILD_NETWORK)
-static void
-cc_wwan_device_nm_changed_cb (CcWwanDevice *self,
-                              GParamSpec   *pspec,
-                              NMClient     *client)
-{
-  gboolean nm_is_running;
-
-  nm_is_running = nm_client_get_nm_running (client);
-
-  if (!nm_is_running && self->wwan_data != NULL)
-    {
-      g_clear_object (&self->wwan_data);
-      wwan_device_emit_data_changed (self);
-    }
-}
-
-static void
-cc_wwan_device_nm_device_added_cb (CcWwanDevice *self,
-                                   NMDevice     *nm_device)
-{
-  if (!NM_IS_DEVICE_MODEM (nm_device))
-    return;
-
-  if(!self->sim || !cc_wwan_device_is_nm_device (self, G_OBJECT (nm_device)))
-    return;
-
-  self->wwan_data = cc_wwan_data_new (self->mm_object,
-                                      NM_CLIENT (self->nm_client));
-
-  if (self->wwan_data)
-    {
-      g_signal_connect_object (self->wwan_data, "notify::enabled",
-                               G_CALLBACK (wwan_device_emit_data_changed),
-                               self, G_CONNECT_SWAPPED);
-      wwan_device_emit_data_changed (self);
-    }
-}
-#endif
-
-static void
-cc_wwan_device_get_property (GObject    *object,
-                             guint       prop_id,
-                             GValue     *value,
-                             GParamSpec *pspec)
-{
-  CcWwanDevice *self = (CcWwanDevice *)object;
-  MMModemMode allowed, preferred;
-
-  switch (prop_id)
-    {
-    case PROP_OPERATOR_NAME:
-      g_value_set_string (value, cc_wwan_device_get_operator_name (self));
-      break;
-
-    case PROP_ERROR:
-      g_value_set_boolean (value, self->error != NULL);
-      break;
-
-    case PROP_HAS_DATA:
-      g_value_set_boolean (value, self->wwan_data != NULL);
-      break;
-
-    case PROP_ENABLED_LOCKS:
-      g_value_set_int (value, self->locks);
-      break;
-
-    case PROP_NETWORK_MODE:
-      if (cc_wwan_device_get_current_mode (self, &allowed, &preferred))
-        g_value_take_string (value, cc_wwan_device_get_string_from_mode (self, allowed, preferred));
-      break;
-
-    case PROP_REGISTRATION_STATE:
-      g_value_set_int (value, self->registration_state);
-      break;
-
-    case PROP_UNLOCK_REQUIRED:
-      g_value_set_int (value, cc_wwan_device_get_lock (self));
-      break;
-
-    default:
-      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
-    }
-}
-
-static void
-cc_wwan_device_dispose (GObject *object)
-{
-  CcWwanDevice *self = (CcWwanDevice *)object;
-
-  g_clear_error (&self->error);
-  g_clear_object (&self->modem);
-  g_clear_object (&self->mm_object);
-  g_clear_object (&self->sim);
-  g_clear_object (&self->modem_3gpp);
-
-  g_clear_object (&self->nm_client);
-  g_clear_object (&self->wwan_data);
-
-  G_OBJECT_CLASS (cc_wwan_device_parent_class)->dispose (object);
-}
-
-static void
-cc_wwan_device_class_init (CcWwanDeviceClass *klass)
-{
-  GObjectClass *object_class = G_OBJECT_CLASS (klass);
-
-  object_class->get_property = cc_wwan_device_get_property;
-  object_class->dispose = cc_wwan_device_dispose;
-
-  properties[PROP_OPERATOR_NAME] =
-    g_param_spec_string ("operator-name",
-                         "Operator Name",
-                         "Operator Name the device is connected to",
-                         NULL,
-                         G_PARAM_READABLE | G_PARAM_STATIC_STRINGS);
-
-  properties[PROP_ENABLED_LOCKS] =
-    g_param_spec_int ("enabled-locks",
-                      "Enabled Locks",
-                      "Locks Enabled in Modem",
-                      MM_MODEM_3GPP_FACILITY_NONE,
-                      MM_MODEM_3GPP_FACILITY_CORP_PERS,
-                      MM_MODEM_3GPP_FACILITY_NONE,
-                      G_PARAM_READABLE | G_PARAM_STATIC_STRINGS);
-
-  properties[PROP_ERROR] =
-    g_param_spec_boolean ("error",
-                          "Error",
-                          "Set if some Error occurs",
-                          FALSE,
-                          G_PARAM_READABLE | G_PARAM_STATIC_STRINGS);
-
-  properties[PROP_HAS_DATA] =
-    g_param_spec_boolean ("has-data",
-                          "has-data",
-                          "Data for the device",
-                          FALSE,
-                          G_PARAM_READABLE | G_PARAM_STATIC_STRINGS);
-
-  properties[PROP_NETWORK_MODE] =
-    g_param_spec_string ("network-mode",
-                         "Network Mode",
-                         "A String representing preferred network mode",
-                         NULL,
-                         G_PARAM_READABLE | G_PARAM_STATIC_STRINGS);
-
-  properties[PROP_REGISTRATION_STATE] =
-    g_param_spec_int ("registration-state",
-                      "Registration State",
-                      "The current network registration state",
-                      CC_WWAN_REGISTRATION_STATE_UNKNOWN,
-                      CC_WWAN_REGISTRATION_STATE_DENIED,
-                      CC_WWAN_REGISTRATION_STATE_UNKNOWN,
-                      G_PARAM_READABLE | G_PARAM_STATIC_STRINGS);
-
-  properties[PROP_UNLOCK_REQUIRED] =
-    g_param_spec_int ("unlock-required",
-                      "Unlock Required",
-                      "The Modem lock status changed",
-                      MM_MODEM_LOCK_UNKNOWN,
-                      MM_MODEM_LOCK_PH_NETSUB_PUK,
-                      MM_MODEM_LOCK_UNKNOWN,
-                      G_PARAM_READABLE | G_PARAM_STATIC_STRINGS);
-
-  properties[PROP_SIGNAL] =
-    g_param_spec_int ("signal",
-                      "Signal",
-                      "Get Device Signal",
-                      0, 100, 0,
-                      G_PARAM_READABLE | G_PARAM_STATIC_STRINGS);
-
-  g_object_class_install_properties (object_class, N_PROPS, properties);
-}
-
-static void
-cc_wwan_device_init (CcWwanDevice *self)
-{
-}
-
-/**
- * cc_wwan_device_new:
- * @mm_object: (transfer full): An #MMObject
- *
- * Create a new device representing the given
- * @mm_object.
- *
- * Returns: A #CcWwanDevice
- */
-CcWwanDevice *
-cc_wwan_device_new (MMObject *mm_object,
-                    GObject  *nm_client)
-{
-  CcWwanDevice *self;
-
-  g_return_val_if_fail (MM_IS_OBJECT (mm_object), NULL);
-#if defined(HAVE_NETWORK_MANAGER) && defined(BUILD_NETWORK)
-  g_return_val_if_fail (NM_IS_CLIENT (nm_client), NULL);
-#else
-  g_return_val_if_fail (!nm_client, NULL);
-#endif
-
-  self = g_object_new (CC_TYPE_WWAN_DEVICE, NULL);
-
-  self->mm_object = g_object_ref (mm_object);
-  self->modem = mm_object_get_modem (mm_object);
-  self->sim = mm_modem_get_sim_sync (self->modem, NULL, NULL);
-  g_set_object (&self->nm_client, nm_client);
-  if (self->sim)
-    {
-      self->operator_code = mm_sim_get_operator_identifier (self->sim);
-#if defined(HAVE_NETWORK_MANAGER) && defined(BUILD_NETWORK)
-      self->wwan_data = cc_wwan_data_new (mm_object,
-                                          NM_CLIENT (self->nm_client));
-#endif
-    }
-
-  g_signal_connect_object (self->mm_object, "notify::unlock-required",
-                           G_CALLBACK (cc_wwan_device_unlock_required_cb),
-                           self, G_CONNECT_SWAPPED);
-  if (self->wwan_data)
-    g_signal_connect_object (self->wwan_data, "notify::enabled",
-                             G_CALLBACK (wwan_device_emit_data_changed),
-                             self, G_CONNECT_SWAPPED);
-
-#if defined(HAVE_NETWORK_MANAGER) && defined(BUILD_NETWORK)
-  g_signal_connect_object (self->nm_client, "notify::nm-running" ,
-                           G_CALLBACK (cc_wwan_device_nm_changed_cb), self,
-                           G_CONNECT_SWAPPED);
-
-  g_signal_connect_object (self->nm_client, "device-added",
-                           G_CALLBACK (cc_wwan_device_nm_device_added_cb),
-                           self, G_CONNECT_SWAPPED);
-#endif
-
-  g_signal_connect_object (self->mm_object, "notify::modem3gpp",
-                           G_CALLBACK (cc_wwan_device_3gpp_changed_cb),
-                           self, G_CONNECT_SWAPPED);
-  g_signal_connect_object (self->modem, "notify::signal-quality",
-                           G_CALLBACK (cc_wwan_device_signal_quality_changed_cb),
-                           self, G_CONNECT_SWAPPED);
-
-  cc_wwan_device_3gpp_changed_cb (self);
-  g_signal_connect_object (self->modem, "notify::current-modes",
-                           G_CALLBACK (cc_wwan_device_mode_changed_cb),
-                           self, G_CONNECT_SWAPPED);
-
-  return self;
-}
-
-gboolean
-cc_wwan_device_has_sim (CcWwanDevice *self)
-{
-  MMModemStateFailedReason state_reason;
-
-  g_return_val_if_fail (CC_IS_WWAN_DEVICE (self), FALSE);
-
-  state_reason = mm_modem_get_state_failed_reason (self->modem);
-
-  if (state_reason == MM_MODEM_STATE_FAILED_REASON_SIM_MISSING)
-    return FALSE;
-
-  return TRUE;
-}
-
-/**
- * cc_wwan_device_get_lock:
- * @self: a #CcWwanDevice
- *
- * Get the active device lock that is required to
- * be unlocked for accessing device features.
- *
- * Returns: %TRUE if PIN enabled, %FALSE otherwise.
- */
-MMModemLock
-cc_wwan_device_get_lock (CcWwanDevice *self)
-{
-  g_return_val_if_fail (CC_IS_WWAN_DEVICE (self), MM_MODEM_LOCK_UNKNOWN);
-
-  return mm_modem_get_unlock_required (self->modem);
-}
-
-
-/**
- * cc_wwan_device_get_sim_lock:
- * @self: a #CcWwanDevice
- *
- * Get if SIM lock with PIN is enabled.  SIM PIN
- * enabled doesn’t mean that SIM is locked.
- * See cc_wwan_device_get_lock().
- *
- * Returns: %TRUE if PIN enabled, %FALSE otherwise.
- */
-gboolean
-cc_wwan_device_get_sim_lock (CcWwanDevice *self)
-{
-  gboolean sim_lock;
-
-  g_return_val_if_fail (CC_IS_WWAN_DEVICE (self), FALSE);
-
-  sim_lock = self->locks & MM_MODEM_3GPP_FACILITY_SIM;
-
-  return !!sim_lock;
-}
-
-guint
-cc_wwan_device_get_unlock_retries (CcWwanDevice *self,
-                                   MMModemLock   lock)
-{
-  MMUnlockRetries *retries;
-
-  g_return_val_if_fail (CC_IS_WWAN_DEVICE (self), 0);
-
-  retries = mm_modem_get_unlock_retries (self->modem);
-
-  return mm_unlock_retries_get (retries, lock);
-}
-
-static void
-cc_wwan_device_pin_sent_cb (GObject      *object,
-                            GAsyncResult *result,
-                            gpointer      user_data)
-{
-  CcWwanDevice *self;
-  MMSim *sim = (MMSim *)object;
-  g_autoptr(GTask) task = user_data;
-  g_autoptr(GError) error = NULL;
-
-  if (!mm_sim_send_pin_finish (sim, result, &error))
-    {
-      self = g_task_get_source_object (G_TASK (task));
-
-      g_clear_error (&self->error);
-      self->error = g_error_copy (error);
-      g_object_notify_by_pspec (G_OBJECT (self), properties[PROP_ERROR]);
-
-      g_task_return_error (task, g_steal_pointer (&error));
-    }
-  else
-    {
-      g_task_return_boolean (task, TRUE);
-    }
-}
-
-void
-cc_wwan_device_send_pin (CcWwanDevice        *self,
-                         const gchar         *pin,
-                         GCancellable        *cancellable,
-                         GAsyncReadyCallback  callback,
-                         gpointer             user_data)
-{
-  g_autoptr(GTask) task = NULL;
-
-  g_return_if_fail (CC_IS_WWAN_DEVICE (self));
-  g_return_if_fail (MM_IS_SIM (self->sim));
-  g_return_if_fail (!cancellable || G_IS_CANCELLABLE (cancellable));
-  g_return_if_fail (pin && *pin);
-
-  task = g_task_new (self, cancellable, callback, user_data);
-
-  mm_sim_send_pin (self->sim, pin, cancellable,
-                   cc_wwan_device_pin_sent_cb,
-                   g_steal_pointer (&task));
-}
-
-gboolean
-cc_wwan_device_send_pin_finish (CcWwanDevice  *self,
-                                GAsyncResult  *result,
-                                GError       **error)
-{
-  g_return_val_if_fail (CC_IS_WWAN_DEVICE (self), FALSE);
-  g_return_val_if_fail (G_IS_TASK (result), FALSE);
-
-  return g_task_propagate_boolean (G_TASK (result), error);
-}
-
-static void
-cc_wwan_device_puk_sent_cb (GObject      *object,
-                            GAsyncResult *result,
-                            gpointer      user_data)
-{
-  CcWwanDevice *self;
-  MMSim *sim = (MMSim *)object;
-  g_autoptr(GTask) task = user_data;
-  g_autoptr(GError) error = NULL;
-
-  if (!mm_sim_send_puk_finish (sim, result, &error))
-    {
-      self = g_task_get_source_object (G_TASK (task));
-
-      g_clear_error (&self->error);
-      self->error = g_error_copy (error);
-      g_object_notify_by_pspec (G_OBJECT (self), properties[PROP_ERROR]);
-
-      g_task_return_error (task, g_steal_pointer (&error));
-    }
-  else
-    {
-      g_task_return_boolean (task, TRUE);
-    }
-}
-
-void
-cc_wwan_device_send_puk (CcWwanDevice        *self,
-                         const gchar         *puk,
-                         const gchar         *pin,
-                         GCancellable        *cancellable,
-                         GAsyncReadyCallback  callback,
-                         gpointer             user_data)
-{
-  g_autoptr(GTask) task = NULL;
-
-  g_return_if_fail (CC_IS_WWAN_DEVICE (self));
-  g_return_if_fail (MM_IS_SIM (self->sim));
-  g_return_if_fail (!cancellable || G_IS_CANCELLABLE (cancellable));
-  g_return_if_fail (puk && *puk);
-  g_return_if_fail (pin && *pin);
-
-  task = g_task_new (self, cancellable, callback, user_data);
-
-  mm_sim_send_puk (self->sim, puk, pin, cancellable,
-                   cc_wwan_device_puk_sent_cb,
-                   g_steal_pointer (&task));
-}
-
-gboolean
-cc_wwan_device_send_puk_finish (CcWwanDevice  *self,
-                                GAsyncResult  *result,
-                                GError       **error)
-{
-  g_return_val_if_fail (CC_IS_WWAN_DEVICE (self), FALSE);
-  g_return_val_if_fail (G_IS_TASK (result), FALSE);
-
-  return g_task_propagate_boolean (G_TASK (result), error);
-}
-
-static void
-cc_wwan_device_enable_pin_cb (GObject      *object,
-                              GAsyncResult *result,
-                              gpointer      user_data)
-{
-  CcWwanDevice *self;
-  MMSim *sim = (MMSim *)object;
-  g_autoptr(GTask) task = user_data;
-  g_autoptr(GError) error = NULL;
-
-  if (!mm_sim_enable_pin_finish (sim, result, &error))
-    {
-      self = g_task_get_source_object (G_TASK (task));
-
-      g_clear_error (&self->error);
-      self->error = g_error_copy (error);
-      g_object_notify_by_pspec (G_OBJECT (self), properties[PROP_ERROR]);
-
-      g_task_return_error (task, g_steal_pointer (&error));
-    }
-  else
-    {
-      g_task_return_boolean (task, TRUE);
-    }
-}
-
-void
-cc_wwan_device_enable_pin (CcWwanDevice        *self,
-                           const gchar         *pin,
-                           GCancellable        *cancellable,
-                           GAsyncReadyCallback  callback,
-                           gpointer             user_data)
-{
-  g_autoptr(GTask) task = NULL;
-
-  g_return_if_fail (CC_IS_WWAN_DEVICE (self));
-  g_return_if_fail (!cancellable || G_IS_CANCELLABLE (cancellable));
-  g_return_if_fail (pin && *pin);
-
-  task = g_task_new (self, cancellable, callback, user_data);
-
-  mm_sim_enable_pin (self->sim, pin, cancellable,
-                     cc_wwan_device_enable_pin_cb,
-                     g_steal_pointer (&task));
-}
-
-gboolean
-cc_wwan_device_enable_pin_finish (CcWwanDevice  *self,
-                                  GAsyncResult  *result,
-                                  GError       **error)
-{
-  g_return_val_if_fail (CC_IS_WWAN_DEVICE (self), FALSE);
-  g_return_val_if_fail (G_IS_TASK (result), FALSE);
-
-  return g_task_propagate_boolean (G_TASK (result), error);
-}
-
-static void
-cc_wwan_device_disable_pin_cb (GObject      *object,
-                               GAsyncResult *result,
-                               gpointer      user_data)
-{
-  CcWwanDevice *self;
-  MMSim *sim = (MMSim *)object;
-  g_autoptr(GTask) task = user_data;
-  g_autoptr(GError) error = NULL;
-
-  if (!mm_sim_disable_pin_finish (sim, result, &error))
-    {
-      self = g_task_get_source_object (G_TASK (task));
-
-      g_clear_error (&self->error);
-      self->error = g_error_copy (error);
-      g_object_notify_by_pspec (G_OBJECT (self), properties[PROP_ERROR]);
-
-      g_task_return_error (task, g_steal_pointer (&error));
-    }
-  else
-    {
-      g_task_return_boolean (task, TRUE);
-    }
-}
-
-void
-cc_wwan_device_disable_pin (CcWwanDevice        *self,
-                            const gchar         *pin,
-                            GCancellable        *cancellable,
-                            GAsyncReadyCallback  callback,
-                            gpointer             user_data)
-{
-  g_autoptr(GTask) task = NULL;
-
-  g_return_if_fail (CC_IS_WWAN_DEVICE (self));
-  g_return_if_fail (!cancellable || G_IS_CANCELLABLE (cancellable));
-  g_return_if_fail (pin && *pin);
-
-  task = g_task_new (self, cancellable, callback, user_data);
-
-  mm_sim_disable_pin (self->sim, pin, cancellable,
-                      cc_wwan_device_disable_pin_cb,
-                      g_steal_pointer (&task));
-}
-
-gboolean
-cc_wwan_device_disable_pin_finish (CcWwanDevice *self,
-                                   GAsyncResult *result,
-                                   GError       **error)
-{
-  g_return_val_if_fail (CC_IS_WWAN_DEVICE (self), FALSE);
-  g_return_val_if_fail (G_IS_TASK (result), FALSE);
-
-  return g_task_propagate_boolean (G_TASK (result), error);
-}
-
-static void
-cc_wwan_device_change_pin_cb (GObject      *object,
-                              GAsyncResult *result,
-                              gpointer      user_data)
-{
-  CcWwanDevice *self;
-  MMSim *sim = (MMSim *)object;
-  g_autoptr(GTask) task = user_data;
-  g_autoptr(GError) error = NULL;
-
-  if (!mm_sim_change_pin_finish (sim, result, &error))
-    {
-      self = g_task_get_source_object (G_TASK (task));
-
-      g_clear_error (&self->error);
-      self->error = g_error_copy (error);
-      g_object_notify_by_pspec (G_OBJECT (self), properties[PROP_ERROR]);
-
-      g_task_return_error (task, g_steal_pointer (&error));
-    }
-  else
-    {
-      g_task_return_boolean (task, TRUE);
-    }
-}
-
-void
-cc_wwan_device_change_pin (CcWwanDevice        *self,
-                           const gchar         *old_pin,
-                           const gchar         *new_pin,
-                           GCancellable        *cancellable,
-                           GAsyncReadyCallback  callback,
-                           gpointer             user_data)
-{
-  g_autoptr(GTask) task = NULL;
-
-  g_return_if_fail (CC_IS_WWAN_DEVICE (self));
-  g_return_if_fail (!cancellable || G_IS_CANCELLABLE (cancellable));
-  g_return_if_fail (old_pin && *old_pin);
-  g_return_if_fail (new_pin && *new_pin);
-
-  task = g_task_new (self, cancellable, callback, user_data);
-
-  mm_sim_change_pin (self->sim, old_pin, new_pin, cancellable,
-                     cc_wwan_device_change_pin_cb,
-                     g_steal_pointer (&task));
-}
-
-gboolean
-cc_wwan_device_change_pin_finish (CcWwanDevice  *self,
-                                  GAsyncResult  *result,
-                                  GError       **error)
-{
-  g_return_val_if_fail (CC_IS_WWAN_DEVICE (self), FALSE);
-  g_return_val_if_fail (G_IS_TASK (result), FALSE);
-
-  return g_task_propagate_boolean (G_TASK (result), error);
-}
-
-static void
-cc_wwan_device_network_mode_set_cb (GObject      *object,
-                                    GAsyncResult *result,
-                                    gpointer      user_data)
-{
-  CcWwanDevice *self;
-  MMModem *modem = (MMModem *)object;
-  g_autoptr(GTask) task = user_data;
-  g_autoptr(GError) error = NULL;
-
-  if (!mm_modem_set_current_modes_finish (modem, result, &error))
-    {
-      self = g_task_get_source_object (G_TASK (task));
-
-      g_clear_error (&self->error);
-      self->error = g_error_copy (error);
-      g_warning ("Error: %s", error->message);
-      g_object_notify_by_pspec (G_OBJECT (self), properties[PROP_ERROR]);
-
-      g_task_return_error (task, g_steal_pointer (&error));
-    }
-  else
-    {
-      g_task_return_boolean (task, TRUE);
-    }
-}
-
-/**
- * cc_wwan_device_set_network_mode:
- * @self: a #CcWwanDevice
- * @allowed: The allowed #MMModemModes
- * @preferred: The preferred #MMModemMode
- * @cancellable: (nullable): a #GCancellable or %NULL
- * @callback: (nullable): a #GAsyncReadyCallback or %NULL
- * @user_data: (nullable): closure data for @callback
- *
- * Asynchronously set preferred network mode.
- *
- * Call @cc_wwan_device_set_current_mode_finish()
- * in @callback to get the result of operation.
- */
-void
-cc_wwan_device_set_current_mode (CcWwanDevice        *self,
-                                 MMModemMode          allowed,
-                                 MMModemMode          preferred,
-                                 GCancellable        *cancellable,
-                                 GAsyncReadyCallback  callback,
-                                 gpointer             user_data)
-{
-  g_autoptr(GTask) task = NULL;
-  GPermission *permission;
-  g_autoptr(GError) error = NULL;
-
-  g_return_if_fail (CC_IS_WWAN_DEVICE (self));
-  g_return_if_fail (!cancellable || G_IS_CANCELLABLE (cancellable));
-
-  task = g_task_new (self, cancellable, callback, user_data);
-  permission = polkit_permission_new_sync ("org.freedesktop.ModemManager1.Device.Control",
-                                           NULL, cancellable, &error);
-  if (permission)
-    g_task_set_task_data (task, permission, g_object_unref);
-
-  if (error)
-    g_warning ("error: %s", error->message);
-
-  if (error)
-    {
-      g_task_return_error (task, g_steal_pointer (&error));
-    }
-  else if (!g_permission_get_allowed (permission))
-    {
-      error = g_error_new (G_IO_ERROR,
-                           G_IO_ERROR_PERMISSION_DENIED,
-                           "Access Denied");
-      g_clear_error (&self->error);
-      self->error = g_error_copy (error);
-      g_object_notify_by_pspec (G_OBJECT (self), properties[PROP_ERROR]);
-
-      g_task_return_error (task, g_steal_pointer (&error));
-    }
-  else
-    {
-      mm_modem_set_current_modes (self->modem, allowed, preferred,
-                                  cancellable, cc_wwan_device_network_mode_set_cb,
-                                  g_steal_pointer (&task));
-    }
-}
-
-/**
- * cc_wwan_device_set_current_mode_finish:
- * @self: a #CcWwanDevice
- * @result: a #GAsyncResult
- * @error: a location for #GError or %NULL
- *
- * Get the status whether setting network mode
- * succeeded
- *
- * Returns: %TRUE if network mode was successfully set,
- * %FALSE otherwise.
- */
-gboolean
-cc_wwan_device_set_current_mode_finish (CcWwanDevice  *self,
-                                        GAsyncResult  *result,
-                                        GError       **error)
-{
-  g_return_val_if_fail (CC_IS_WWAN_DEVICE (self), FALSE);
-  g_return_val_if_fail (G_IS_TASK (result), FALSE);
-
-  return g_task_propagate_boolean (G_TASK (result), error);
-}
-
-gboolean
-cc_wwan_device_get_current_mode (CcWwanDevice *self,
-                                 MMModemMode  *allowed,
-                                 MMModemMode  *preferred)
-{
-  g_return_val_if_fail (CC_IS_WWAN_DEVICE (self), FALSE);
-
-  return mm_modem_get_current_modes (self->modem, allowed, preferred);
-}
-
-gboolean
-cc_wwan_device_is_auto_network (CcWwanDevice *self)
-{
-  /*
-   * XXX: ModemManager Doesn’t have a true API to check
-   * if registration is automatic or manual.  So Let’s
-   * do some guess work.
-   */
-  if (self->registration_state == CC_WWAN_REGISTRATION_STATE_DENIED)
-    return FALSE;
-
-  return !self->network_is_manual;
-}
-
-CcWwanState
-cc_wwan_device_get_network_state (CcWwanDevice *self)
-{
-  g_return_val_if_fail (CC_IS_WWAN_DEVICE (self), 0);
-
-  return self->registration_state;
-}
-
-gboolean
-cc_wwan_device_get_supported_modes (CcWwanDevice *self,
-                                    MMModemMode  *allowed,
-                                    MMModemMode  *preferred)
-{
-  g_autofree MMModemModeCombination *modes = NULL;
-  guint n_modes, i;
-
-  g_return_val_if_fail (CC_IS_WWAN_DEVICE (self), FALSE);
-
-  if (!mm_modem_get_supported_modes (self->modem, &modes, &n_modes))
-    return FALSE;
-
-  if (allowed)
-    *allowed = 0;
-  if (preferred)
-    *preferred = 0;
-
-  for (i = 0; i < n_modes; i++)
-    {
-      if (allowed)
-        *allowed = *allowed | modes[i].allowed;
-      if (preferred)
-        *preferred = *preferred | modes[i].preferred;
-    }
-
-  return TRUE;
-}
-
-gchar *
-cc_wwan_device_get_string_from_mode (CcWwanDevice *self,
-                                     MMModemMode   allowed,
-                                     MMModemMode   preferred)
-{
-  GString *str;
-
-  g_return_val_if_fail (CC_IS_WWAN_DEVICE (self), NULL);
-  g_return_val_if_fail (allowed != 0, NULL);
-
-  if (allowed == MM_MODEM_MODE_2G)
-    return g_strdup (_("2G Only"));
-
-  if (allowed == MM_MODEM_MODE_3G)
-    return g_strdup (_("3G Only"));
-
-  if (allowed == MM_MODEM_MODE_4G)
-    return g_strdup (_("4G Only"));
-
-  str = g_string_sized_new (10);
-
-  if (allowed & MM_MODEM_MODE_2G &&
-      allowed & MM_MODEM_MODE_3G &&
-      allowed & MM_MODEM_MODE_4G)
-    {
-      if (preferred & MM_MODEM_MODE_4G)
-        g_string_append (str, _("2G, 3G, 4G (Preferred)"));
-      else if (preferred & MM_MODEM_MODE_3G)
-        g_string_append (str, _("2G, 3G (Preferred), 4G"));
-      else if (preferred & MM_MODEM_MODE_2G)
-        g_string_append (str, _("2G (Preferred), 3G, 4G"));
-      else
-        g_string_append (str, _("2G, 3G, 4G"));
-    }
-  else if (allowed & MM_MODEM_MODE_3G &&
-           allowed & MM_MODEM_MODE_4G)
-    {
-      if (preferred & MM_MODEM_MODE_4G)
-        g_string_append (str, _("3G, 4G (Preferred)"));
-      else if (preferred & MM_MODEM_MODE_3G)
-        g_string_append (str, _("3G (Preferred), 4G"));
-      else
-        g_string_append (str, _("3G, 4G"));
-    }
-  else if (allowed & MM_MODEM_MODE_2G &&
-           allowed & MM_MODEM_MODE_4G)
-    {
-      if (preferred & MM_MODEM_MODE_4G)
-        g_string_append (str, _("2G, 4G (Preferred)"));
-      else if (preferred & MM_MODEM_MODE_2G)
-        g_string_append (str, _("2G (Preferred), 4G"));
-      else
-        g_string_append (str, _("2G, 4G"));
-    }
-  else if (allowed & MM_MODEM_MODE_2G &&
-           allowed & MM_MODEM_MODE_3G)
-    {
-      if (preferred & MM_MODEM_MODE_3G)
-        g_string_append (str, _("2G, 3G (Preferred)"));
-      else if (preferred & MM_MODEM_MODE_2G)
-        g_string_append (str, _("2G (Preferred), 3G"));
-      else
-        g_string_append (str, _("2G, 3G"));
-    }
-
-  if (!str->len)
-    g_string_append (str, C_("Network mode", "Unknown"));
-
-  return g_string_free (str, FALSE);
-}
-
-static void
-wwan_network_list_free (GList *network_list)
-{
-  g_list_free_full (network_list, (GDestroyNotify)mm_modem_3gpp_network_free);
-}
-
-static void
-cc_wwan_device_scan_complete_cb (GObject      *object,
-                                 GAsyncResult *result,
-                                 gpointer      user_data)
-{
-  MMModem3gpp *modem_3gpp = (MMModem3gpp *)object;
-  g_autoptr(GTask) task = user_data;
-  g_autoptr(GError) error = NULL;
-  GList *network_list;
-
-  network_list = mm_modem_3gpp_scan_finish (modem_3gpp, result, &error);
-
-  if (error)
-    g_task_return_error (task, g_steal_pointer (&error));
-  else
-    g_task_return_pointer (task, network_list, (GDestroyNotify)wwan_network_list_free);
-}
-
-void
-cc_wwan_device_scan_networks (CcWwanDevice        *self,
-                              GCancellable        *cancellable,
-                              GAsyncReadyCallback  callback,
-                              gpointer             user_data)
-{
-  g_autoptr(GTask) task = NULL;
-
-  g_return_if_fail (CC_IS_WWAN_DEVICE (self));
-  g_return_if_fail (!cancellable || G_IS_CANCELLABLE (cancellable));
-
-  task = g_task_new (self, cancellable, callback, user_data);
-
-  mm_modem_3gpp_scan (self->modem_3gpp, cancellable,
-                      cc_wwan_device_scan_complete_cb,
-                      g_steal_pointer (&task));
-}
-
-GList *
-cc_wwan_device_scan_networks_finish (CcWwanDevice  *self,
-                                     GAsyncResult  *result,
-                                     GError       **error)
-{
-  g_return_val_if_fail (CC_IS_WWAN_DEVICE (self), FALSE);
-  g_return_val_if_fail (G_IS_TASK (result), FALSE);
-
-  return g_task_propagate_pointer (G_TASK (result), error);
-}
-
-static void
-cc_wwan_device_register_network_complete_cb (GObject      *object,
-                                             GAsyncResult *result,
-                                             gpointer      user_data)
-{
-  CcWwanDevice *self;
-  MMModem3gpp *modem_3gpp = (MMModem3gpp *)object;
-  g_autoptr(GTask) task = user_data;
-  g_autoptr(GError) error = NULL;
-
-  if (!mm_modem_3gpp_register_finish (modem_3gpp, result, &error))
-    {
-      self = g_task_get_source_object (G_TASK (task));
-
-      g_clear_error (&self->error);
-      self->error = g_error_copy (error);
-      g_warning ("Error: %s", error->message);
-      g_object_notify_by_pspec (G_OBJECT (self), properties[PROP_ERROR]);
-
-      g_task_return_error (task, g_steal_pointer (&error));
-    }
-  else
-    {
-      g_task_return_boolean (task, TRUE);
-    }
-}
-
-void
-cc_wwan_device_register_network (CcWwanDevice        *self,
-                                 const gchar         *network_id,
-                                 GCancellable        *cancellable,
-                                 GAsyncReadyCallback  callback,
-                                 gpointer             user_data)
-{
-  g_autoptr(GTask) task = NULL;
-
-  g_return_if_fail (CC_IS_WWAN_DEVICE (self));
-  g_return_if_fail (!cancellable || G_IS_CANCELLABLE (cancellable));
-
-  task = g_task_new (self, cancellable, callback, user_data);
-
-  if (network_id && *network_id)
-    self->network_is_manual = TRUE;
-  else
-    self->network_is_manual = FALSE;
-
-  mm_modem_3gpp_register (self->modem_3gpp, network_id, cancellable,
-                          cc_wwan_device_register_network_complete_cb,
-                          g_steal_pointer (&task));
-}
-
-gboolean
-cc_wwan_device_register_network_finish (CcWwanDevice *self,
-                                        GAsyncResult *result,
-                                        GError       **error)
-{
-  g_return_val_if_fail (CC_IS_WWAN_DEVICE (self), FALSE);
-  g_return_val_if_fail (G_IS_TASK (result), FALSE);
-
-  return g_task_propagate_boolean (G_TASK (result), error);
-}
-
-/**
- * cc_wwan_device_get_operator_name:
- * @self: a #CcWwanDevice
- *
- * Get the human readable network operator name
- * currently the device is connected to.
- *
- * Returns: (nullable): The operator name or %NULL
- */
-const gchar *
-cc_wwan_device_get_operator_name (CcWwanDevice *self)
-{
-  g_return_val_if_fail (CC_IS_WWAN_DEVICE (self), NULL);
-
-  if (!self->modem_3gpp)
-    return NULL;
-
-  return mm_modem_3gpp_get_operator_name (self->modem_3gpp);
-}
-
-gchar *
-cc_wwan_device_dup_own_numbers (CcWwanDevice *self)
-{
-  const char *const *own_numbers;
-
-  g_return_val_if_fail (CC_IS_WWAN_DEVICE (self), NULL);
-
-  own_numbers = mm_modem_get_own_numbers (self->modem);
-
-  if (!own_numbers)
-    return NULL;
-
-  return g_strjoinv ("\n", (char **)own_numbers);
-}
-
-gchar *
-cc_wwan_device_dup_network_type_string (CcWwanDevice *self)
-{
-  MMModemAccessTechnology type;
-
-  g_return_val_if_fail (CC_IS_WWAN_DEVICE (self), NULL);
-
-  type = mm_modem_get_access_technologies (self->modem);
-
-  return mm_modem_access_technology_build_string_from_mask (type);
-}
-
-gchar *
-cc_wwan_device_dup_signal_string (CcWwanDevice *self)
-{
-  MMModemSignal *modem_signal;
-  MMSignal *signal;
-  GString *str;
-  gdouble value;
-  gboolean recent;
-  guint refresh_rate;
-
-  g_return_val_if_fail (CC_IS_WWAN_DEVICE (self), NULL);
-
-  modem_signal = mm_object_peek_modem_signal (self->mm_object);
-
-  if (modem_signal)
-    refresh_rate = mm_modem_signal_get_rate (modem_signal);
-
-  if (!modem_signal || !refresh_rate)
-    return g_strdup_printf ("%d%%", mm_modem_get_signal_quality (self->modem, &recent));
-
-  str = g_string_new ("");
-
-  /* Adapted from ModemManager mmcli-modem-signal.c */
-  signal = mm_modem_signal_peek_cdma (modem_signal);
-  if (signal)
-    {
-      if ((value = mm_signal_get_rssi (signal)) != MM_SIGNAL_UNKNOWN)
-        g_string_append_printf (str, "rssi: %.2g dBm ", value);
-      if ((value = mm_signal_get_ecio (signal)) != MM_SIGNAL_UNKNOWN)
-        g_string_append_printf (str, "ecio: %.2g dBm ", value);
-    }
-
-  signal = mm_modem_signal_peek_evdo (modem_signal);
-  if (signal)
-    {
-      if ((value = mm_signal_get_rssi (signal)) != MM_SIGNAL_UNKNOWN)
-        g_string_append_printf (str, "rssi: %.2g dBm ", value);
-      if ((value = mm_signal_get_ecio (signal)) != MM_SIGNAL_UNKNOWN)
-        g_string_append_printf (str, "ecio: %.2g dBm ", value);
-      if ((value = mm_signal_get_sinr (signal)) != MM_SIGNAL_UNKNOWN)
-        g_string_append_printf (str, "sinr: %.2g dB ", value);
-      if ((value = mm_signal_get_io (signal)) != MM_SIGNAL_UNKNOWN)
-        g_string_append_printf (str, "io: %.2g dBm ", value);
-    }
-
-  signal = mm_modem_signal_peek_gsm (modem_signal);
-  if (signal)
-    if ((value = mm_signal_get_rssi (signal)) != MM_SIGNAL_UNKNOWN)
-      g_string_append_printf (str, "rssi: %.2g dBm ", value);
-
-  signal = mm_modem_signal_peek_umts (modem_signal);
-  if (signal)
-    {
-      if ((value = mm_signal_get_rssi (signal)) != MM_SIGNAL_UNKNOWN)
-        g_string_append_printf (str, "rssi: %.2g dBm ", value);
-      if ((value = mm_signal_get_rscp (signal)) != MM_SIGNAL_UNKNOWN)
-        g_string_append_printf (str, "rscp: %.2g dBm ", value);
-      if ((value = mm_signal_get_ecio (signal)) != MM_SIGNAL_UNKNOWN)
-        g_string_append_printf (str, "ecio: %.2g dBm ", value);
-    }
-
-  signal = mm_modem_signal_peek_lte (modem_signal);
-  if (signal)
-    {
-      if ((value = mm_signal_get_rssi (signal)) != MM_SIGNAL_UNKNOWN)
-        g_string_append_printf (str, "rssi: %.2g dBm ", value);
-      if ((value = mm_signal_get_rsrq (signal)) != MM_SIGNAL_UNKNOWN)
-        g_string_append_printf (str, "rsrq: %.2g dB ", value);
-      if ((value = mm_signal_get_rsrp (signal)) != MM_SIGNAL_UNKNOWN)
-        g_string_append_printf (str, "rsrp: %.2g dBm ", value);
-      if ((value = mm_signal_get_snr (signal)) != MM_SIGNAL_UNKNOWN)
-        g_string_append_printf (str, "snr: %.2g dB ", value);
-    }
-
-  return g_string_free (str, FALSE);
-}
-
-const gchar *
-cc_wwan_device_get_manufacturer (CcWwanDevice *self)
-{
-  g_return_val_if_fail (CC_IS_WWAN_DEVICE (self), NULL);
-
-  return mm_modem_get_manufacturer (self->modem);
-}
-
-const gchar *
-cc_wwan_device_get_model (CcWwanDevice *self)
-{
-  g_return_val_if_fail (CC_IS_WWAN_DEVICE (self), NULL);
-
-  return mm_modem_get_model (self->modem);
-}
-
-const gchar *
-cc_wwan_device_get_firmware_version (CcWwanDevice *self)
-{
-  g_return_val_if_fail (CC_IS_WWAN_DEVICE (self), NULL);
-
-  return mm_modem_get_revision (self->modem);
-}
-
-const gchar *
-cc_wwan_device_get_identifier (CcWwanDevice *self)
-{
-  g_return_val_if_fail (CC_IS_WWAN_DEVICE (self), NULL);
-
-  return mm_modem_get_equipment_identifier (self->modem);
-}
-
-const gchar *
-cc_wwan_device_get_simple_error (CcWwanDevice *self)
-{
-  g_return_val_if_fail (CC_IS_WWAN_DEVICE (self), NULL);
-
-  if (!self->error)
-    return NULL;
-
-  return cc_wwan_error_get_message (self->error);
-}
-
-gboolean
-cc_wwan_device_is_nm_device (CcWwanDevice *self,
-                             GObject      *nm_device)
-{
-#if defined(HAVE_NETWORK_MANAGER) && defined(BUILD_NETWORK)
-  g_return_val_if_fail (NM_IS_DEVICE (nm_device), FALSE);
-
-  return g_str_equal (mm_modem_get_primary_port (self->modem),
-                      nm_device_get_iface (NM_DEVICE (nm_device)));
-#else
-  return FALSE;
-#endif
-}
-
-const gchar *
-cc_wwan_device_get_path (CcWwanDevice *self)
-{
-  g_return_val_if_fail (CC_IS_WWAN_DEVICE (self), "");
-
-  return mm_object_get_path (self->mm_object);
-}
-
-CcWwanData *
-cc_wwan_device_get_data (CcWwanDevice *self)
-{
-  g_return_val_if_fail (CC_IS_WWAN_DEVICE (self), NULL);
-
-  return self->wwan_data;
-}
-
-gboolean
-cc_wwan_device_pin_valid (const gchar *password,
-                          MMModemLock  lock)
-{
-  size_t len;
-
-  g_return_val_if_fail (lock == MM_MODEM_LOCK_SIM_PIN  ||
-                        lock == MM_MODEM_LOCK_SIM_PIN2 ||
-                        lock == MM_MODEM_LOCK_SIM_PUK  ||
-                        lock == MM_MODEM_LOCK_SIM_PUK2, FALSE);
-  if (!password)
-    return FALSE;
-
-  len = strlen (password);
-
-  if (len < 4 || len > 8)
-    return FALSE;
-
-  if (strspn (password, "0123456789") != len)
-    return FALSE;
-
-  /*
-   * XXX: Can PUK code be something other than 8 digits?
-   * 3GPP standard seems mum on this
-   */
-  if (lock == MM_MODEM_LOCK_SIM_PUK ||
-      lock == MM_MODEM_LOCK_SIM_PUK2)
-    if (len != 8)
-      return FALSE;
-
-  return TRUE;
-}
diff --git a/panels/wwan/cc-wwan-device.h b/panels/wwan/cc-wwan-device.h
deleted file mode 100644
index e484bcf..0000000
--- a/panels/wwan/cc-wwan-device.h
+++ /dev/null
@@ -1,152 +0,0 @@
-/* -*- Mode: C; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* cc-wwan-device.h
- *
- * Copyright 2019-2020 Purism SPC
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- *
- * Author(s):
- *   Mohammed Sadiq <sadiq@sadiqpk.org>
- *
- * SPDX-License-Identifier: GPL-3.0-or-later
- */
-
-#pragma once
-
-#include <glib-object.h>
-#include <libmm-glib.h>
-
-#if defined(HAVE_NETWORK_MANAGER) && defined(BUILD_NETWORK)
-# include "cc-wwan-data.h"
-#endif
-
-G_BEGIN_DECLS
-
-typedef enum
-{
-  CC_WWAN_REGISTRATION_STATE_UNKNOWN,
-  CC_WWAN_REGISTRATION_STATE_IDLE,
-  CC_WWAN_REGISTRATION_STATE_REGISTERED,
-  CC_WWAN_REGISTRATION_STATE_ROAMING,
-  CC_WWAN_REGISTRATION_STATE_SEARCHING,
-  CC_WWAN_REGISTRATION_STATE_DENIED
-} CcWwanState;
-
-typedef struct _CcWwanData CcWwanData;
-
-#define CC_TYPE_WWAN_DEVICE (cc_wwan_device_get_type())
-G_DECLARE_FINAL_TYPE (CcWwanDevice, cc_wwan_device, CC, WWAN_DEVICE, GObject)
-
-CcWwanDevice  *cc_wwan_device_new                (MMObject            *mm_object,
-                                                  GObject             *nm_client);
-gboolean       cc_wwan_device_has_sim            (CcWwanDevice        *self);
-MMModemLock    cc_wwan_device_get_lock           (CcWwanDevice        *self);
-gboolean       cc_wwan_device_get_sim_lock       (CcWwanDevice        *self);
-guint          cc_wwan_device_get_unlock_retries (CcWwanDevice        *self,
-                                                  MMModemLock          lock);
-void           cc_wwan_device_enable_pin         (CcWwanDevice        *self,
-                                                  const gchar         *pin,
-                                                  GCancellable        *cancellable,
-                                                  GAsyncReadyCallback  callback,
-                                                  gpointer             user_data);
-gboolean       cc_wwan_device_enable_pin_finish  (CcWwanDevice        *self,
-                                                  GAsyncResult        *result,
-                                                  GError             **error);
-void           cc_wwan_device_disable_pin        (CcWwanDevice        *self,
-                                                  const gchar         *pin,
-                                                  GCancellable        *cancellable,
-                                                  GAsyncReadyCallback  callback,
-                                                  gpointer             user_data);
-gboolean       cc_wwan_device_disable_pin_finish (CcWwanDevice        *self,
-                                                  GAsyncResult        *result,
-                                                  GError             **error);
-void           cc_wwan_device_send_pin           (CcWwanDevice        *self,
-                                                  const gchar         *pin,
-                                                  GCancellable        *cancellable,
-                                                  GAsyncReadyCallback  callback,
-                                                  gpointer             user_data);
-gboolean       cc_wwan_device_send_pin_finish    (CcWwanDevice        *self,
-                                                  GAsyncResult        *result,
-                                                  GError             **error);
-void          cc_wwan_device_send_puk            (CcWwanDevice        *self,
-                                                  const gchar         *puk,
-                                                  const gchar         *pin,
-                                                  GCancellable        *cancellable,
-                                                  GAsyncReadyCallback  callback,
-                                                  gpointer             user_data);
-gboolean      cc_wwan_device_send_puk_finish     (CcWwanDevice        *self,
-                                                  GAsyncResult        *result,
-                                                  GError             **error);
-void           cc_wwan_device_change_pin         (CcWwanDevice        *self,
-                                                  const gchar         *old_pin,
-                                                  const gchar         *new_pin,
-                                                  GCancellable        *cancellable,
-                                                  GAsyncReadyCallback  callback,
-                                                  gpointer             user_data);
-gboolean       cc_wwan_device_change_pin_finish  (CcWwanDevice        *self,
-                                                  GAsyncResult        *result,
-                                                  GError             **error);
-const gchar   *cc_wwan_device_get_operator_name  (CcWwanDevice        *self);
-gchar         *cc_wwan_device_dup_own_numbers    (CcWwanDevice        *self);
-gchar         *cc_wwan_device_dup_network_type_string (CcWwanDevice   *self);
-gchar         *cc_wwan_device_dup_signal_string  (CcWwanDevice        *self);
-const gchar   *cc_wwan_device_get_manufacturer   (CcWwanDevice        *self);
-const gchar   *cc_wwan_device_get_model          (CcWwanDevice        *self);
-const gchar   *cc_wwan_device_get_firmware_version (CcWwanDevice      *self);
-const gchar   *cc_wwan_device_get_identifier     (CcWwanDevice        *self);
-gboolean       cc_wwan_device_get_current_mode   (CcWwanDevice        *self,
-                                                  MMModemMode         *allowed,
-                                                  MMModemMode         *preferred);
-gboolean       cc_wwan_device_is_auto_network    (CcWwanDevice        *self);
-CcWwanState    cc_wwan_device_get_network_state  (CcWwanDevice        *self);
-gboolean       cc_wwan_device_get_supported_modes (CcWwanDevice       *self,
-                                                   MMModemMode        *allowed,
-                                                   MMModemMode        *preferred);
-void           cc_wwan_device_set_current_mode   (CcWwanDevice        *self,
-                                                  MMModemMode          allowed,
-                                                  MMModemMode          preferred,
-                                                  GCancellable        *cancellable,
-                                                  GAsyncReadyCallback  callback,
-                                                  gpointer             user_data);
-gboolean       cc_wwan_device_set_current_mode_finish (CcWwanDevice        *self,
-                                                       GAsyncResult        *result,
-                                                       GError             **error);
-gchar         *cc_wwan_device_get_string_from_mode    (CcWwanDevice        *self,
-                                                       MMModemMode          allowed,
-                                                       MMModemMode          preferred);
-void           cc_wwan_device_scan_networks           (CcWwanDevice        *self,
-                                                       GCancellable        *cancellable,
-                                                       GAsyncReadyCallback  callback,
-                                                       gpointer             user_data);
-GList         *cc_wwan_device_scan_networks_finish    (CcWwanDevice        *self,
-                                                       GAsyncResult        *result,
-                                                       GError             **error);
-void           cc_wwan_device_register_network        (CcWwanDevice        *self,
-                                                       const gchar         *network_id,
-                                                       GCancellable        *cancellable,
-                                                       GAsyncReadyCallback  callback,
-                                                       gpointer             user_data);
-gboolean       cc_wwan_device_register_network_finish (CcWwanDevice        *self,
-                                                       GAsyncResult        *result,
-                                                       GError             **error);
-const gchar   *cc_wwan_device_get_simple_error        (CcWwanDevice        *self);
-GSList        *cc_wwan_device_get_apn_list            (CcWwanDevice        *self);
-gboolean       cc_wwan_device_is_nm_device            (CcWwanDevice        *self,
-                                                       GObject             *nm_device);
-const gchar   *cc_wwan_device_get_path                (CcWwanDevice        *self);
-CcWwanData    *cc_wwan_device_get_data                (CcWwanDevice        *self);
-gboolean       cc_wwan_device_pin_valid               (const gchar         *password,
-                                                       MMModemLock          lock);
-
-G_END_DECLS
diff --git a/panels/wwan/cc-wwan-errors-private.h b/panels/wwan/cc-wwan-errors-private.h
deleted file mode 100644
index 076482d..0000000
--- a/panels/wwan/cc-wwan-errors-private.h
+++ /dev/null
@@ -1,104 +0,0 @@
-/* -*- Mode: C; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* cc-wwan-errors-private.h
- *
- * Copyright 2019 Purism SPC
- *
- * Modified from mm-error-helpers.c from ModemManager
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- *
- * Author(s):
- *   Mohammed Sadiq <sadiq@sadiqpk.org>
- *
- * SPDX-License-Identifier: GPL-3.0-or-later
- */
-
-#pragma once
-
-#include <glib/gi18n.h>
-#include <glib-object.h>
-#include <libmm-glib.h>
-
-typedef struct {
-  guint code;
-  const gchar *message;
-} ErrorTable;
-
-
-static ErrorTable me_errors[] = {
-  { MM_MOBILE_EQUIPMENT_ERROR_PHONE_FAILURE,                      N_("Phone failure") },
-  { MM_MOBILE_EQUIPMENT_ERROR_NO_CONNECTION,                      N_("No connection to phone") },
-  { MM_MOBILE_EQUIPMENT_ERROR_LINK_RESERVED,                      "Phone-adaptor link reserved" },
-  { MM_MOBILE_EQUIPMENT_ERROR_NOT_ALLOWED,                        N_("Operation not allowed") },
-  { MM_MOBILE_EQUIPMENT_ERROR_NOT_SUPPORTED,                      N_("Operation not supported") },
-  { MM_MOBILE_EQUIPMENT_ERROR_PH_SIM_PIN,                         "PH-SIM PIN required" },
-  { MM_MOBILE_EQUIPMENT_ERROR_PH_FSIM_PIN,                        "PH-FSIM PIN required" },
-  { MM_MOBILE_EQUIPMENT_ERROR_PH_FSIM_PUK,                        "PH-FSIM PUK required" },
-  { MM_MOBILE_EQUIPMENT_ERROR_SIM_NOT_INSERTED,                   N_("SIM not inserted") },
-  { MM_MOBILE_EQUIPMENT_ERROR_SIM_PIN,                            N_("SIM PIN required") },
-  { MM_MOBILE_EQUIPMENT_ERROR_SIM_PUK,                            N_("SIM PUK required") },
-  { MM_MOBILE_EQUIPMENT_ERROR_SIM_FAILURE,                        N_("SIM failure") },
-  { MM_MOBILE_EQUIPMENT_ERROR_SIM_BUSY,                           N_("SIM busy") },
-  { MM_MOBILE_EQUIPMENT_ERROR_SIM_WRONG,                          N_("SIM wrong") },
-  { MM_MOBILE_EQUIPMENT_ERROR_INCORRECT_PASSWORD,                 N_("Incorrect password") },
-  { MM_MOBILE_EQUIPMENT_ERROR_SIM_PIN2,                           N_("SIM PIN2 required") },
-  { MM_MOBILE_EQUIPMENT_ERROR_SIM_PUK2,                           N_("SIM PUK2 required") },
-  { MM_MOBILE_EQUIPMENT_ERROR_MEMORY_FULL,                        "Memory full" },
-  { MM_MOBILE_EQUIPMENT_ERROR_INVALID_INDEX,                      "Invalid index" },
-  { MM_MOBILE_EQUIPMENT_ERROR_NOT_FOUND,                          N_("Not found") },
-  { MM_MOBILE_EQUIPMENT_ERROR_MEMORY_FAILURE,                     "Memory failure" },
-  { MM_MOBILE_EQUIPMENT_ERROR_NO_NETWORK,                         N_("No network service") },
-  { MM_MOBILE_EQUIPMENT_ERROR_NETWORK_TIMEOUT,                    N_("Network timeout") },
-  { MM_MOBILE_EQUIPMENT_ERROR_NETWORK_NOT_ALLOWED,                "Network not allowed - emergency calls only" },
-  { MM_MOBILE_EQUIPMENT_ERROR_NETWORK_PIN,                        "Network personalization PIN required" },
-  { MM_MOBILE_EQUIPMENT_ERROR_NETWORK_PUK,                        "Network personalization PUK required" },
-  { MM_MOBILE_EQUIPMENT_ERROR_NETWORK_SUBSET_PIN,                 "Network subset personalization PIN required" },
-  { MM_MOBILE_EQUIPMENT_ERROR_NETWORK_SUBSET_PUK,                 "Network subset personalization PUK required" },
-  { MM_MOBILE_EQUIPMENT_ERROR_SERVICE_PIN,                        "Service provider personalization PIN required" },
-  { MM_MOBILE_EQUIPMENT_ERROR_SERVICE_PUK,                        "Service provider personalization PUK required" },
-  { MM_MOBILE_EQUIPMENT_ERROR_CORP_PIN,                           "Corporate personalization PIN required" },
-  { MM_MOBILE_EQUIPMENT_ERROR_CORP_PUK,                           "Corporate personalization PUK required" },
-  { MM_MOBILE_EQUIPMENT_ERROR_UNKNOWN,                            N_("Unknown error") },
-  { MM_MOBILE_EQUIPMENT_ERROR_GPRS_ILLEGAL_MS,                    "Illegal MS" },
-  { MM_MOBILE_EQUIPMENT_ERROR_GPRS_ILLEGAL_ME,                    "Illegal ME" },
-  { MM_MOBILE_EQUIPMENT_ERROR_GPRS_SERVICE_NOT_ALLOWED,           N_("GPRS services not allowed") },
-  { MM_MOBILE_EQUIPMENT_ERROR_GPRS_PLMN_NOT_ALLOWED,              "PLMN not allowed" },
-  { MM_MOBILE_EQUIPMENT_ERROR_GPRS_LOCATION_NOT_ALLOWED,          "Location area not allowed" },
-  { MM_MOBILE_EQUIPMENT_ERROR_GPRS_ROAMING_NOT_ALLOWED,           N_("Roaming not allowed in this location area") },
-  { MM_MOBILE_EQUIPMENT_ERROR_GPRS_SERVICE_OPTION_NOT_SUPPORTED,  "Service option not supported" },
-  { MM_MOBILE_EQUIPMENT_ERROR_GPRS_SERVICE_OPTION_NOT_SUBSCRIBED, "Requested service option not subscribed" },
-  { MM_MOBILE_EQUIPMENT_ERROR_GPRS_SERVICE_OPTION_OUT_OF_ORDER,   "Service option temporarily out of order" },
-  { MM_MOBILE_EQUIPMENT_ERROR_GPRS_UNKNOWN,                       N_("Unspecified GPRS error") },
-  { MM_MOBILE_EQUIPMENT_ERROR_GPRS_PDP_AUTH_FAILURE,              "PDP authentication failure" },
-  { MM_MOBILE_EQUIPMENT_ERROR_GPRS_INVALID_MOBILE_CLASS,          "Invalid mobile class" },
-};
-
-static inline const gchar *
-cc_wwan_error_get_message (GError *error)
-{
- if (g_error_matches (error, G_IO_ERROR, G_IO_ERROR_CANCELLED))
-    return _("Action Cancelled");
-
- if (g_error_matches (error, G_DBUS_ERROR, G_DBUS_ERROR_ACCESS_DENIED))
-   return _("Access denied");
-
-  if (error->domain != MM_MOBILE_EQUIPMENT_ERROR)
-    return error->message;
-
-  for (guint i = 0; i < G_N_ELEMENTS (me_errors); i++)
-    if (me_errors[i].code == error->code)
-      return _(me_errors[i].message);
-
-  return _("Unknown Error");
-}
diff --git a/panels/wwan/cc-wwan-mode-dialog.c b/panels/wwan/cc-wwan-mode-dialog.c
deleted file mode 100644
index e5917a4..0000000
--- a/panels/wwan/cc-wwan-mode-dialog.c
+++ /dev/null
@@ -1,327 +0,0 @@
-/* -*- Mode: C; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* cc-wwan-mode-dialog.c
- *
- * Copyright 2019 Purism SPC
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- *
- * Author(s):
- *   Mohammed Sadiq <sadiq@sadiqpk.org>
- *
- * SPDX-License-Identifier: GPL-3.0-or-later
- */
-
-#undef G_LOG_DOMAIN
-#define G_LOG_DOMAIN "cc-network-mode-dialog"
-
-#include <config.h>
-#include <glib/gi18n.h>
-#include <libmm-glib.h>
-
-#include "list-box-helper.h"
-#include "cc-wwan-mode-dialog.h"
-#include "cc-wwan-resources.h"
-
-/**
- * @short_description: WWAN network type selection dialog
- */
-
-#define CC_TYPE_WWAN_MODE_ROW (cc_wwan_mode_row_get_type())
-G_DECLARE_FINAL_TYPE (CcWwanModeRow, cc_wwan_mode_row, CC, WWAN_MODE_ROW, GtkListBoxRow)
-
-struct _CcWwanModeDialog
-{
-  GtkDialog      parent_instance;
-
-  CcWwanDevice  *device;
-  GtkListBox    *network_mode_list;
-  CcWwanModeRow *selected_row;
-
-  MMModemMode preferred;
-  MMModemMode allowed;
-  MMModemMode new_allowed;
-  MMModemMode new_preferred;
-};
-
-G_DEFINE_TYPE (CcWwanModeDialog, cc_wwan_mode_dialog, GTK_TYPE_DIALOG)
-
-
-enum {
-  PROP_0,
-  PROP_DEVICE,
-  N_PROPS
-};
-
-static GParamSpec *properties[N_PROPS];
-
-struct _CcWwanModeRow
-{
-  GtkListBoxRow  parent_instance;
-  GtkImage      *ok_emblem;
-  MMModemMode    allowed;
-  MMModemMode    preferred;
-};
-
-G_DEFINE_TYPE (CcWwanModeRow, cc_wwan_mode_row, GTK_TYPE_LIST_BOX_ROW)
-
-static void
-cc_wwan_mode_row_class_init (CcWwanModeRowClass *klass)
-{
-}
-
-static void
-cc_wwan_mode_row_init (CcWwanModeRow *row)
-{
-}
-
-static void
-cc_wwan_mode_changed_cb (CcWwanModeDialog *self,
-                         CcWwanModeRow    *row)
-{
-  g_assert (CC_IS_WWAN_MODE_DIALOG (self));
-  g_assert (CC_IS_WWAN_MODE_ROW (row));
-
-  if (row == self->selected_row)
-    return;
-
-  gtk_widget_show (GTK_WIDGET (row->ok_emblem));
-
-  if (self->selected_row)
-    gtk_widget_hide (GTK_WIDGET (self->selected_row->ok_emblem));
-
-  self->selected_row = row;
-}
-
-static void
-cc_wwan_mode_dialog_ok_clicked_cb (CcWwanModeDialog *self)
-{
-  g_assert (CC_IS_WWAN_MODE_DIALOG (self));
-
-  if (self->selected_row)
-    {
-      cc_wwan_device_set_current_mode (self->device,
-                                       self->selected_row->allowed,
-                                       self->selected_row->preferred,
-                                       NULL, NULL, NULL);
-    }
-  else
-    {
-      g_return_if_reached ();
-    }
-
-  gtk_widget_hide (GTK_WIDGET (self));
-}
-
-static GtkWidget *
-cc_wwan_mode_dialog_row_new (CcWwanModeDialog *self,
-                             MMModemMode       allowed,
-                             MMModemMode       preferred)
-{
-  CcWwanModeRow *row;
-  GtkWidget *box, *label, *image;
-  g_autofree gchar *mode = NULL;
-
-  g_assert (CC_WWAN_MODE_DIALOG (self));
-
-  row = g_object_new (CC_TYPE_WWAN_MODE_ROW, NULL);
-  row->allowed = allowed;
-  row->preferred = preferred;
-
-  box = gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 12);
-  gtk_widget_show (box);
-  g_object_set (box, "margin", 18, NULL);
-  gtk_container_add (GTK_CONTAINER (row), box);
-
-  mode = cc_wwan_device_get_string_from_mode (self->device, allowed, preferred);
-  label = gtk_label_new (mode);
-  gtk_widget_show (label);
-  gtk_widget_set_hexpand (label, TRUE);
-  gtk_widget_set_halign (label, GTK_ALIGN_START);
-  gtk_container_add (GTK_CONTAINER (box), label);
-
-  /* image should be hidden by default */
-  image = gtk_image_new_from_icon_name ("emblem-ok-symbolic", GTK_ICON_SIZE_BUTTON);
-  gtk_container_add (GTK_CONTAINER (box), image);
-  row->ok_emblem = GTK_IMAGE (image);
-
-  return GTK_WIDGET (row);
-}
-
-static void
-cc_wwan_mode_dialog_update (CcWwanModeDialog *self)
-{
-  MMModemMode allowed;
-  MMModemMode modes[][2] = {
-    {MM_MODEM_MODE_2G | MM_MODEM_MODE_3G | MM_MODEM_MODE_4G, MM_MODEM_MODE_4G},
-    {MM_MODEM_MODE_2G | MM_MODEM_MODE_3G | MM_MODEM_MODE_4G, 0},
-    {MM_MODEM_MODE_3G | MM_MODEM_MODE_4G, MM_MODEM_MODE_4G},
-    {MM_MODEM_MODE_3G | MM_MODEM_MODE_4G, 0},
-    {MM_MODEM_MODE_2G | MM_MODEM_MODE_3G, MM_MODEM_MODE_3G},
-    {MM_MODEM_MODE_2G | MM_MODEM_MODE_3G, 0},
-    {MM_MODEM_MODE_4G, 0},
-    {MM_MODEM_MODE_3G, 0},
-    {MM_MODEM_MODE_2G, 0},
-  };
-  size_t i;
-
-  g_assert (CC_IS_WWAN_MODE_DIALOG (self));
-
-  if (!cc_wwan_device_get_supported_modes (self->device, &allowed, NULL))
-    {
-      g_warning ("No modes supported by modem");
-      return;
-    }
-
-  for (i = 0; i < G_N_ELEMENTS (modes); i++)
-    {
-      GtkWidget *row;
-
-      if ((modes[i][0] & allowed) != modes[i][0])
-        continue;
-
-      if (modes[i][1] && !(modes[i][1] & allowed))
-        continue;
-
-      row = cc_wwan_mode_dialog_row_new (self, modes[i][0], modes[i][1]);
-      gtk_widget_show (row);
-      gtk_container_add (GTK_CONTAINER (self->network_mode_list), row);
-    }
-}
-
-static void
-cc_wwan_mode_dialog_set_property (GObject      *object,
-                                  guint         prop_id,
-                                  const GValue *value,
-                                  GParamSpec   *pspec)
-{
-  CcWwanModeDialog *self = CC_WWAN_MODE_DIALOG (object);
-
-  switch (prop_id)
-    {
-    case PROP_DEVICE:
-      self->device = g_value_dup_object (value);
-      break;
-
-    default:
-      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
-    }
-}
-
-static void
-cc_wwan_mode_dialog_constructed (GObject *object)
-{
-  CcWwanModeDialog *self = CC_WWAN_MODE_DIALOG (object);
-
-  G_OBJECT_CLASS (cc_wwan_mode_dialog_parent_class)->constructed (object);
-
-  if(!cc_wwan_device_get_current_mode (self->device, &self->allowed, &self->preferred))
-    g_warning ("Can't get allowed and preferred wwan modes");
-
-  cc_wwan_mode_dialog_update (self);
-}
-
-static void
-cc_wwan_mode_dialog_dispose (GObject *object)
-{
-  CcWwanModeDialog *self = CC_WWAN_MODE_DIALOG (object);
-
-  g_clear_object (&self->device);
-
-  G_OBJECT_CLASS (cc_wwan_mode_dialog_parent_class)->dispose (object);
-}
-
-static void
-cc_wwan_mode_dialog_update_mode (CcWwanModeRow    *row,
-                                 CcWwanModeDialog *self)
-{
-  if (self->allowed == row->allowed && self->preferred == row->preferred)
-    {
-      self->selected_row = row;
-      gtk_widget_show (GTK_WIDGET (row->ok_emblem));
-    }
-  else
-    gtk_widget_hide (GTK_WIDGET (row->ok_emblem));
-}
-
-static void
-cc_wwan_mode_dialog_show (GtkWidget *widget)
-{
-  CcWwanModeDialog *self = CC_WWAN_MODE_DIALOG (widget);
-
-  if(!cc_wwan_device_get_current_mode (self->device, &self->allowed, &self->preferred))
-    {
-      g_warning ("Can't get allowed and preferred wwan modes");
-      goto end;
-    }
-
-  gtk_container_foreach (GTK_CONTAINER (self->network_mode_list),
-                         (GtkCallback)cc_wwan_mode_dialog_update_mode,
-                         self);
- end:
-  GTK_WIDGET_CLASS (cc_wwan_mode_dialog_parent_class)->show (widget);
-}
-
-static void
-cc_wwan_mode_dialog_class_init (CcWwanModeDialogClass *klass)
-{
-  GtkWidgetClass *widget_class = GTK_WIDGET_CLASS (klass);
-  GObjectClass *object_class = G_OBJECT_CLASS (klass);
-
-  object_class->set_property = cc_wwan_mode_dialog_set_property;
-  object_class->constructed  = cc_wwan_mode_dialog_constructed;
-  object_class->dispose = cc_wwan_mode_dialog_dispose;
-
-  widget_class->show = cc_wwan_mode_dialog_show;
-
-  properties[PROP_DEVICE] =
-    g_param_spec_object ("device",
-                         "Device",
-                         "The WWAN Device",
-                         CC_TYPE_WWAN_DEVICE,
-                         G_PARAM_WRITABLE | G_PARAM_STATIC_STRINGS | G_PARAM_CONSTRUCT_ONLY);
-
-  g_object_class_install_properties (object_class, N_PROPS, properties);
-
-  gtk_widget_class_set_template_from_resource (widget_class,
-                                               "/org/gnome/control-center/wwan/cc-wwan-mode-dialog.ui");
-
-  gtk_widget_class_bind_template_child (widget_class, CcWwanModeDialog, network_mode_list);
-
-  gtk_widget_class_bind_template_callback (widget_class, cc_wwan_mode_changed_cb);
-  gtk_widget_class_bind_template_callback (widget_class, cc_wwan_mode_dialog_ok_clicked_cb);
-}
-
-static void
-cc_wwan_mode_dialog_init (CcWwanModeDialog *self)
-{
-  gtk_widget_init_template (GTK_WIDGET (self));
-
-  gtk_list_box_set_header_func (self->network_mode_list,
-                                cc_list_box_update_header_func,
-                                NULL, NULL);
-}
-
-CcWwanModeDialog *
-cc_wwan_mode_dialog_new (GtkWindow    *parent_window,
-                         CcWwanDevice *device)
-{
-  g_return_val_if_fail (GTK_IS_WINDOW (parent_window), NULL);
-  g_return_val_if_fail (CC_IS_WWAN_DEVICE (device), NULL);
-
-  return g_object_new (CC_TYPE_WWAN_MODE_DIALOG,
-                       "transient-for", parent_window,
-                       "use-header-bar", 1,
-                       "device", device,
-                       NULL);
-}
diff --git a/panels/wwan/cc-wwan-mode-dialog.h b/panels/wwan/cc-wwan-mode-dialog.h
deleted file mode 100644
index 2399f0b..0000000
--- a/panels/wwan/cc-wwan-mode-dialog.h
+++ /dev/null
@@ -1,40 +0,0 @@
-/* -*- Mode: C; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* cc-wwan-mode-dialog.h
- *
- * Copyright 2019 Purism SPC
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- *
- * Author(s):
- *   Mohammed Sadiq <sadiq@sadiqpk.org>
- *
- * SPDX-License-Identifier: GPL-3.0-or-later
- */
-
-#pragma once
-
-#include <handy.h>
-#include <shell/cc-panel.h>
-
-#include "cc-wwan-device.h"
-
-G_BEGIN_DECLS
-
-#define CC_TYPE_WWAN_MODE_DIALOG (cc_wwan_mode_dialog_get_type())
-G_DECLARE_FINAL_TYPE (CcWwanModeDialog, cc_wwan_mode_dialog, CC, WWAN_MODE_DIALOG, GtkDialog)
-
-CcWwanModeDialog *cc_wwan_mode_dialog_new (GtkWindow    *parent_window,
-                                           CcWwanDevice *device);
-
-G_END_DECLS
diff --git a/panels/wwan/cc-wwan-mode-dialog.ui b/panels/wwan/cc-wwan-mode-dialog.ui
deleted file mode 100644
index e0a924a..0000000
--- a/panels/wwan/cc-wwan-mode-dialog.ui
+++ /dev/null
@@ -1,57 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<interface>
-  <template class="CcWwanModeDialog" parent="GtkDialog">
-    <property name="title" translatable="yes">Network Mode</property>
-    <property name="default-height">480</property>
-    <property name="default-width">360</property>
-    <signal name="delete-event" handler="gtk_widget_hide_on_delete"/>
-
-    <child internal-child="vbox">
-      <object class="GtkBox">
-        <property name="visible">1</property>
-        <property name="margin-start">12</property>
-        <property name="margin-end">12</property>
-        <property name="margin-top">18</property>
-        <property name="margin-bottom">18</property>
-        <child>
-          <object class="GtkFrame">
-            <property name="visible">1</property>
-            <child>
-              <object class="GtkListBox" id="network_mode_list">
-                <property name="visible">1</property>
-                <property name="selection-mode">none</property>
-                <signal name="row-activated" handler="cc_wwan_mode_changed_cb" swapped="yes" />
-              </object>
-            </child>
-          </object>
-        </child>
-      </object>
-    </child>
-
-    <child type="action">
-      <object class="GtkButton" id="button_cancel">
-        <property name="visible">1</property>
-        <property name="use-underline">1</property>
-        <property name="label" translatable="yes">_Cancel</property>
-        <signal name="clicked" handler="gtk_widget_hide" swapped="yes"/>
-      </object>
-    </child>
-    <child type="action">
-      <object class="GtkButton" id="button_ok">
-        <property name="visible">1</property>
-        <property name="can-default">1</property>
-        <property name="use-underline">1</property>
-        <property name="label" translatable="yes">_Set</property>
-        <signal name="clicked" handler="cc_wwan_mode_dialog_ok_clicked_cb" swapped="yes"/>
-        <style>
-          <class name="suggested-action "/>
-        </style>
-      </object>
-    </child>
-
-    <action-widgets>
-      <action-widget response="cancel">button_cancel</action-widget>
-      <action-widget response="apply" default="true">button_ok</action-widget>
-    </action-widgets>
-  </template>
-</interface>
diff --git a/panels/wwan/cc-wwan-network-dialog.c b/panels/wwan/cc-wwan-network-dialog.c
deleted file mode 100644
index 1c8883b..0000000
--- a/panels/wwan/cc-wwan-network-dialog.c
+++ /dev/null
@@ -1,443 +0,0 @@
-/* -*- Mode: C; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* cc-wwan-network-dialog.c
- *
- * Copyright 2019 Purism SPC
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- *
- * Author(s):
- *   Mohammed Sadiq <sadiq@sadiqpk.org>
- *
- * SPDX-License-Identifier: GPL-3.0-or-later
- */
-
-#undef G_LOG_DOMAIN
-#define G_LOG_DOMAIN "cc-wwan-network-dialog"
-
-#include <config.h>
-#include <glib/gi18n.h>
-#include <libmm-glib.h>
-
-#include "list-box-helper.h"
-#include "cc-list-row.h"
-#include "cc-wwan-errors-private.h"
-#include "cc-wwan-network-dialog.h"
-#include "cc-wwan-resources.h"
-
-/**
- * @short_description: WWAN network operator selection dialog
- */
-
-#define CC_TYPE_WWAN_NETWORK_ROW (cc_wwan_network_row_get_type())
-G_DECLARE_FINAL_TYPE (CcWwanNetworkRow, cc_wwan_network_row, CC, WWAN_NETWORK_ROW, GtkListBoxRow)
-
-struct _CcWwanNetworkDialog
-{
-  GtkDialog     parent_instance;
-
-  CcListRow    *automatic_row;
-  GtkButton    *button_apply;
-  GtkSpinner   *loading_spinner;
-  GtkBox       *network_search_title;
-  GtkLabel     *notification_label;
-  GtkRevealer  *notification_revealer;
-  GtkListBox   *operator_list_box;
-  GtkButton    *refresh_button;
-
-  CcWwanDevice *device;
-  GList        *operator_list;
-
-  CcWwanNetworkRow *selected_row;
-
-  GCancellable *search_cancellable;
-
-  guint         revealer_timeout_id;
-  gboolean      no_update_network;
-};
-
-G_DEFINE_TYPE (CcWwanNetworkDialog, cc_wwan_network_dialog, GTK_TYPE_DIALOG)
-
-
-enum {
-  PROP_0,
-  PROP_DEVICE,
-  N_PROPS
-};
-
-static GParamSpec *properties[N_PROPS];
-
-struct _CcWwanNetworkRow
-{
-  GtkListBoxRow  parent_instance;
-  GtkImage      *ok_emblem;
-  gchar         *operator_code;
-};
-
-G_DEFINE_TYPE (CcWwanNetworkRow, cc_wwan_network_row, GTK_TYPE_LIST_BOX_ROW)
-
-static void
-cc_wwan_network_row_finalize (GObject *object)
-{
-  CcWwanNetworkRow *row = (CcWwanNetworkRow *)object;
-
-  g_free (row->operator_code);
-
-  G_OBJECT_CLASS (cc_wwan_network_row_parent_class)->finalize (object);
-}
-
-static void
-cc_wwan_network_row_class_init (CcWwanNetworkRowClass *klass)
-{
-  GObjectClass *object_class = G_OBJECT_CLASS (klass);
-
-  object_class->finalize = cc_wwan_network_row_finalize;
-}
-
-static void
-cc_wwan_network_row_init (CcWwanNetworkRow *row)
-{
-}
-
-static void
-cc_wwan_on_notification_closed (CcWwanNetworkDialog *self,
-                                GtkWidget           *button)
-{
-  g_assert (CC_IS_WWAN_NETWORK_DIALOG (self));
-
-  gtk_revealer_set_reveal_child (GTK_REVEALER (self->notification_revealer), FALSE);
-
-  if (self->revealer_timeout_id != 0)
-    g_source_remove (self->revealer_timeout_id);
-
-  self->revealer_timeout_id = 0;
-}
-
-static gboolean
-cc_wwan_on_notification_timeout (gpointer user_data)
-{
-  cc_wwan_on_notification_closed (user_data, NULL);
-
-  return G_SOURCE_REMOVE;
-}
-
-static void
-cc_wwan_network_changed_cb (CcWwanNetworkDialog *self,
-                            CcWwanNetworkRow    *row)
-{
-  if (row == self->selected_row)
-    return;
-
-  gtk_widget_set_sensitive (GTK_WIDGET (self->button_apply), TRUE);
-  gtk_widget_show (GTK_WIDGET (row->ok_emblem));
-
-  if (self->selected_row)
-    gtk_widget_hide (GTK_WIDGET (self->selected_row->ok_emblem));
-
-  self->selected_row = row;
-}
-
-/*
- * cc_wwan_network_dialog_row_new:
- * @self: a #CcWwanNetworkDialog
- * @operator_name: (transfer full): The long operator name
- * @operator_id: (transfer full): operator id
- */
-static CcWwanNetworkRow *
-cc_wwan_network_dialog_row_new (CcWwanNetworkDialog *self,
-                                const gchar         *operator_name,
-                                const gchar         *operator_code)
-{
-  CcWwanNetworkRow *row;
-  GtkWidget *box, *label, *image;
-
-  row = g_object_new (CC_TYPE_WWAN_NETWORK_ROW, NULL);
-
-  box = gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 12);
-  gtk_widget_show (box);
-  g_object_set (box, "margin", 18, NULL);
-  gtk_container_add (GTK_CONTAINER (row), box);
-
-  label = gtk_label_new (operator_name);
-  gtk_widget_show (label);
-  gtk_widget_set_hexpand (label, TRUE);
-  gtk_widget_set_halign (label, GTK_ALIGN_START);
-  gtk_container_add (GTK_CONTAINER (box), label);
-
-  image = gtk_image_new_from_icon_name ("emblem-ok-symbolic", GTK_ICON_SIZE_BUTTON);
-  row->ok_emblem = GTK_IMAGE (image);
-  gtk_container_add (GTK_CONTAINER (box), GTK_WIDGET (row->ok_emblem));
-
-  row->operator_code = g_strdup (operator_code);
-
-  return row;
-}
-
-static void
-cc_wwan_network_dialog_update_current_network (CcWwanNetworkDialog *self)
-{
-  CcWwanNetworkRow *row;
-  const gchar *operator_name;
-
-  operator_name = cc_wwan_device_get_operator_name (self->device);
-
-  if (!operator_name || operator_name[0] == '\0')
-    return;
-
-  gtk_container_foreach (GTK_CONTAINER (self->operator_list_box),
-                         (GtkCallback)gtk_widget_destroy, NULL);
-
-  row = cc_wwan_network_dialog_row_new (self, operator_name, "");
-  self->selected_row = row;
-  gtk_container_add (GTK_CONTAINER (self->operator_list_box), GTK_WIDGET (row));
-  gtk_widget_show_all (GTK_WIDGET (self->operator_list_box));
-}
-
-static void
-cc_wwan_network_dialog_update (CcWwanNetworkDialog *self)
-{
-  CcWwanNetworkRow *row;
-  GList *item;
-  const gchar *operator_code, *operator_name;
-
-  gtk_container_foreach (GTK_CONTAINER (self->operator_list_box),
-                         (GtkCallback)gtk_widget_destroy, NULL);
-
-  for (item = self->operator_list; item; item = item->next)
-    {
-      operator_code = mm_modem_3gpp_network_get_operator_code (item->data);
-      operator_name = mm_modem_3gpp_network_get_operator_long (item->data);
-
-      row = cc_wwan_network_dialog_row_new (self, operator_name, operator_code);
-      gtk_widget_show (GTK_WIDGET (row));
-      gtk_container_add (GTK_CONTAINER (self->operator_list_box), GTK_WIDGET (row));
-    }
-}
-
-static void
-cc_wwan_network_scan_complete_cb (GObject      *object,
-                                  GAsyncResult *result,
-                                  gpointer      user_data)
-{
-  g_autoptr(CcWwanNetworkDialog) self = user_data;
-  g_autoptr(GError) error = NULL;
-
-  if (self->operator_list)
-    g_list_free_full (self->operator_list, (GDestroyNotify)mm_modem_3gpp_network_free);
-
-  gtk_widget_set_sensitive (GTK_WIDGET (self->refresh_button), TRUE);
-  gtk_spinner_stop (self->loading_spinner);
-  self->operator_list = cc_wwan_device_scan_networks_finish (self->device, result, &error);
-  gtk_widget_set_sensitive (GTK_WIDGET (self->operator_list_box), !error);
-
-  if (!error)
-    {
-      cc_wwan_network_dialog_update (self);
-      gtk_widget_show (GTK_WIDGET (self->operator_list_box));
-    }
-  else if (!g_error_matches (error, G_IO_ERROR, G_IO_ERROR_CANCELLED))
-    {
-      self->no_update_network = TRUE;
-      gtk_widget_activate (GTK_WIDGET (self->automatic_row));
-      gtk_widget_set_sensitive (GTK_WIDGET (self->operator_list_box), FALSE);
-
-      gtk_label_set_label (self->notification_label,
-                           cc_wwan_error_get_message (error));
-      gtk_revealer_set_reveal_child (self->notification_revealer, TRUE);
-      self->revealer_timeout_id = g_timeout_add_seconds (5, cc_wwan_on_notification_timeout, self);
-
-      gtk_widget_show (GTK_WIDGET (self->operator_list_box));
-      g_warning ("Error: scanning networks failed: %s", error->message);
-    }
-}
-
-static void
-cc_wwan_network_dialog_refresh_networks (CcWwanNetworkDialog *self)
-{
-  gtk_widget_set_sensitive (GTK_WIDGET (self->refresh_button), FALSE);
-  gtk_spinner_start (self->loading_spinner);
-  cc_wwan_device_scan_networks (self->device, self->search_cancellable,
-                                (GAsyncReadyCallback)cc_wwan_network_scan_complete_cb,
-                                g_object_ref (self));
-}
-
-static void
-cc_wwan_network_dialog_apply_clicked_cb (CcWwanNetworkDialog *self)
-{
-  gboolean is_auto;
-
-  g_assert (CC_IS_WWAN_NETWORK_DIALOG (self));
-
-  is_auto = cc_list_row_get_active (self->automatic_row);
-
-  if (is_auto)
-    cc_wwan_device_register_network (self->device, "", NULL, NULL, NULL);
-  else if (self->selected_row)
-    cc_wwan_device_register_network (self->device, self->selected_row->operator_code, NULL, NULL, self);
-  else
-    g_warn_if_reached ();
-
-  gtk_widget_hide (GTK_WIDGET (self));
-}
-
-static void
-cc_wwan_auto_network_changed_cb (CcWwanNetworkDialog *self,
-                                 GParamSpec          *pspec,
-                                 CcListRow           *auto_network_row)
-{
-  gboolean is_auto;
-
-  g_assert (CC_IS_WWAN_NETWORK_DIALOG (self));
-  g_assert (CC_IS_LIST_ROW (auto_network_row));
-
-  is_auto = cc_list_row_get_active (auto_network_row);
-  gtk_widget_set_sensitive (GTK_WIDGET (self->button_apply), is_auto);
-
-  if (self->no_update_network)
-    {
-      self->no_update_network = FALSE;
-      return;
-    }
-
-  self->selected_row = NULL;
-  gtk_widget_set_visible (GTK_WIDGET (self->network_search_title), !is_auto);
-  gtk_widget_set_sensitive (GTK_WIDGET (self->operator_list_box), !is_auto);
-  gtk_widget_hide (GTK_WIDGET (self->operator_list_box));
-
-  if (is_auto)
-    {
-      g_cancellable_cancel (self->search_cancellable);
-      g_cancellable_reset (self->search_cancellable);
-    }
-  else
-    {
-      cc_wwan_network_dialog_refresh_networks (self);
-    }
-}
-
-static void
-cc_wwan_network_dialog_show (GtkWidget *widget)
-{
-  CcWwanNetworkDialog *self = (CcWwanNetworkDialog *)widget;
-  gboolean is_auto;
-
-  is_auto = cc_wwan_device_is_auto_network (self->device);
-
-  g_object_set (self->automatic_row, "active", is_auto, NULL);
-
-  cc_wwan_network_dialog_update_current_network (self);
-
-  GTK_WIDGET_CLASS (cc_wwan_network_dialog_parent_class)->show (widget);
-}
-
-static void
-cc_wwan_network_dialog_set_property (GObject      *object,
-                                     guint         prop_id,
-                                     const GValue *value,
-                                     GParamSpec   *pspec)
-{
-  CcWwanNetworkDialog *self = (CcWwanNetworkDialog *)object;
-
-  switch (prop_id)
-    {
-    case PROP_DEVICE:
-      self->device = g_value_dup_object (value);
-      break;
-
-    default:
-      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
-    }
-}
-
-static void
-cc_wwan_network_dialog_dispose (GObject *object)
-{
-  CcWwanNetworkDialog *self = (CcWwanNetworkDialog *)object;
-
-  if (self->revealer_timeout_id != 0)
-    g_source_remove (self->revealer_timeout_id);
-
-  self->revealer_timeout_id = 0;
-
-  g_cancellable_cancel (self->search_cancellable);
-
-  g_clear_object (&self->search_cancellable);
-  g_clear_object (&self->device);
-
-  G_OBJECT_CLASS (cc_wwan_network_dialog_parent_class)->dispose (object);
-}
-
-static void
-cc_wwan_network_dialog_class_init (CcWwanNetworkDialogClass *klass)
-{
-  GtkWidgetClass *widget_class = GTK_WIDGET_CLASS (klass);
-  GObjectClass *object_class = G_OBJECT_CLASS (klass);
-
-  object_class->set_property = cc_wwan_network_dialog_set_property;
-  object_class->dispose = cc_wwan_network_dialog_dispose;
-
-  widget_class->show = cc_wwan_network_dialog_show;
-
-  properties[PROP_DEVICE] =
-    g_param_spec_object ("device",
-                         "Device",
-                         "The WWAN Device",
-                         CC_TYPE_WWAN_DEVICE,
-                         G_PARAM_WRITABLE | G_PARAM_STATIC_STRINGS | G_PARAM_CONSTRUCT_ONLY);
-
-  g_object_class_install_properties (object_class, N_PROPS, properties);
-
-  gtk_widget_class_set_template_from_resource (widget_class,
-                                               "/org/gnome/control-center/wwan/cc-wwan-network-dialog.ui");
-
-  gtk_widget_class_bind_template_child (widget_class, CcWwanNetworkDialog, automatic_row);
-  gtk_widget_class_bind_template_child (widget_class, CcWwanNetworkDialog, button_apply);
-  gtk_widget_class_bind_template_child (widget_class, CcWwanNetworkDialog, loading_spinner);
-  gtk_widget_class_bind_template_child (widget_class, CcWwanNetworkDialog, network_search_title);
-  gtk_widget_class_bind_template_child (widget_class, CcWwanNetworkDialog, notification_label);
-  gtk_widget_class_bind_template_child (widget_class, CcWwanNetworkDialog, notification_revealer);
-  gtk_widget_class_bind_template_child (widget_class, CcWwanNetworkDialog, operator_list_box);
-  gtk_widget_class_bind_template_child (widget_class, CcWwanNetworkDialog, refresh_button);
-
-  gtk_widget_class_bind_template_callback (widget_class, cc_wwan_network_changed_cb);
-  gtk_widget_class_bind_template_callback (widget_class, cc_wwan_on_notification_closed);
-  gtk_widget_class_bind_template_callback (widget_class, cc_wwan_auto_network_changed_cb);
-  gtk_widget_class_bind_template_callback (widget_class, cc_wwan_network_dialog_refresh_networks);
-  gtk_widget_class_bind_template_callback (widget_class, cc_wwan_network_dialog_apply_clicked_cb);
-}
-
-static void
-cc_wwan_network_dialog_init (CcWwanNetworkDialog *self)
-{
-  gtk_widget_init_template (GTK_WIDGET (self));
-
-  self->search_cancellable = g_cancellable_new ();
-
-  gtk_list_box_set_header_func (self->operator_list_box,
-                                cc_list_box_update_header_func,
-                                NULL, NULL);
-}
-
-CcWwanNetworkDialog *
-cc_wwan_network_dialog_new (GtkWindow    *parent_window,
-                            CcWwanDevice *device)
-{
-  g_return_val_if_fail (GTK_IS_WINDOW (parent_window), NULL);
-  g_return_val_if_fail (CC_IS_WWAN_DEVICE (device), NULL);
-
-  return g_object_new (CC_TYPE_WWAN_NETWORK_DIALOG,
-                       "transient-for", parent_window,
-                       "use-header-bar", 1,
-                       "device", device,
-                       NULL);
-}
diff --git a/panels/wwan/cc-wwan-network-dialog.h b/panels/wwan/cc-wwan-network-dialog.h
deleted file mode 100644
index 1818a08..0000000
--- a/panels/wwan/cc-wwan-network-dialog.h
+++ /dev/null
@@ -1,40 +0,0 @@
-/* -*- Mode: C; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* cc-wwan-network-dialog.h
- *
- * Copyright 2019 Purism SPC
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- *
- * Author(s):
- *   Mohammed Sadiq <sadiq@sadiqpk.org>
- *
- * SPDX-License-Identifier: GPL-3.0-or-later
- */
-
-#pragma once
-
-#include <handy.h>
-#include <shell/cc-panel.h>
-
-#include "cc-wwan-device.h"
-
-G_BEGIN_DECLS
-
-#define CC_TYPE_WWAN_NETWORK_DIALOG (cc_wwan_network_dialog_get_type())
-G_DECLARE_FINAL_TYPE (CcWwanNetworkDialog, cc_wwan_network_dialog, CC, WWAN_NETWORK_DIALOG, GtkDialog)
-
-CcWwanNetworkDialog *cc_wwan_network_dialog_new (GtkWindow    *parent_window,
-                                                 CcWwanDevice *device);
-
-G_END_DECLS
diff --git a/panels/wwan/cc-wwan-network-dialog.ui b/panels/wwan/cc-wwan-network-dialog.ui
deleted file mode 100644
index 03223b3..0000000
--- a/panels/wwan/cc-wwan-network-dialog.ui
+++ /dev/null
@@ -1,188 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<interface>
-  <template class="CcWwanNetworkDialog" parent="GtkDialog">
-    <property name="title" translatable="yes">Network</property>
-    <property name="default-height">480</property>
-    <property name="default-width">360</property>
-    <signal name="delete-event" handler="gtk_widget_hide_on_delete"/>
-
-    <child internal-child="vbox">
-      <object class="GtkBox">
-        <property name="visible">1</property>
-        <property name="border-width">0</property>
-        <property name="width-request">340</property>
-        <property name="height-request">360</property>
-        <child>
-          <object class="GtkOverlay">
-            <property name="visible">1</property>
-            <child type="overlay">
-              <object class="GtkRevealer" id="notification_revealer">
-                <property name="visible">1</property>
-                <property name="halign">center</property>
-                <property name="valign">start</property>
-                <child>
-                  <object class="GtkBox">
-                    <property name="visible">1</property>
-                    <property name="spacing">12</property>
-                    <style>
-                      <class name="frame" />
-                      <class name="app-notification" />
-                    </style>
-                    <child>
-                      <object class="GtkLabel" id="notification_label">
-                        <property name="visible">1</property>
-                        <property name="wrap">1</property>
-                        <property name="wrap-mode">word-char</property>
-                        <property name="use-markup">1</property>
-                      </object>
-                    </child>
-                    <child>
-                      <object class="GtkButton">
-                        <property name="visible">1</property>
-                        <property name="relief">none</property>
-                        <signal name="clicked" handler="cc_wwan_on_notification_closed" swapped="yes" />
-                        <child internal-child="accessible">
-                          <object class="AtkObject">
-                            <property name="accessible-name" translatable="yes">Close</property>
-                          </object>
-                        </child>
-                        <child>
-                          <object class="GtkImage">
-                            <property name="visible">1</property>
-                            <property name="icon-name">window-close-symbolic</property>
-                          </object>
-                        </child>
-                      </object>
-                    </child>
-                  </object>
-                </child>
-              </object>
-            </child>
-            <child>
-              <object class="GtkBox">
-                <property name="visible">1</property>
-                <property name="margin-start">12</property>
-                <property name="margin-end">12</property>
-                <property name="margin-top">18</property>
-                <property name="margin-bottom">18</property>
-                <property name="orientation">vertical</property>
-
-                <!-- Automatic Network Selection Switch -->
-                <child>
-                  <object class="GtkListBox">
-                    <property name="visible">1</property>
-                    <property name="selection-mode">none</property>
-                    <property name="margin-bottom">18</property>
-                    <style>
-                      <class name="frame" />
-                    </style>
-                    <child>
-                      <object class="CcListRow" id="automatic_row">
-                        <property name="visible">1</property>
-                        <property name="show-switch">1</property>
-                        <property name="use-underline">1</property>
-                        <property name="title" translatable="yes">_Automatic</property>
-                        <signal name="notify::active" handler="cc_wwan_auto_network_changed_cb" swapped="yes" />
-                      </object>
-                    </child>
-                  </object>
-                </child>
-
-                <!-- Network Selection List Title and Spinner -->
-                <child>
-                  <object class="GtkBox" id="network_search_title" >
-                    <property name="visible">1</property>
-                    <property name="margin-bottom">9</property>
-                    <property name="spacing">6</property>
-                    <child>
-                      <object class="GtkLabel">
-                        <property name="visible">1</property>
-                        <property name="label" translatable="yes">Choose Network</property>
-                        <property name="xalign">0.0</property>
-                        <attributes>
-                          <attribute name="weight" value="bold"/>
-                        </attributes>
-                      </object>
-                    </child>
-                    <child>
-                      <object class="GtkSpinner" id="loading_spinner">
-                        <property name="visible">1</property>
-                      </object>
-                    </child>
-                    <child>
-                      <object class="GtkButton" id="refresh_button">
-                        <property name="visible">1</property>
-                        <signal name="clicked" handler="cc_wwan_network_dialog_refresh_networks" swapped="yes" />
-                        <child internal-child="accessible">
-                          <object class="AtkObject">
-                            <property name="accessible-name" translatable="yes">Refresh Network Providers</property>
-                          </object>
-                        </child>
-                        <child>
-                          <object class="GtkImage">
-                            <property name="visible">1</property>
-                            <property name="icon-name">view-refresh-symbolic</property>
-                          </object>
-                        </child>
-                      </object>
-                      <packing>
-                        <property name="pack-type">end</property>
-                      </packing>
-                    </child>
-                  </object>
-                </child>
-
-                <!-- Network Selection List -->
-                <child>
-                  <object class="GtkScrolledWindow">
-                    <property name="visible">1</property>
-                    <property name="hscrollbar-policy">never</property>
-                    <property name="propagate-natural-height">1</property>
-                    <child>
-                      <object class="GtkListBox" id="operator_list_box">
-                        <property name="visible">0</property>
-                        <property name="sensitive">0</property>
-                        <property name="selection-mode">none</property>
-                        <signal name="row-activated" handler="cc_wwan_network_changed_cb" swapped="yes" />
-                        <style>
-                         <class name="frame" />
-                        </style>
-                      </object>
-                    </child>
-                  </object>
-                </child>
-
-              </object>
-            </child>
-          </object>
-        </child>
-      </object>
-    </child> <!-- ./internal-child -->
-
-    <child type="action">
-      <object class="GtkButton" id="button_cancel">
-        <property name="visible">1</property>
-        <property name="use-underline">1</property>
-        <property name="label" translatable="yes">_Cancel</property>
-        <signal name="clicked" handler="gtk_widget_hide" swapped="yes"/>
-      </object>
-    </child>
-    <child type="action">
-      <object class="GtkButton" id="button_apply">
-        <property name="visible">1</property>
-        <property name="can-default">1</property>
-        <property name="use-underline">1</property>
-        <property name="label" translatable="yes">_Set</property>
-        <signal name="clicked" handler="cc_wwan_network_dialog_apply_clicked_cb" swapped="yes"/>
-        <style>
-          <class name="suggested-action "/>
-        </style>
-      </object>
-    </child>
-
-    <action-widgets>
-      <action-widget response="cancel">button_cancel</action-widget>
-      <action-widget response="apply" default="true">button_apply</action-widget>
-    </action-widgets>
-  </template>
-</interface>
diff --git a/panels/wwan/cc-wwan-panel.c b/panels/wwan/cc-wwan-panel.c
deleted file mode 100644
index 963c469..0000000
--- a/panels/wwan/cc-wwan-panel.c
+++ /dev/null
@@ -1,929 +0,0 @@
-/* -*- Mode: C; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* cc-wwan-panel.c
- *
- * Copyright 2019 Purism SPC
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- *
- * Author(s):
- *   Mohammed Sadiq <sadiq@sadiqpk.org>
- *
- * SPDX-License-Identifier: GPL-3.0-or-later
- */
-
-#undef G_LOG_DOMAIN
-#define G_LOG_DOMAIN "cc-wwan-panel"
-
-#include <config.h>
-#include <glib/gi18n.h>
-#include <libmm-glib.h>
-
-#include "cc-wwan-device.h"
-#include "cc-wwan-data.h"
-#include "cc-wwan-device-page.h"
-#include "cc-wwan-panel.h"
-#include "cc-wwan-resources.h"
-
-#include "shell/cc-application.h"
-#include "shell/cc-debug.h"
-#include "shell/cc-object-storage.h"
-
-typedef enum {
-  OPERATION_NULL,
-  OPERATION_SHOW_DEVICE,
-} CmdlineOperation;
-
-struct _CcWwanPanel
-{
-  CcPanel parent_instance;
-
-  GtkListBox       *data_select_listbox;
-  GtkPopover       *data_select_popover;
-  GtkLabel         *data_sim_label;
-  GtkListBox       *data_sim_select_listbox;
-  GtkStack         *devices_stack;
-  GtkStackSwitcher *devices_switcher;
-  GtkSwitch        *enable_switch;
-  GtkStack         *main_stack;
-  GtkRevealer      *multi_device_revealer;
-  GtkLabel         *notification_label;
-  GtkRevealer      *notification_revealer;
-
-  GDBusProxy   *rfkill_proxy;
-  MMManager    *mm_manager;
-  NMClient     *nm_client;
-
-  /* The default device that will be used for data */
-  CcWwanDevice *data_device;
-  GListStore   *devices;
-  GListStore   *data_devices;
-  GCancellable *cancellable;
-
-  CmdlineOperation  arg_operation;
-  char             *arg_device;
-
-  guint revealer_timeout_id;
-};
-
-enum {
-  PROP_0,
-  PROP_PARAMETERS
-};
-
-G_DEFINE_TYPE (CcWwanPanel, cc_wwan_panel, CC_TYPE_PANEL)
-
-
-#define CC_TYPE_DATA_DEVICE_ROW (cc_data_device_row_get_type())
-G_DECLARE_FINAL_TYPE (CcDataDeviceRow, cc_data_device_row, CC, DATA_DEVICE_ROW, GtkListBoxRow)
-
-struct _CcDataDeviceRow
-{
-  GtkListBoxRow  parent_instance;
-
-  GtkImage      *ok_emblem;
-  CcWwanDevice  *device;
-};
-
-G_DEFINE_TYPE (CcDataDeviceRow, cc_data_device_row, GTK_TYPE_LIST_BOX_ROW)
-
-static void
-cc_data_device_row_class_init (CcDataDeviceRowClass *klass)
-{
-}
-
-static void
-cc_data_device_row_init (CcDataDeviceRow *row)
-{
-}
-
-static CmdlineOperation
-cmdline_operation_from_string (const gchar *str)
-{
-  if (g_strcmp0 (str, "show-device") == 0)
-    return OPERATION_SHOW_DEVICE;
-
-  g_warning ("Invalid additional argument %s", str);
-  return OPERATION_NULL;
-}
-
-static void
-reset_command_line_args (CcWwanPanel *self)
-{
-  self->arg_operation = OPERATION_NULL;
-  g_clear_pointer (&self->arg_device, g_free);
-}
-
-static gboolean
-verify_argv (CcWwanPanel  *self,
-             const char  **args)
-{
-	switch (self->arg_operation)
-    {
-    case OPERATION_SHOW_DEVICE:
-      if (self->arg_device == NULL)
-        {
-          g_warning ("Operation %s requires an object path", args[0]);
-          return FALSE;
-        }
-    default:
-      return TRUE;
-    }
-}
-
-static void
-handle_argv (CcWwanPanel *self)
-{
-  if (self->arg_operation == OPERATION_SHOW_DEVICE &&
-      self->arg_operation)
-    {
-      g_autoptr(GList) pages = NULL;
-
-      pages = gtk_container_get_children (GTK_CONTAINER (self->devices_stack));
-
-      for (GList *page = pages; page; page = page->next)
-        {
-          CcWwanDevice *device;
-
-          device = cc_wwan_device_page_get_device (page->data);
-
-          if (g_strcmp0 (cc_wwan_device_get_path (device), self->arg_device) == 0)
-            {
-              gtk_stack_set_visible_child (GTK_STACK (self->devices_stack), page->data);
-              g_debug ("Opening device %s", self->arg_device);
-              reset_command_line_args (self);
-              return;
-            }
-        }
-    }
-}
-
-static gboolean
-wwan_panel_device_is_supported (GDBusObject *object)
-{
-  MMObject *mm_object;
-  MMModem *modem;
-  MMModemCapability capability;
-
-  g_assert (G_IS_DBUS_OBJECT (object));
-
-  mm_object = MM_OBJECT (object);
-  modem = mm_object_get_modem (mm_object);
-  capability = mm_modem_get_current_capabilities (modem);
-
-  /* We Support only GSM/3G/LTE devices */
-  if (capability & (MM_MODEM_CAPABILITY_GSM_UMTS |
-                    MM_MODEM_CAPABILITY_LTE |
-                    MM_MODEM_CAPABILITY_LTE_ADVANCED))
-    return TRUE;
-
-  return FALSE;
-}
-
-static gint
-wwan_model_get_item_index (GListModel *model,
-                           gpointer    item)
-{
-  guint i, n_items;
-
-  g_assert (G_IS_LIST_MODEL (model));
-  g_assert (G_IS_OBJECT (item));
-
-  n_items = g_list_model_get_n_items (model);
-
-  for (i = 0; i < n_items; i++)
-    {
-      g_autoptr(GObject) object = NULL;
-
-      object = g_list_model_get_item (model, i);
-
-      if (object == item)
-        return i;
-    }
-
-  return -1;
-}
-
-static CcWwanDevice *
-wwan_model_get_item_from_mm_object (GListModel *model,
-                                    MMObject   *mm_object)
-{
-  const gchar *modem_path, *device_path;
-  guint i, n_items;
-
-  n_items = g_list_model_get_n_items (model);
-  modem_path = mm_object_get_path (mm_object);
-
-  for (i = 0; i < n_items; i++)
-    {
-      g_autoptr(CcWwanDevice) device = NULL;
-
-      device = g_list_model_get_item (model, i);
-      device_path = cc_wwan_device_get_path (device);
-
-      if (g_str_equal (modem_path, device_path))
-        return g_steal_pointer (&device);
-    }
-
-  return NULL;
-}
-
-static CcDataDeviceRow *
-cc_data_device_row_new (CcWwanDevice *device,
-                        CcWwanPanel  *self)
-{
-  CcDataDeviceRow *row;
-  GtkWidget *box, *label, *image;
-  g_autofree gchar *operator = NULL;
-  gint index;
-
-  row = g_object_new (CC_TYPE_DATA_DEVICE_ROW, NULL);
-  row->device = device;
-
-  box = gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 12);
-  gtk_widget_show (box);
-  g_object_set (box, "margin", 12, NULL);
-  gtk_container_add (GTK_CONTAINER (row), box);
-
-  index = wwan_model_get_item_index (G_LIST_MODEL (self->devices), device);
-  operator = g_strdup_printf ("SIM %d", index + 1);
-  label = gtk_label_new (operator);
-  gtk_widget_show (label);
-  gtk_container_add (GTK_CONTAINER (box), label);
-
-  image = gtk_image_new_from_icon_name ("emblem-ok-symbolic", GTK_ICON_SIZE_BUTTON);
-  row->ok_emblem = GTK_IMAGE (image);
-  gtk_container_add (GTK_CONTAINER (box), image);
-
-  return row;
-}
-
-static void
-wwan_notification_close_clicked_cb (CcWwanPanel *self)
-{
-  gtk_revealer_set_reveal_child (self->notification_revealer, FALSE);
-
-  if (self->revealer_timeout_id != 0)
-    g_source_remove (self->revealer_timeout_id);
-
-  self->revealer_timeout_id = 0;
-}
-
-static void
-wwan_data_selector_clicked_cb (CcWwanPanel *self)
-{
-  if (gtk_widget_is_visible (GTK_WIDGET (self->data_select_popover)))
-    gtk_popover_popdown (self->data_select_popover);
-  else
-    gtk_popover_popup (self->data_select_popover);
-}
-
-static void
-cc_wwan_panel_update_data_selection (CcDataDeviceRow *row,
-                                     CcWwanPanel     *self)
-{
-  if (self->data_device == row->device)
-    {
-      g_autofree gchar *str = NULL;
-      gint i;
-
-      i = wwan_model_get_item_index (G_LIST_MODEL (self->devices), row->device);
-      g_assert (i >= 0);
-
-      /* Human index starts from 1 */
-      str = g_strdup_printf ("SIM %d", i + 1);
-      gtk_label_set_label (self->data_sim_label, str);
-
-      gtk_widget_show (GTK_WIDGET (row->ok_emblem));
-    }
-  else
-    {
-      gtk_widget_hide (GTK_WIDGET (row->ok_emblem));
-    }
-}
-
-static void
-cc_wwan_data_item_activate_cb (CcWwanPanel     *self,
-                               CcDataDeviceRow *row)
-{
-  CcWwanData *data;
-
-  gtk_popover_popdown (self->data_select_popover);
-
-  if (row->device == self->data_device)
-    return;
-
-  /* Set lower priority for previously selected APN */
-  data = cc_wwan_device_get_data (self->data_device);
-  cc_wwan_data_set_priority (data, CC_WWAN_APN_PRIORITY_LOW);
-  cc_wwan_data_save_settings (data, NULL, NULL, NULL);
-
-  /* Set high priority for currently selected APN */
-  data = cc_wwan_device_get_data (row->device);
-  cc_wwan_data_set_priority (data, CC_WWAN_APN_PRIORITY_HIGH);
-  cc_wwan_data_save_settings (data, NULL, NULL, NULL);
-
-  self->data_device = row->device;
-  gtk_container_foreach (GTK_CONTAINER (self->data_select_listbox),
-                         (GtkCallback) cc_wwan_panel_update_data_selection, self);
-}
-
-static void
-wwan_on_airplane_off_clicked_cb (CcWwanPanel *self)
-{
-  g_debug ("Airplane Mode Off clicked, disabling airplane mode");
-  g_dbus_proxy_call (self->rfkill_proxy,
-                     "org.freedesktop.DBus.Properties.Set",
-                     g_variant_new_parsed ("('org.gnome.SettingsDaemon.Rfkill',"
-                                           "'AirplaneMode', %v)",
-                                           g_variant_new_boolean (FALSE)),
-                     G_DBUS_CALL_FLAGS_NONE,
-                     -1,
-                     self->cancellable,
-                     NULL,
-                     NULL);
-}
-
-static gboolean
-cc_wwan_panel_get_cached_dbus_property (GDBusProxy  *proxy,
-                                        const gchar *property)
-{
-  g_autoptr(GVariant) result = NULL;
-
-  g_assert (G_IS_DBUS_PROXY (proxy));
-  g_assert (property && *property);
-
-  result = g_dbus_proxy_get_cached_property (proxy, property);
-  g_assert (!result || g_variant_is_of_type (result, G_VARIANT_TYPE_BOOLEAN));
-
-  return result ? g_variant_get_boolean (result) : FALSE;
-}
-
-static void
-cc_wwan_panel_update_view (CcWwanPanel *self)
-{
-  gboolean has_airplane, is_airplane = FALSE, enabled = FALSE;
-
-  has_airplane = cc_wwan_panel_get_cached_dbus_property (self->rfkill_proxy, "HasAirplaneMode");
-  has_airplane &= cc_wwan_panel_get_cached_dbus_property (self->rfkill_proxy, "ShouldShowAirplaneMode");
-
-  if (has_airplane)
-    {
-      is_airplane = cc_wwan_panel_get_cached_dbus_property (self->rfkill_proxy, "AirplaneMode");
-      is_airplane |= cc_wwan_panel_get_cached_dbus_property (self->rfkill_proxy, "HardwareAirplaneMode");
-    }
-
-  if (self->nm_client)
-    enabled = nm_client_wwan_get_enabled (self->nm_client);
-
-  if (has_airplane && is_airplane)
-    gtk_stack_set_visible_child_name (self->main_stack, "airplane-mode");
-  else if (enabled && g_list_model_get_n_items (G_LIST_MODEL (self->devices)) > 0)
-    gtk_stack_set_visible_child_name (self->main_stack, "device-settings");
-  else
-    gtk_stack_set_visible_child_name (self->main_stack, "no-wwan-devices");
-
-  gtk_widget_set_sensitive (GTK_WIDGET (self->enable_switch), !is_airplane);
-
-  if (enabled)
-    gtk_revealer_set_reveal_child (self->multi_device_revealer,
-                                   g_list_model_get_n_items (G_LIST_MODEL (self->devices)) > 1);
-}
-
-static void
-cc_wwan_panel_on_notification_closed (CcWwanPanel *self,
-                                      GtkWidget   *button)
-{
-  gtk_revealer_set_reveal_child (self->notification_revealer, FALSE);
-
-  if (self->revealer_timeout_id != 0)
-    g_source_remove (self->revealer_timeout_id);
-
-  self->revealer_timeout_id = 0;
-}
-
-static gboolean
-cc_wwan_panel_on_notification_timeout (gpointer user_data)
-{
-  cc_wwan_panel_on_notification_closed (user_data, NULL);
-
-  return G_SOURCE_REMOVE;
-}
-
-static void
-cc_wwan_panel_notification_changed_cb (CcWwanPanel *self)
-{
-  const gchar *label;
-
-  label = gtk_label_get_label (self->notification_label);
-
-  if (label && *label)
-    {
-      gtk_revealer_set_reveal_child (self->notification_revealer, TRUE);
-      self->revealer_timeout_id = g_timeout_add_seconds (5, cc_wwan_panel_on_notification_timeout, self);
-    }
-  else
-    {
-      cc_wwan_panel_on_notification_closed (self, NULL);
-    }
-}
-
-static void
-cc_wwan_panel_add_device (CcWwanPanel  *self,
-                          CcWwanDevice *device)
-{
-  CcWwanDevicePage *device_page;
-  g_autofree gchar *operator_name = NULL;
-  g_autofree gchar *stack_name = NULL;
-  guint n_items;
-
-  g_list_store_append (self->devices, device);
-
-  n_items = g_list_model_get_n_items (G_LIST_MODEL (self->devices));
-  operator_name = g_strdup_printf (_("SIM %d"), n_items);
-  stack_name = g_strdup_printf ("sim-%d", n_items);
-
-  device_page = cc_wwan_device_page_new (device, GTK_WIDGET (self->notification_label));
-  cc_wwan_device_page_set_sim_index (device_page, n_items);
-  gtk_stack_add_titled (self->devices_stack,
-                        GTK_WIDGET (device_page), stack_name, operator_name);
-}
-
-static void
-cc_wwan_panel_update_page_title (CcWwanDevicePage *device_page,
-                                 CcWwanPanel      *self)
-{
-  g_autofree gchar *title = NULL;
-  g_autofree gchar *name = NULL;
-  CcWwanDevice *device;
-  GtkWidget *parent;
-  gint index;
-
-  device = cc_wwan_device_page_get_device (device_page);
-
-  parent = gtk_widget_get_parent (GTK_WIDGET (device_page));
-  index  = wwan_model_get_item_index (G_LIST_MODEL (self->devices), device);
-
-  if (index == -1)
-    g_return_if_reached ();
-
-  /* index starts with 0, but we need human readable index to be 1+ */
-  cc_wwan_device_page_set_sim_index (device_page, index + 1);
-  title = g_strdup_printf (_("SIM %d"), index + 1);
-  name = g_strdup_printf ("sim-%d", index + 1);
-  gtk_container_child_set (GTK_CONTAINER (parent),
-                           GTK_WIDGET (device_page),
-                           "title", title,
-                           "name", name,
-                           NULL);
-}
-
-static void
-cc_wwan_panel_remove_mm_object (CcWwanPanel *self,
-                                MMObject    *mm_object)
-{
-  g_autoptr(CcWwanDevice) device = NULL;
-  GtkWidget *device_page;
-  g_autofree gchar *stack_name = NULL;
-  guint n_items;
-  gint index;
-
-  device = wwan_model_get_item_from_mm_object (G_LIST_MODEL (self->devices), mm_object);
-
-  if (!device)
-    return;
-
-  index = wwan_model_get_item_index (G_LIST_MODEL (self->data_devices), device);
-  if (index != -1)
-    g_list_store_remove (self->data_devices, index);
-
-  index = wwan_model_get_item_index (G_LIST_MODEL (self->devices), device);
-  if (index == -1)
-    return;
-
-  g_list_store_remove (self->devices, index);
-  stack_name = g_strdup_printf ("sim-%d", index + 1);
-  device_page = gtk_stack_get_child_by_name (self->devices_stack, stack_name);
-  gtk_container_remove (GTK_CONTAINER (self->devices_stack), device_page);
-
-  n_items = g_list_model_get_n_items (G_LIST_MODEL (self->data_devices));
-  g_list_model_items_changed (G_LIST_MODEL (self->data_devices), 0, n_items, n_items);
-  gtk_container_foreach (GTK_CONTAINER (self->devices_stack),
-                         (GtkCallback)cc_wwan_panel_update_page_title,
-                         self);
-}
-
-static void
-cc_wwan_panel_update_data_connections (CcWwanPanel *self)
-{
-  CcWwanData *device_data, *active_data = NULL;
-  guint n_items;
-  gint i;
-
-  /*
-   * We can’t predict the order in which the data of device is enabled.
-   * But we have to keep data store in the same order as device store.
-   * So let’s remove every data device and re-add.
-   */
-  g_list_store_remove_all (self->data_devices);
-  n_items = g_list_model_get_n_items (G_LIST_MODEL (self->devices));
-
-  for (i = 0; i < n_items; i++)
-    {
-      g_autoptr(CcWwanDevice) device = NULL;
-
-      device = g_list_model_get_item (G_LIST_MODEL (self->devices), i);
-      device_data = cc_wwan_device_get_data (device);
-
-      if (!device_data)
-        continue;
-
-      if ((!active_data ||
-           cc_wwan_data_get_priority (device_data) > cc_wwan_data_get_priority (active_data)) &&
-          cc_wwan_data_get_enabled (device_data))
-        {
-          active_data = device_data;
-          self->data_device = device;
-        }
-
-      if (cc_wwan_data_get_enabled (device_data))
-        g_list_store_append (self->data_devices, device);
-    }
-
-  gtk_widget_set_sensitive (GTK_WIDGET (self->data_sim_select_listbox),
-                            g_list_model_get_n_items (G_LIST_MODEL (self->data_devices)) > 1);
-  if (active_data)
-    gtk_container_foreach (GTK_CONTAINER (self->data_select_listbox),
-                           (GtkCallback)cc_wwan_panel_update_data_selection, self);
-  else
-    gtk_label_set_label (self->data_sim_label, "");
-}
-
-static void
-cc_wwan_panel_update_devices (CcWwanPanel *self)
-{
-  GList *devices, *iter;
-
-  devices = g_dbus_object_manager_get_objects (G_DBUS_OBJECT_MANAGER (self->mm_manager));
-
-  for (iter = devices; iter; iter = iter->next)
-    {
-      MMObject *mm_object = iter->data;
-      CcWwanDevice *device;
-
-      if(!wwan_panel_device_is_supported (iter->data))
-        continue;
-
-      device = cc_wwan_device_new (mm_object, G_OBJECT (self->nm_client));
-      cc_wwan_panel_add_device (self, device);
-      g_signal_connect_object (device, "notify::has-data",
-                               G_CALLBACK (cc_wwan_panel_update_data_connections),
-                               self, G_CONNECT_SWAPPED);
-
-      if (cc_wwan_device_get_data (device))
-        g_list_store_append (self->data_devices, device);
-    }
-
-  cc_wwan_panel_update_data_connections (self);
-  handle_argv (self);
-}
-
-static void
-wwan_panel_device_added_cb (CcWwanPanel *self,
-                            GDBusObject *object)
-{
-  CcWwanDevice *device;
-
-  if(!wwan_panel_device_is_supported (object))
-    return;
-
-  device = cc_wwan_device_new (MM_OBJECT (object), G_OBJECT (self->nm_client));
-  cc_wwan_panel_add_device (self, device);
-  g_signal_connect_object (device, "notify::has-data",
-                           G_CALLBACK (cc_wwan_panel_update_data_connections),
-                           self, G_CONNECT_SWAPPED);
-  cc_wwan_panel_update_view (self);
-  handle_argv (self);
-}
-
-static void
-wwan_panel_device_removed_cb (CcWwanPanel *self,
-                              GDBusObject *object)
-{
-  if (!wwan_panel_device_is_supported (object))
-    return;
-
-  cc_wwan_panel_remove_mm_object (self, MM_OBJECT (object));
-
-  gtk_revealer_set_reveal_child (self->multi_device_revealer,
-                                 g_list_model_get_n_items (G_LIST_MODEL (self->devices)) > 1);
-}
-
-static GPtrArray *
-variant_av_to_string_array (GVariant *array)
-{
-  GVariant *v;
-  GPtrArray *strv;
-  GVariantIter iter;
-  gsize count;
-
-  count = g_variant_iter_init (&iter, array);
-  strv = g_ptr_array_sized_new (count + 1);
-
-  while (g_variant_iter_next (&iter, "v", &v))
-    {
-      g_ptr_array_add (strv, (gpointer)g_variant_get_string (v, NULL));
-      g_variant_unref (v);
-    }
-  g_ptr_array_add (strv, NULL); /* NULL-terminate the strv data array */
-
-  return strv;
-}
-
-static void
-cc_wwan_panel_set_property (GObject      *object,
-                            guint         property_id,
-                            const GValue *value,
-                            GParamSpec   *pspec)
-{
-  CcWwanPanel *self = CC_WWAN_PANEL (object);
-
-  switch (property_id)
-    {
-    case PROP_PARAMETERS:
-      {
-        GVariant *parameters;
-
-        reset_command_line_args (self);
-
-        parameters = g_value_get_variant (value);
-        if (parameters)
-          {
-            g_autoptr(GPtrArray) array = NULL;
-            const gchar **args;
-
-            array = variant_av_to_string_array (parameters);
-            args = (const gchar **) array->pdata;
-
-            g_debug ("Invoked with operation %s", args[0]);
-
-            if (args[0])
-              self->arg_operation = cmdline_operation_from_string (args[0]);
-            if (args[0] && args[1])
-              self->arg_device = g_strdup (args[1]);
-
-            if (!verify_argv (self, (const char **) args))
-              {
-                reset_command_line_args (self);
-                return;
-              }
-            g_debug ("Calling handle_argv() after setting property");
-            handle_argv (self);
-          }
-        break;
-      }
-    default:
-      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
-    }
-}
-
-static void
-cc_wwan_panel_constructed (GObject *object)
-{
-  CcWwanPanel *self = (CcWwanPanel *)object;
-
-  G_OBJECT_CLASS (cc_wwan_panel_parent_class)->constructed (object);
-
-	cc_shell_embed_widget_in_header (cc_panel_get_shell (CC_PANEL (self)),
-                                   GTK_WIDGET (self->enable_switch), GTK_POS_RIGHT);
-
-  if (self->nm_client)
-    {
-      g_object_bind_property (self->nm_client, "wwan-enabled",
-                              self->enable_switch, "active",
-                              G_BINDING_BIDIRECTIONAL | G_BINDING_SYNC_CREATE);
-    }
-}
-
-static void
-cc_wwan_panel_dispose (GObject *object)
-{
-  CcWwanPanel *self = (CcWwanPanel *)object;
-
-  if (self->revealer_timeout_id != 0)
-    g_source_remove (self->revealer_timeout_id);
-
-  self->revealer_timeout_id = 0;
-
-  g_cancellable_cancel (self->cancellable);
-
-  g_clear_object (&self->devices);
-  g_clear_object (&self->data_devices);
-  g_clear_object (&self->mm_manager);
-  g_clear_object (&self->nm_client);
-  g_clear_object (&self->cancellable);
-  g_clear_object (&self->rfkill_proxy);
-  g_clear_pointer (&self->arg_device, g_free);
-
-  G_OBJECT_CLASS (cc_wwan_panel_parent_class)->dispose (object);
-}
-
-static void
-cc_wwan_panel_class_init (CcWwanPanelClass *klass)
-{
-  GtkWidgetClass *widget_class = GTK_WIDGET_CLASS (klass);
-  GObjectClass *object_class = G_OBJECT_CLASS (klass);
-
-  object_class->set_property = cc_wwan_panel_set_property;
-  object_class->constructed = cc_wwan_panel_constructed;
-  object_class->dispose = cc_wwan_panel_dispose;
-
-  g_object_class_override_property (object_class, PROP_PARAMETERS, "parameters");
-
-  gtk_widget_class_set_template_from_resource (widget_class,
-                                               "/org/gnome/control-center/wwan/cc-wwan-panel.ui");
-
-  gtk_widget_class_bind_template_child (widget_class, CcWwanPanel, data_select_listbox);
-  gtk_widget_class_bind_template_child (widget_class, CcWwanPanel, data_select_popover);
-  gtk_widget_class_bind_template_child (widget_class, CcWwanPanel, data_sim_label);
-  gtk_widget_class_bind_template_child (widget_class, CcWwanPanel, data_sim_select_listbox);
-  gtk_widget_class_bind_template_child (widget_class, CcWwanPanel, devices_stack);
-  gtk_widget_class_bind_template_child (widget_class, CcWwanPanel, devices_switcher);
-  gtk_widget_class_bind_template_child (widget_class, CcWwanPanel, enable_switch);
-  gtk_widget_class_bind_template_child (widget_class, CcWwanPanel, main_stack);
-  gtk_widget_class_bind_template_child (widget_class, CcWwanPanel, multi_device_revealer);
-  gtk_widget_class_bind_template_child (widget_class, CcWwanPanel, notification_label);
-  gtk_widget_class_bind_template_child (widget_class, CcWwanPanel, notification_revealer);
-
-  gtk_widget_class_bind_template_callback (widget_class, wwan_on_airplane_off_clicked_cb);
-  gtk_widget_class_bind_template_callback (widget_class, wwan_notification_close_clicked_cb);
-  gtk_widget_class_bind_template_callback (widget_class, wwan_data_selector_clicked_cb);
-  gtk_widget_class_bind_template_callback (widget_class, cc_wwan_data_item_activate_cb);
-}
-
-static void
-cc_wwan_panel_init (CcWwanPanel *self)
-{
-  g_autoptr(GError) error = NULL;
-
-  g_resources_register (cc_wwan_get_resource ());
-
-  gtk_widget_init_template (GTK_WIDGET (self));
-
-  self->cancellable = g_cancellable_new ();
-  self->devices = g_list_store_new (CC_TYPE_WWAN_DEVICE);
-  self->data_devices = g_list_store_new (CC_TYPE_WWAN_DEVICE);
-  gtk_list_box_bind_model (GTK_LIST_BOX (self->data_select_listbox),
-                           G_LIST_MODEL (self->data_devices),
-                           (GtkListBoxCreateWidgetFunc) cc_data_device_row_new,
-                           self, NULL);
-
-  g_signal_connect_object (self->notification_label, "notify::label",
-                           G_CALLBACK (cc_wwan_panel_notification_changed_cb),
-                           self, G_CONNECT_SWAPPED);
-
-  if (cc_object_storage_has_object (CC_OBJECT_NMCLIENT))
-    {
-      self->nm_client = cc_object_storage_get_object (CC_OBJECT_NMCLIENT);
-      g_signal_connect_object (self->nm_client,
-                               "notify::wwan-enabled",
-                               G_CALLBACK (cc_wwan_panel_update_view),
-                               self, G_CONNECT_SWAPPED);
-
-    }
-  else
-    {
-      g_warn_if_reached ();
-    }
-
-  if (cc_object_storage_has_object ("CcObjectStorage::mm-manager"))
-    {
-      self->mm_manager = cc_object_storage_get_object ("CcObjectStorage::mm-manager");
-
-      g_signal_connect_object (self->mm_manager, "object-added",
-                               G_CALLBACK (wwan_panel_device_added_cb),
-                               self, G_CONNECT_SWAPPED);
-      g_signal_connect_object (self->mm_manager, "object-removed",
-                               G_CALLBACK (wwan_panel_device_removed_cb),
-                               self, G_CONNECT_SWAPPED);
-
-      cc_wwan_panel_update_devices (self);
-    }
-  else
-    {
-      g_warn_if_reached ();
-    }
-
-  /* Acquire Airplane Mode proxy */
-  self->rfkill_proxy = cc_object_storage_create_dbus_proxy_sync (G_BUS_TYPE_SESSION,
-                                                                 G_DBUS_PROXY_FLAGS_NONE,
-                                                                 "org.gnome.SettingsDaemon.Rfkill",
-                                                                 "/org/gnome/SettingsDaemon/Rfkill",
-                                                                 "org.gnome.SettingsDaemon.Rfkill",
-                                                                 self->cancellable,
-                                                                 &error);
-
-  if (error)
-    {
-      if (!g_error_matches (error, G_IO_ERROR, G_IO_ERROR_CANCELLED))
-        g_printerr ("Error creating rfkill proxy: %s\n", error->message);
-    }
-  else
-    {
-      g_signal_connect_object (self->rfkill_proxy,
-                               "g-properties-changed",
-                               G_CALLBACK (cc_wwan_panel_update_view),
-                               self, G_CONNECT_SWAPPED);
-
-      cc_wwan_panel_update_view (self);
-    }
-}
-
-static void
-wwan_update_panel_visibility (MMManager *mm_manager)
-{
-  CcApplication *application;
-  GList *devices;
-  gboolean has_wwan;
-
-  g_assert (MM_IS_MANAGER (mm_manager));
-
-  CC_TRACE_MSG ("Updating WWAN panel visibility");
-
-  has_wwan = FALSE;
-  devices = g_dbus_object_manager_get_objects (G_DBUS_OBJECT_MANAGER (mm_manager));
-
-  for (GList *item = devices; item != NULL; item = item->next)
-    {
-      if(wwan_panel_device_is_supported (item->data))
-        {
-          has_wwan = TRUE;
-          break;
-        }
-    }
-
-  /* Set the new visibility */
-  application = CC_APPLICATION (g_application_get_default ());
-  cc_shell_model_set_panel_visibility (cc_application_get_model (application),
-                                       "wwan",
-                                       has_wwan ? CC_PANEL_VISIBLE : CC_PANEL_VISIBLE_IN_SEARCH);
-
-  g_debug ("WWAN panel visible: %s", has_wwan ? "yes" : "no");
-
-  g_list_free_full (devices, (GDestroyNotify)g_object_unref);
-}
-
-void
-cc_wwan_panel_static_init_func (void)
-{
-  g_autoptr(GDBusConnection) system_bus = NULL;
-  g_autoptr(MMManager) mm_manager = NULL;
-  g_autoptr(GError) error = NULL;
-
-  /*
-   * There could be other modems that are only handled by rfkill,
-   * and not available via ModemManager.  But as this panel
-   * makes use of ModemManager APIs, we only care devices
-   * supported by ModemManager.
-   */
-  system_bus = g_bus_get_sync (G_BUS_TYPE_SYSTEM, NULL, &error);
-  if (system_bus == NULL)
-    g_warning ("Error connecting to system D-Bus: %s", error->message);
-  else
-    mm_manager = mm_manager_new_sync (system_bus,
-                                      G_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_NONE,
-                                      NULL, &error);
-
-  if (mm_manager == NULL)
-    {
-      CcApplication *application;
-
-      g_warning ("Error connecting to ModemManager: %s", error->message);
-
-      application = CC_APPLICATION (g_application_get_default ());
-      cc_shell_model_set_panel_visibility (cc_application_get_model (application),
-                                           "wwan", FALSE);
-      return;
-    }
-  else
-    {
-      cc_object_storage_add_object ("CcObjectStorage::mm-manager", mm_manager);
-    }
-
-  g_debug ("Monitoring ModemManager for WWAN devices");
-
-  g_signal_connect (mm_manager, "object-added", G_CALLBACK (wwan_update_panel_visibility), NULL);
-  g_signal_connect (mm_manager, "object-removed", G_CALLBACK (wwan_update_panel_visibility), NULL);
-
-  wwan_update_panel_visibility (mm_manager);
-}
diff --git a/panels/wwan/cc-wwan-panel.h b/panels/wwan/cc-wwan-panel.h
deleted file mode 100644
index 57d2dae..0000000
--- a/panels/wwan/cc-wwan-panel.h
+++ /dev/null
@@ -1,36 +0,0 @@
-/* -*- Mode: C; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* cc-wwan-panel.h
- *
- * Copyright 2019 Purism SPC
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- *
- * Author(s):
- *   Mohammed Sadiq <sadiq@sadiqpk.org>
- *
- * SPDX-License-Identifier: GPL-3.0-or-later
- */
-
-#pragma once
-
-#include <shell/cc-panel.h>
-
-G_BEGIN_DECLS
-
-#define CC_TYPE_WWAN_PANEL (cc_wwan_panel_get_type())
-G_DECLARE_FINAL_TYPE (CcWwanPanel, cc_wwan_panel, CC, WWAN_PANEL, CcPanel)
-
-void                 cc_wwan_panel_static_init_func              (void);
-
-G_END_DECLS
diff --git a/panels/wwan/cc-wwan-panel.ui b/panels/wwan/cc-wwan-panel.ui
deleted file mode 100644
index 5258c42..0000000
--- a/panels/wwan/cc-wwan-panel.ui
+++ /dev/null
@@ -1,336 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<interface>
-  <template class="CcWwanPanel" parent="CcPanel">
-    <property name="visible">1</property>
-
-    <child>
-      <object class="GtkOverlay">
-        <property name="visible">1</property>
-
-        <!-- Notification Revealer -->
-        <child type="overlay">
-          <object class="GtkRevealer" id="notification_revealer">
-            <property name="visible">1</property>
-            <property name="halign">center</property>
-            <property name="valign">start</property>
-            <child>
-              <object class="GtkBox">
-                <property name="visible">1</property>
-                <property name="spacing">12</property>
-                <style>
-                  <class name="frame" />
-                  <class name="app-notification" />
-                </style>
-                <child>
-                  <object class="GtkLabel" id="notification_label">
-                    <property name="visible">1</property>
-                    <property name="wrap">1</property>
-                    <property name="wrap-mode">word</property>
-                    <property name="use-markup">1</property>
-                  </object>
-                </child>
-                <child>
-                  <object class="GtkButton">
-                    <property name="visible">1</property>
-                    <property name="relief">none</property>
-                    <signal name="clicked" handler="wwan_notification_close_clicked_cb" swapped="yes" />
-                    <child internal-child="accessible">
-                      <object class="AtkObject">
-                        <property name="accessible-name" translatable="yes">Close</property>
-                      </object>
-                    </child>
-                    <child>
-                      <object class="GtkImage">
-                        <property name="visible">1</property>
-                        <property name="icon-name">window-close-symbolic</property>
-                      </object>
-                    </child>
-                  </object>
-                </child>
-              </object>
-            </child>
-          </object>
-        </child>
-
-        <child>
-          <object class="GtkScrolledWindow">
-            <property name="visible">1</property>
-            <property name="hscrollbar-policy">never</property>
-            <property name="min-content-height">500</property>
-            <child>
-              <object class="HdyClamp">
-                <property name="visible">1</property>
-                <property name="margin-top">0</property>
-                <property name="margin-bottom">32</property>
-                <property name="margin-start">18</property>
-                <property name="margin-end">18</property>
-
-                <child>
-                  <object class="GtkBox">
-                    <property name="visible">1</property>
-                    <property name="hexpand">1</property>
-                    <property name="orientation">vertical</property>
-                    <child>
-                      <object class="GtkStack" id="main_stack">
-                        <property name="visible">1</property>
-                        <property name="homogeneous">0</property>
-                        <property name="transition-type">crossfade</property>
-
-                        <!-- "No WWAN Adapter" page -->
-                        <child>
-                          <object class="GtkBox">
-                            <property name="visible">1</property>
-                            <property name="expand">1</property>
-                            <property name="valign">center</property>
-                            <property name="orientation">vertical</property>
-                            <child>
-                              <object class="GtkImage">
-                                <property name="visible">1</property>
-                                <property name="icon-name">network-cellular-offline-symbolic</property>
-                                <property name="pixel-size">192</property>
-                                <property name="margin-bottom">18</property>
-                                <style>
-                                 <class name="dim-label" />
-                                </style>
-                              </object>
-                            </child>
-                            <child>
-                              <object class="GtkLabel">
-                                <property name="visible">1</property>
-                                <property name="wrap">1</property>
-                                <property name="label" translatable="yes">No WWAN Adapter Found</property>
-                                <attributes>
-                                  <attribute name="weight" value="bold" />
-                                  <attribute name="scale" value="1.2" />
-                                </attributes>
-                              </object>
-                            </child>
-                            <child>
-                              <object class="GtkLabel">
-                                <property name="visible">1</property>
-                                <property name="wrap">1</property>
-                                <property name="label" translatable="yes">Make sure you have a Wireless Wan/Cellular device</property>
-                              </object>
-                            </child>
-                          </object>
-                          <packing>
-                            <property name="name">no-wwan-devices</property>
-                          </packing>
-                        </child>
-
-                        <!-- "Airplane Mode" page -->
-                        <child>
-                          <object class="GtkBox">
-                            <property name="visible">1</property>
-                            <property name="expand">1</property>
-                            <property name="orientation">vertical</property>
-                            <property name="valign">center</property>
-                            <child>
-                              <object class="GtkImage">
-                                <property name="visible">1</property>
-                                <property name="icon-name">airplane-mode-symbolic</property>
-                                <property name="pixel-size">192</property>
-                                <property name="margin-bottom">18</property>
-                                <style>
-                                 <class name="dim-label" />
-                                </style>
-                              </object>
-                            </child>
-                            <child>
-                              <object class="GtkLabel">
-                                <property name="visible">1</property>
-                                <property name="wrap">1</property>
-                                <property name="label" translatable="yes">Airplane Mode On</property>
-                                <attributes>
-                                  <attribute name="weight" value="bold" />
-                                  <attribute name="scale" value="1.2" />
-                                </attributes>
-                              </object>
-                            </child>
-                            <child>
-                              <object class="GtkLabel">
-                                <property name="visible">1</property>
-                                <property name="wrap">1</property>
-                                <property name="label" translatable="yes">Wireless Wan is disabled when airplane mode is on</property>
-                              </object>
-                            </child>
-                            <child>
-                              <object class="GtkButton">
-                                <property name="visible">1</property>
-                                <property name="halign">center</property>
-                                <property name="use-underline">1</property>
-                                <property name="margin-top">24</property>
-                                <property name="label" translatable="yes">_Turn off Airplane Mode</property>
-                                <signal name="clicked" handler="wwan_on_airplane_off_clicked_cb" swapped="yes" />
-                              </object>
-                            </child>
-                          </object>
-                          <packing>
-                            <property name="name">airplane-mode</property>
-                          </packing>
-                        </child>
-
-                        <child>
-                          <object class="GtkBox">
-                            <property name="visible">1</property>
-                            <property name="orientation">vertical</property>
-
-                            <child>
-                              <object class="GtkRevealer" id="multi_device_revealer">
-                                <property name="visible">1</property>
-                                <property name="margin-top">18</property>
-                                <child>
-                                  <object class="GtkBox">
-                                    <property name="visible">1</property>
-                                    <property name="orientation">vertical</property>
-
-                                    <!-- Data SIM selector -->
-                                    <child>
-                                      <object class="GtkListBox" id="data_sim_select_listbox">
-                                        <property name="visible">1</property>
-                                        <property name="selection-mode">none</property>
-                                        <property name="margin-bottom">32</property>
-                                        <signal name="row-activated" handler="wwan_data_selector_clicked_cb" swapped="yes" />
-                                        <style>
-                                         <class name="frame" />
-                                        </style>
-                                        <child>
-                                          <object class="GtkGrid">
-                                            <property name="visible">1</property>
-                                            <property name="border-width">9</property>
-                                            <property name="margin-start">9</property>
-                                            <property name="margin-end">9</property>
-                                            <property name="column-spacing">12</property>
-
-                                            <!-- Title -->
-                                            <child>
-                                              <object class="GtkLabel">
-                                                <property name="visible">1</property>
-                                                <property name="hexpand">1</property>
-                                                <property name="label" translatable="yes">Data Connection</property>
-                                                <property name="xalign">0.0</property>
-                                              </object>
-                                              <packing>
-                                                <property name="left-attach">0</property>
-                                                <property name="top-attach">0</property>
-                                              </packing>
-                                            </child>
-
-                                            <!-- SubTitle -->
-                                            <child>
-                                              <object class="GtkLabel">
-                                                <property name="visible">1</property>
-                                                <property name="hexpand">1</property>
-                                                <property name="label" translatable="yes">SIM card used for internet</property>
-                                                <property name="xalign">0.0</property>
-                                                <attributes>
-                                                  <attribute name="scale" value="0.88" />
-                                                </attributes>
-                                                <style>
-                                                  <class name="dim-label" />
-                                                </style>
-                                              </object>
-                                              <packing>
-                                                <property name="left-attach">0</property>
-                                                <property name="top-attach">1</property>
-                                              </packing>
-                                            </child>
-
-                                            <!-- Network Name -->
-                                            <child>
-                                              <object class="GtkLabel" id="data_sim_label">
-                                                <property name="visible">1</property>
-                                                <property name="valign">center</property>
-                                              </object>
-                                              <packing>
-                                                <property name="left-attach">1</property>
-                                                <property name="top-attach">0</property>
-                                                <property name="height">2</property>
-                                              </packing>
-                                            </child>
-
-                                            <!-- Popover Arrow -->
-                                            <child>
-                                              <object class="GtkImage" id="popover_arrow">
-                                                <property name="visible">1</property>
-                                                <property name="valign">center</property>
-                                                <property name="icon-name">pan-down-symbolic</property>
-                                              </object>
-                                              <packing>
-                                                <property name="left-attach">2</property>
-                                                <property name="top-attach">0</property>
-                                                <property name="height">2</property>
-                                              </packing>
-                                            </child>
-
-                                          </object>
-                                        </child>
-                                      </object>
-                                    </child>
-
-                                    <!-- Device (SIM) Name -->
-                                    <child>
-                                      <object class="GtkStackSwitcher" id="devices_switcher">
-                                        <property name="stack">devices_stack</property>
-                                        <property name="visible">1</property>
-                                        <property name="hexpand">1</property>
-                                        <property name="halign">center</property>
-                                      </object>
-                                    </child>
-
-                                  </object>
-                                </child>
-                              </object>
-                            </child>
-
-                            <!-- Device (SIM) settings page -->
-                            <child>
-                              <object class="GtkStack" id="devices_stack">
-                                <property name="visible">1</property>
-                                <property name="homogeneous">0</property>
-                              </object>
-                            </child>
-
-                          </object>
-                          <packing>
-                            <property name="name">device-settings</property>
-                          </packing>
-                        </child>
-
-                      </object> <!-- ./GtkStack main_stack -->
-                    </child>
-                  </object>
-                </child>
-
-              </object> <!-- ./HdyClamp -->
-            </child>
-          </object> <!-- ./GtkScrolledWindow -->
-        </child>
-
-      </object>
-    </child>
-
-  </template>
-
-  <object class="GtkPopover" id="data_select_popover">
-    <property name="position">bottom</property>
-    <property name="relative-to">popover_arrow</property>
-    <child>
-      <object class="GtkListBox" id="data_select_listbox">
-        <property name="visible">1</property>
-        <property name="selection-mode">none</property>
-        <signal name="row-activated" handler="cc_wwan_data_item_activate_cb" swapped="yes" />
-      </object>
-    </child>
-  </object>
-
-  <!-- Cellular panel on/off switch -->
-  <object class="GtkSwitch" id="enable_switch">
-    <property name="visible">1</property>
-    <child internal-child="accessible">
-      <object class="AtkObject">
-        <property name="accessible-name" translatable="yes">Enable Mobile Network</property>
-      </object>
-    </child>
-  </object>
-</interface>
diff --git a/panels/wwan/cc-wwan-sim-lock-dialog.c b/panels/wwan/cc-wwan-sim-lock-dialog.c
deleted file mode 100644
index 14adbf4..0000000
--- a/panels/wwan/cc-wwan-sim-lock-dialog.c
+++ /dev/null
@@ -1,310 +0,0 @@
-/* -*- Mode: C; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* cc-wwan-network-dialog.c
- *
- * Copyright 2019 Purism SPC
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- *
- * Author(s):
- *   Mohammed Sadiq <sadiq@sadiqpk.org>
- *
- * SPDX-License-Identifier: GPL-3.0-or-later
- */
-
-#undef G_LOG_DOMAIN
-#define G_LOG_DOMAIN "cc-wwan-sim-lock-dialog"
-
-#include <config.h>
-#include <glib/gi18n.h>
-#include <libmm-glib.h>
-
-#include "list-box-helper.h"
-#include "cc-list-row.h"
-#include "cc-wwan-sim-lock-dialog.h"
-#include "cc-wwan-resources.h"
-
-/**
- * @short_description: Dialog to manage SIM Locks like PIN
- */
-
-#define PIN_MINIMUM_LENGTH 4
-#define PIN_MAXIMUM_LENGTH 8
-
-struct _CcWwanSimLockDialog
-{
-  GtkDialog     parent_instance;
-
-  CcWwanDevice *device;
-
-  GtkButton    *apply_button;
-  GtkStack     *button_stack;
-  GtkGrid      *lock_change_grid;
-  CcListRow    *lock_row;
-  GtkEntry     *new_pin_entry;
-  GtkButton    *next_button;
-  GtkEntry     *pin_confirm_entry;
-  GtkEntry     *pin_entry;
-  GtkStack     *pin_settings_stack;
-};
-
-G_DEFINE_TYPE (CcWwanSimLockDialog, cc_wwan_sim_lock_dialog, GTK_TYPE_DIALOG)
-
-
-enum {
-  PROP_0,
-  PROP_DEVICE,
-  N_PROPS
-};
-
-static GParamSpec *properties[N_PROPS];
-
-static void
-cc_wwan_sim_lock_changed_cb (CcWwanSimLockDialog *self)
-{
-  gboolean row_enabled, lock_enabled;
-
-  lock_enabled = cc_wwan_device_get_sim_lock (self->device);
-  row_enabled = cc_list_row_get_active (self->lock_row);
-
-  gtk_widget_set_sensitive (GTK_WIDGET (self->next_button), lock_enabled != row_enabled);
-  gtk_widget_set_visible (GTK_WIDGET (self->lock_change_grid), row_enabled && lock_enabled);
-}
-
-static void
-cc_wwan_pin_next_clicked_cb (CcWwanSimLockDialog *self)
-{
-  gtk_stack_set_visible_child_name (self->pin_settings_stack, "pin-entry");
-  gtk_entry_set_text (self->pin_entry, "");
-
-  gtk_widget_set_sensitive (GTK_WIDGET (self->apply_button), FALSE);
-  gtk_stack_set_visible_child (self->button_stack,
-                               GTK_WIDGET (self->apply_button));
-}
-
-static void
-cc_wwan_pin_apply_clicked_cb (CcWwanSimLockDialog *self)
-{
-  const gchar *pin, *new_pin;
-  gboolean row_enabled, lock_enabled;
-
-  gtk_widget_hide (GTK_WIDGET (self));
-
-  lock_enabled = cc_wwan_device_get_sim_lock (self->device);
-  row_enabled = cc_list_row_get_active (self->lock_row);
-  pin = gtk_entry_get_text (self->pin_entry);
-  new_pin = gtk_entry_get_text (self->new_pin_entry);
-
-  if (lock_enabled != row_enabled)
-    {
-      if (row_enabled)
-        cc_wwan_device_enable_pin (self->device, pin, NULL, NULL, NULL);
-      else
-        cc_wwan_device_disable_pin (self->device, pin, NULL, NULL, NULL);
-
-      return;
-    }
-
-  cc_wwan_device_change_pin (self->device, pin, new_pin, NULL, NULL, NULL);
-}
-
-static void
-cc_wwan_pin_entry_text_inserted_cb (CcWwanSimLockDialog *self,
-                                    gchar               *new_text,
-                                    gint                 new_text_length,
-                                    gpointer             position,
-                                    GtkEditable         *editable)
-{
-  size_t digit_end;
-  size_t len;
-
-  if (!new_text || !*new_text)
-    return;
-
-  if (new_text_length == 1 && g_ascii_isdigit (*new_text))
-    return;
-
-  if (new_text_length == -1)
-    len = strlen (new_text);
-  else
-    len = new_text_length;
-
-  if (len == 1 && g_ascii_isdigit (*new_text))
-    return;
-
-  digit_end = strspn (new_text, "1234567890");
-
-  /* The maximum length possible for PIN is 8 */
-  if (len <= 8 &&  digit_end == len)
-    return;
-
-  g_signal_stop_emission_by_name (editable, "insert-text");
-  gtk_widget_error_bell (GTK_WIDGET (editable));
-}
-
-static void
-cc_wwan_pin_entry_changed_cb (CcWwanSimLockDialog *self)
-{
-  const gchar *new_pin, *confirm_pin;
-
-  new_pin = gtk_entry_get_text (self->new_pin_entry);
-  confirm_pin = gtk_entry_get_text (self->pin_confirm_entry);
-  gtk_widget_set_sensitive (GTK_WIDGET (self->next_button), FALSE);
-
-  /* A PIN should have a minimum length of 4 */
-  if (!new_pin || !confirm_pin || strlen (new_pin) < 4)
-    return;
-
-  if (g_str_equal (new_pin, confirm_pin))
-    gtk_widget_set_sensitive (GTK_WIDGET (self->next_button), TRUE);
-}
-
-
-static void
-cc_wwan_pin_entered_cb (CcWwanSimLockDialog *self)
-{
-  const gchar *pin;
-  gsize len;
-  gboolean enable_apply;
-
-  pin = gtk_entry_get_text (self->pin_entry);
-
-  if (!pin || !*pin)
-    {
-      gtk_widget_set_sensitive (GTK_WIDGET (self->apply_button), FALSE);
-      return;
-    }
-
-  len = strlen (pin);
-  enable_apply = len >= PIN_MINIMUM_LENGTH && len <= PIN_MAXIMUM_LENGTH;
-
-  gtk_widget_set_sensitive (GTK_WIDGET (self->apply_button), enable_apply);
-}
-
-static void
-cc_wwan_sim_lock_dialog_set_property (GObject      *object,
-                                      guint         prop_id,
-                                      const GValue *value,
-                                      GParamSpec   *pspec)
-{
-  CcWwanSimLockDialog *self = (CcWwanSimLockDialog *)object;
-
-  switch (prop_id)
-    {
-    case PROP_DEVICE:
-      self->device = g_value_dup_object (value);
-      break;
-
-    default:
-      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
-    }
-}
-
-static void
-cc_wwan_sim_lock_dialog_show (GtkWidget *widget)
-{
-  CcWwanSimLockDialog *self = (CcWwanSimLockDialog *)widget;
-  gboolean lock_enabled;
-
-  gtk_entry_set_text (self->pin_entry, "");
-  gtk_widget_set_sensitive (GTK_WIDGET (self->next_button), FALSE);
-  gtk_widget_set_sensitive (GTK_WIDGET (self->apply_button), FALSE);
-
-  lock_enabled = cc_wwan_device_get_sim_lock (self->device);
-  g_object_set (self->lock_row, "active", lock_enabled, NULL);
-  gtk_widget_set_visible (GTK_WIDGET (self->lock_change_grid), lock_enabled);
-
-  gtk_widget_set_sensitive (GTK_WIDGET (self->next_button), FALSE);
-  gtk_stack_set_visible_child (self->button_stack,
-                               GTK_WIDGET (self->next_button));
-  gtk_button_set_label (self->apply_button, _("_Set"));
-
-  gtk_stack_set_visible_child_name (self->pin_settings_stack, "pin-settings");
-
-  gtk_entry_set_text (self->pin_entry, "");
-  gtk_entry_set_text (self->new_pin_entry, "");
-  gtk_entry_set_text (self->pin_confirm_entry, "");
-
-  GTK_WIDGET_CLASS (cc_wwan_sim_lock_dialog_parent_class)->show (widget);
-}
-
-static void
-cc_wwan_sim_lock_dialog_dispose (GObject *object)
-{
-  CcWwanSimLockDialog *self = (CcWwanSimLockDialog *)object;
-
-  g_clear_object (&self->device);
-
-  G_OBJECT_CLASS (cc_wwan_sim_lock_dialog_parent_class)->dispose (object);
-}
-
-static void
-cc_wwan_sim_lock_dialog_class_init (CcWwanSimLockDialogClass *klass)
-{
-  GtkWidgetClass *widget_class = GTK_WIDGET_CLASS (klass);
-  GObjectClass *object_class = G_OBJECT_CLASS (klass);
-
-  object_class->set_property = cc_wwan_sim_lock_dialog_set_property;
-  object_class->dispose = cc_wwan_sim_lock_dialog_dispose;
-
-  widget_class->show = cc_wwan_sim_lock_dialog_show;
-
-  properties[PROP_DEVICE] =
-    g_param_spec_object ("device",
-                         "Device",
-                         "The WWAN Device",
-                         CC_TYPE_WWAN_DEVICE,
-                         G_PARAM_WRITABLE | G_PARAM_STATIC_STRINGS | G_PARAM_CONSTRUCT_ONLY);
-
-  g_object_class_install_properties (object_class, N_PROPS, properties);
-
-  gtk_widget_class_set_template_from_resource (widget_class,
-                                               "/org/gnome/control-center/wwan/cc-wwan-sim-lock-dialog.ui");
-
-  gtk_widget_class_bind_template_child (widget_class, CcWwanSimLockDialog, apply_button);
-  gtk_widget_class_bind_template_child (widget_class, CcWwanSimLockDialog, button_stack);
-  gtk_widget_class_bind_template_child (widget_class, CcWwanSimLockDialog, lock_change_grid);
-  gtk_widget_class_bind_template_child (widget_class, CcWwanSimLockDialog, lock_row);
-  gtk_widget_class_bind_template_child (widget_class, CcWwanSimLockDialog, new_pin_entry);
-  gtk_widget_class_bind_template_child (widget_class, CcWwanSimLockDialog, next_button);
-  gtk_widget_class_bind_template_child (widget_class, CcWwanSimLockDialog, pin_confirm_entry);
-  gtk_widget_class_bind_template_child (widget_class, CcWwanSimLockDialog, pin_entry);
-  gtk_widget_class_bind_template_child (widget_class, CcWwanSimLockDialog, pin_settings_stack);
-
-  gtk_widget_class_bind_template_callback (widget_class, cc_wwan_sim_lock_changed_cb);
-  gtk_widget_class_bind_template_callback (widget_class, cc_wwan_pin_next_clicked_cb);
-  gtk_widget_class_bind_template_callback (widget_class, cc_wwan_pin_apply_clicked_cb);
-  gtk_widget_class_bind_template_callback (widget_class, cc_wwan_pin_entry_text_inserted_cb);
-  gtk_widget_class_bind_template_callback (widget_class, cc_wwan_pin_entry_changed_cb);
-  gtk_widget_class_bind_template_callback (widget_class, cc_wwan_pin_entered_cb);
-}
-
-static void
-cc_wwan_sim_lock_dialog_init (CcWwanSimLockDialog *self)
-{
-  gtk_widget_init_template (GTK_WIDGET (self));
-}
-
-CcWwanSimLockDialog *
-cc_wwan_sim_lock_dialog_new (GtkWindow    *parent_window,
-                             CcWwanDevice *device)
-{
-  g_return_val_if_fail (GTK_IS_WINDOW (parent_window), NULL);
-  g_return_val_if_fail (CC_IS_WWAN_DEVICE (device), NULL);
-
-  return g_object_new (CC_TYPE_WWAN_SIM_LOCK_DIALOG,
-                       "transient-for", parent_window,
-                       "use-header-bar", 1,
-                       "device", device,
-                       NULL);
-}
diff --git a/panels/wwan/cc-wwan-sim-lock-dialog.h b/panels/wwan/cc-wwan-sim-lock-dialog.h
deleted file mode 100644
index b6d1d5a..0000000
--- a/panels/wwan/cc-wwan-sim-lock-dialog.h
+++ /dev/null
@@ -1,40 +0,0 @@
-/* -*- Mode: C; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* cc-wwan-sim-lock-dialog.h
- *
- * Copyright 2019 Purism SPC
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- *
- * Author(s):
- *   Mohammed Sadiq <sadiq@sadiqpk.org>
- *
- * SPDX-License-Identifier: GPL-3.0-or-later
- */
-
-#pragma once
-
-#include <handy.h>
-#include <shell/cc-panel.h>
-
-#include "cc-wwan-device.h"
-
-G_BEGIN_DECLS
-
-#define CC_TYPE_WWAN_SIM_LOCK_DIALOG (cc_wwan_sim_lock_dialog_get_type())
-G_DECLARE_FINAL_TYPE (CcWwanSimLockDialog, cc_wwan_sim_lock_dialog, CC, WWAN_SIM_LOCK_DIALOG, GtkDialog)
-
-CcWwanSimLockDialog *cc_wwan_sim_lock_dialog_new (GtkWindow    *parent_window,
-                                                  CcWwanDevice *device);
-
-G_END_DECLS
diff --git a/panels/wwan/cc-wwan-sim-lock-dialog.ui b/panels/wwan/cc-wwan-sim-lock-dialog.ui
deleted file mode 100644
index 48a946b..0000000
--- a/panels/wwan/cc-wwan-sim-lock-dialog.ui
+++ /dev/null
@@ -1,306 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<interface>
-  <template class="CcWwanSimLockDialog" parent="GtkDialog">
-    <property name="default-height">480</property>
-    <property name="default-width">360</property>
-    <signal name="delete-event" handler="gtk_widget_hide_on_delete"/>
-
-    <child type="titlebar">
-      <object class="GtkHeaderBar">
-        <property name="visible">1</property>
-        <property name="title" translatable="yes">SIM Lock</property>
-        <child>
-          <object class="GtkStack" id="button_stack">
-            <property name="visible">1</property>
-
-            <!-- Next Buttoon -->
-            <child>
-              <object class="GtkButton" id="next_button">
-                <property name="visible">1</property>
-                <property name="sensitive">0</property>
-                <property name="use-underline">1</property>
-                <property name="label" translatable="yes">_Next</property>
-                <signal name="clicked" handler="cc_wwan_pin_next_clicked_cb" swapped="yes" />
-                <style>
-                 <class name="suggested-action" />
-                </style>
-              </object>
-              <packing>
-                <property name="name">next</property>
-              </packing>
-            </child>
-
-            <!-- Apply button -->
-            <child>
-              <object class="GtkButton" id="apply_button">
-                <property name="visible">1</property>
-                <property name="use-underline">1</property>
-                <signal name="clicked" handler="cc_wwan_pin_apply_clicked_cb" swapped="yes" />
-                <style>
-                 <class name="suggested-action" />
-                </style>
-              </object>
-              <packing>
-                <property name="name">apply</property>
-              </packing>
-            </child>
-
-          </object>
-          <packing>
-            <property name="pack-type">end</property>
-          </packing>
-        </child>
-      </object>
-    </child>
-
-    <child internal-child="vbox">
-      <object class="GtkBox">
-        <property name="visible">1</property>
-        <property name="border-width">0</property>
-        <property name="width-request">340</property>
-        <property name="height-request">360</property>
-
-        <child>
-          <object class="HdyClamp">
-            <property name="visible">1</property>
-            <property name="margin-top">32</property>
-            <property name="margin-bottom">32</property>
-            <property name="margin-start">18</property>
-            <property name="margin-end">18</property>
-            <child>
-              <object class="GtkOverlay">
-                <property name="visible">1</property>
-                <child type="overlay">
-                  <object class="GtkRevealer" id="notification_revealer">
-                    <property name="visible">1</property>
-                    <property name="halign">center</property>
-                    <property name="valign">start</property>
-                    <child>
-                      <object class="GtkBox">
-                        <property name="visible">1</property>
-                        <property name="spacing">12</property>
-                        <style>
-                         <class name="frame" />
-                         <class name="app-notification" />
-                        </style>
-                        <child>
-                          <object class="GtkLabel" id="notification_label">
-                            <property name="visible">1</property>
-                            <property name="wrap">1</property>
-                            <property name="wrap-mode">word-char</property>
-                            <property name="use-markup">1</property>
-                          </object>
-                        </child>
-                        <child>
-                          <object class="GtkButton">
-                            <property name="visible">1</property>
-                            <property name="relief">none</property>
-                            <!-- <signal name="clicked" handler="cc_wwan_on_notification_closed" object="CcWwanSimLockDialog" swapped="yes" /> -->
-                            <child internal-child="accessible">
-                              <object class="AtkObject">
-                                <property name="accessible-name" translatable="yes">Close</property>
-                              </object>
-                            </child>
-                            <child>
-                              <object class="GtkImage">
-                                <property name="visible">1</property>
-                                <property name="icon-name">window-close-symbolic</property>
-                              </object>
-                            </child>
-                          </object>
-                        </child>
-                      </object>
-                    </child>
-                  </object>
-                </child>
-
-                <child>
-                  <object class="GtkStack" id="pin_settings_stack">
-                    <property name="visible">1</property>
-                    <property name="transition-type">slide-left</property>
-
-                    <child>
-                      <object class="GtkBox">
-                        <property name="visible">1</property>
-                        <property name="orientation">vertical</property>
-
-                        <!-- SIM Lock Switch -->
-                        <child>
-                          <object class="GtkListBox">
-                            <property name="visible">1</property>
-                            <property name="selection-mode">none</property>
-                            <property name="margin-bottom">18</property>
-                            <style>
-                              <class name="frame" />
-                            </style>
-                            <child>
-                              <object class="CcListRow" id="lock_row">
-                                <property name="visible">1</property>
-                                <property name="show-switch">1</property>
-                                <property name="use-underline">1</property>
-                                <property name="title" translatable="yes">_Lock SIM with PIN</property>
-                                <signal name="notify::active" handler="cc_wwan_sim_lock_changed_cb" swapped="yes" />
-                              </object>
-                            </child>
-                          </object>
-                        </child>
-
-                        <child>
-                          <object class="GtkGrid" id="lock_change_grid">
-                            <property name="visible">0</property>
-                            <property name="row-spacing">18</property>
-                            <property name="column-spacing">12</property>
-
-                            <!-- SIM Lock Change Title -->
-                            <child>
-                              <object class="GtkLabel" id="lock_change_title">
-                                <property name="visible">1</property>
-                                <property name="label" translatable="yes">Change PIN</property>
-                                <property name="margin-bottom">9</property>
-                                <property name="xalign">0.0</property>
-                                <attributes>
-                                  <attribute name="weight" value="bold"/>
-                                </attributes>
-                              </object>
-                              <packing>
-                                <property name="left-attach">0</property>
-                                <property name="top-attach">0</property>
-                                <property name="width">2</property>
-                              </packing>
-                            </child>
-
-                            <!-- PIN Entry -->
-                            <child>
-                              <object class="GtkLabel">
-                                <property name="visible">1</property>
-                                <property name="label">New PIN</property>
-                                <property name="halign">end</property>
-                              </object>
-                              <packing>
-                                <property name="left-attach">0</property>
-                                <property name="top-attach">1</property>
-                              </packing>
-                            </child>
-                            <child>
-                              <object class="GtkEntry" id="new_pin_entry">
-                                <property name="visible">1</property>
-                                <property name="visibility">0</property>
-                                <property name="input-purpose">password</property>
-                                <property name="input-hints">no-emoji</property>
-                                <property name="max-length">8</property>
-                                <property name="max-width-chars">32</property>
-                                <signal name="notify::text" handler="cc_wwan_pin_entry_changed_cb" swapped="yes" />
-                                <signal name="insert-text" handler="cc_wwan_pin_entry_text_inserted_cb" swapped="yes" />
-                              </object>
-                              <packing>
-                                <property name="left-attach">1</property>
-                                <property name="top-attach">1</property>
-                              </packing>
-                            </child>
-
-                            <!-- Confirm PIN Entry -->
-                            <child>
-                              <object class="GtkLabel">
-                                <property name="visible">1</property>
-                                <property name="label">Confirm</property>
-                                <property name="halign">end</property>
-                              </object>
-                              <packing>
-                                <property name="left-attach">0</property>
-                                <property name="top-attach">2</property>
-                              </packing>
-                            </child>
-                            <child>
-                              <object class="GtkEntry" id="pin_confirm_entry">
-                                <property name="visible">1</property>
-                                <property name="visibility">0</property>
-                                <property name="input-purpose">password</property>
-                                <property name="input-hints">no-emoji</property>
-                                <property name="max-length">8</property>
-                                <property name="max-width-chars">32</property>
-                                <signal name="notify::text" handler="cc_wwan_pin_entry_changed_cb" swapped="yes" />
-                                <signal name="insert-text" handler="cc_wwan_pin_entry_changed_cb" swapped="yes" />
-                              </object>
-                              <packing>
-                                <property name="left-attach">1</property>
-                                <property name="top-attach">2</property>
-                              </packing>
-                            </child>
-
-                          </object>
-                        </child>
-
-                      </object>
-                      <packing>
-                        <property name="name">pin-settings</property>
-                      </packing>
-                    </child>
-
-                    <child>
-                      <object class="GtkBox">
-                        <property name="visible">1</property>
-                        <property name="orientation">vertical</property>
-                        <property name="expand">1</property>
-                        <property name="valign">center</property>
-                        <property name="halign">center</property>
-                        <child>
-                          <object class="GtkImage">
-                            <property name="visible">1</property>
-                            <property name="pixel-size">128</property>
-                            <property name="icon-name">dialog-password-symbolic</property>
-                          </object>
-                        </child>
-                        <child>
-                          <object class="GtkLabel" id="">
-                            <property name="visible">1</property>
-                            <property name="label" translatable="yes">Enter current PIN to change SIM lock settings</property>
-                            <property name="margin-bottom">24</property>
-                            <property name="halign">center</property>
-                            <style>
-                              <class name="dim-label" />
-                            </style>
-                          </object>
-                        </child>
-                        <child>
-                          <object class="GtkEntry" id="pin_entry">
-                            <property name="visible">1</property>
-                            <property name="visibility">0</property>
-                            <property name="input-purpose">password</property>
-                            <property name="input-hints">no-emoji</property>
-                            <property name="max-length">8</property>
-                            <property name="max-width-chars">32</property>
-                            <signal name="notify::text" handler="cc_wwan_pin_entered_cb" swapped="yes" />
-                            <signal name="insert-text" handler="cc_wwan_pin_entry_text_inserted_cb" swapped="yes" />
-                            <!-- We have custom widgets and no actions, so "activates-default" won't work -->
-                            <signal name="activate" handler="cc_wwan_pin_apply_clicked_cb" swapped="yes" />
-                          </object>
-                        </child>
-                      </object>
-                      <packing>
-                        <property name="name">pin-entry</property>
-                      </packing>
-                    </child>
-
-                  </object> <!-- ./GtkStack pin_settings_stack -->
-                </child>
-              </object>
-            </child>
-          </object>
-        </child>
-      </object>
-    </child> <!-- ./internal-child -->
-
-    <child type="action">
-      <object class="GtkButton" id="cancel_button">
-        <property name="visible">1</property>
-        <property name="use-underline">1</property>
-        <property name="label" translatable="yes">_Cancel</property>
-        <signal name="clicked" handler="gtk_widget_hide" swapped="yes"/>
-      </object>
-    </child>
-    <action-widgets>
-      <action-widget response="cancel">cancel_button</action-widget>
-    </action-widgets>
-
-  </template>
-</interface>
diff --git a/panels/wwan/gnome-wwan-panel.desktop.in.in b/panels/wwan/gnome-wwan-panel.desktop.in.in
deleted file mode 100644
index 351a8ed..0000000
--- a/panels/wwan/gnome-wwan-panel.desktop.in.in
+++ /dev/null
@@ -1,16 +0,0 @@
-[Desktop Entry]
-Name=Mobile Network
-Comment=Configure Telephony and mobile data connections
-Exec=gnome-control-center wwan
-# FIXME
-# Translators: Do NOT translate or transliterate this text (this is an icon file name)!
-Icon=network-cellular-signal-excellent
-Terminal=false
-Type=Application
-NoDisplay=true
-StartupNotify=true
-Categories=GNOME;GTK;Settings;X-GNOME-NetworkSettings;HardwareSettings;X-GNOME-Settings-Panel;X-GNOME-ConnectivitySettings;
-OnlyShowIn=GNOME;Unity;
-StartupNotify=true
-# Translators: Search terms to find the WWAN panel. Do NOT translate or localize the semicolons! The list MUST also end with a semicolon!
-Keywords=cellular;wwan;telephony;sim;mobile;
diff --git a/panels/wwan/meson.build b/panels/wwan/meson.build
deleted file mode 100644
index 8c1b02f..0000000
--- a/panels/wwan/meson.build
+++ /dev/null
@@ -1,61 +0,0 @@
-gcr_dep = [dependency('gcr-3')]
-
-deps = common_deps + network_manager_deps + gcr_dep + [polkit_gobject_dep]
-panels_list += cappletname
-desktop = 'gnome-@0@-panel.desktop'.format(cappletname)
-
-desktop_in = configure_file(
-          input : desktop + '.in.in',
-         output : desktop + '.in',
-  configuration : desktop_conf
-)
-
-i18n.merge_file(
-       desktop,
-         type : 'desktop',
-        input : desktop_in,
-       output : desktop,
-       po_dir : po_dir,
-      install : true,
-  install_dir : control_center_desktopdir
-)
-
-sources = files(
-  'cc-wwan-panel.c',
-  'cc-wwan-device.c',
-  'cc-wwan-data.c',
-  'cc-wwan-device-page.c',
-  'cc-wwan-mode-dialog.c',
-  'cc-wwan-network-dialog.c',
-  'cc-wwan-details-dialog.c',
-  'cc-wwan-sim-lock-dialog.c',
-  'cc-wwan-apn-dialog.c',
-)
-
-resource_data = files(
-  'cc-wwan-panel.ui',
-  'cc-wwan-device-page.ui',
-  'cc-wwan-mode-dialog.ui',
-  'cc-wwan-network-dialog.ui',
-  'cc-wwan-details-dialog.ui',
-  'cc-wwan-sim-lock-dialog.ui',
-  'cc-wwan-apn-dialog.ui',
-)
-
-sources += gnome.compile_resources(
-  'cc-' + cappletname + '-resources',
-  cappletname + '.gresource.xml',
-        c_name : 'cc_' + cappletname,
-  dependencies : resource_data,
-        export : true
-)
-
-cflags += '-DGNOMELOCALEDIR="@0@"'.format(control_center_localedir)
-
-panels_libs += static_library(
-           cappletname,
-              sources : sources,
-  include_directories : [ top_inc, common_inc ],
-         dependencies : deps,
-               c_args : cflags
-)
diff --git a/panels/wwan/wwan.gresource.xml b/panels/wwan/wwan.gresource.xml
deleted file mode 100644
index f128a16..0000000
--- a/panels/wwan/wwan.gresource.xml
+++ /dev/null
@@ -1,12 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<gresources>
-  <gresource prefix="/org/gnome/control-center/wwan">
-    <file preprocess="xml-stripblanks">cc-wwan-panel.ui</file>
-    <file preprocess="xml-stripblanks">cc-wwan-device-page.ui</file>
-    <file preprocess="xml-stripblanks">cc-wwan-mode-dialog.ui</file>
-    <file preprocess="xml-stripblanks">cc-wwan-network-dialog.ui</file>
-    <file preprocess="xml-stripblanks">cc-wwan-details-dialog.ui</file>
-    <file preprocess="xml-stripblanks">cc-wwan-sim-lock-dialog.ui</file>
-    <file preprocess="xml-stripblanks">cc-wwan-apn-dialog.ui</file>
-  </gresource>
-</gresources>
